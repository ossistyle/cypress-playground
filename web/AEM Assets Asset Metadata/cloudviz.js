d3 = function() {
  var d3 = {
    version: "3.3.13"
  };
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
  try {
    d3_array(d3_documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = function(list) {
      var i = list.length, array = new Array(i);
      while (i--) array[i] = list[i];
      return array;
    };
  }
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_element_prototype.setAttribute = function(name, value) {
      d3_element_setAttribute.call(this, name, value + "");
    };
    d3_element_prototype.setAttributeNS = function(space, local, value) {
      d3_element_setAttributeNS.call(this, space, local, value + "");
    };
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && !((a = c = array[i]) != null && a <= a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && !((a = c = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  d3.map = function(object) {
    var map = new d3_Map();
    if (object instanceof d3_Map) object.forEach(function(key, value) {
      map.set(key, value);
    }); else for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {}
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\x00", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {}
  d3_class(d3_Set, {
    has: function(value) {
      return d3_map_prefix + value in this;
    },
    add: function(value) {
      this[d3_map_prefix + value] = true;
      return value;
    },
    remove: function(value) {
      value = d3_map_prefix + value;
      return value in this && delete this[value];
    },
    values: function() {
      var values = [];
      this.forEach(function(value) {
        values.push(value);
      });
      return values;
    },
    forEach: function(f) {
      for (var value in this) {
        if (value.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, value.substring(1));
        }
      }
    }
  });
  d3.behavior = {};
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.substring(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatcher = d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3_selectionRoot;
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return name.trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    } : function() {
      return this.ownerDocument.createElementNS(this.namespaceURI, name);
    };
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (node = nodeByKeyValue.get(keyValue)) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          } else if (!dataByKeyValue.has(keyValue)) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
          dataByKeyValue.set(keyValue, nodeData);
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    this.each(function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_selectionPrototype.interrupt = function() {
    return this.each(d3_selection_interrupt);
  };
  function d3_selection_interrupt() {
    var lock = this.__transition__;
    if (lock) ++lock.active;
  }
  d3.select = function(node) {
    var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  var d3_selectionRoot = d3.select(d3_documentElement);
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.substring(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  d3_selection_onFilters.forEach(function(k) {
    if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
  });
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
  function d3_event_dragSuppress() {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect) {
      var style = d3_documentElement.style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        function off() {
          w.on(click, null);
        }
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select("body").append("svg").style({
          position: "absolute",
          top: 0,
          left: 0,
          margin: 0,
          padding: 0,
          border: "none"
        }, "important");
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, "mousemove", "mouseup"), touchstart = dragstart(touchid, touchposition, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function touchid() {
      return d3.event.changedTouches[0].identifier;
    }
    function touchposition(parent, id) {
      return d3.touches(parent).filter(function(p) {
        return p.identifier === id;
      })[0];
    }
    function dragstart(id, position, move, end) {
      return function() {
        var target = this, parent = target.parentNode, event_ = event.of(target, arguments), eventTarget = d3.event.target, eventId = id(), drag = eventId == null ? "drag" : "drag-" + eventId, origin_ = position(parent, eventId), dragged = 0, offset, w = d3.select(d3_window).on(move + "." + drag, moved).on(end + "." + drag, ended), dragRestore = d3_event_dragSuppress();
        if (origin) {
          offset = origin.apply(target, arguments);
          offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
        } else {
          offset = [ 0, 0 ];
        }
        event_({
          type: "dragstart"
        });
        function moved() {
          var p = position(parent, eventId), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
          dragged |= dx | dy;
          origin_ = p;
          event_({
            type: "drag",
            x: p[0] + offset[0],
            y: p[1] + offset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          w.on(move + "." + drag, null).on(end + "." + drag, null);
          dragRestore(dragged && d3.event.target === eventTarget);
          event_({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  var π = Math.PI, τ = 2 * π, halfπ = π / 2, ε = 1e-6, ε2 = ε * ε, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on(mousemove, mousewheelreset).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(event_);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = dx / 2, cy = dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(event_);
            };
          }).each("end.zoom", function() {
            zoomended(event_);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(event_);
          zoomed(event_);
          zoomended(event_);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(event) {
      event({
        type: "zoomstart"
      });
    }
    function zoomed(event) {
      rescale();
      event({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(event) {
      event({
        type: "zoomend"
      });
    }
    function mousedowned() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, dragged = 0, w = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), l = location(d3.mouse(target)), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(target);
      zoomstarted(event_);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(target), l);
        zoomed(event_);
      }
      function ended() {
        w.on(mousemove, d3_window === target ? mousewheelreset : null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === eventTarget);
        zoomended(event_);
      }
    }
    function touchstarted() {
      var target = this, event_ = event.of(target, arguments), locations0 = {}, distance0 = 0, scale0, eventId = d3.event.changedTouches[0].identifier, touchmove = "touchmove.zoom-" + eventId, touchend = "touchend.zoom-" + eventId, w = d3.select(d3_window).on(touchmove, moved).on(touchend, ended), t = d3.select(target).on(mousedown, null).on(touchstart, started), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(target);
      started();
      zoomstarted(event_);
      function relocate() {
        var touches = d3.touches(target);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0], l = locations0[p.identifier];
            scaleTo(view.k * 2);
            translateTo(p, l);
            d3_eventPreventDefault();
            zoomed(event_);
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(target), p0, l0, p1, l1;
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(event_);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        w.on(touchmove, null).on(touchend, null);
        t.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(event_);
      }
    }
    function mousewheeled() {
      var event_ = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      zoomstarted(event_);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(event_);
      }, 50);
      d3_eventPreventDefault();
      var point = center || d3.mouse(this);
      if (!translate0) translate0 = location(point);
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(point, translate0);
      zoomed(event_);
    }
    function mousewheelreset() {
      translate0 = null;
    }
    function dblclicked() {
      var event_ = event.of(this, arguments), p = d3.mouse(this), l = location(p), k = Math.log(view.k) / Math.LN2;
      zoomstarted(event_);
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      zoomed(event_);
      zoomended(event_);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  function d3_Color() {}
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color();
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  function d3_rgbNumber(value) {
    return d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, ~~(r / k)), Math.min(255, ~~(g / k)), Math.min(255, ~~(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(~~(k * this.r), ~~(k * this.g), ~~(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  function d3_identity(d) {
    return d;
  }
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && request.responseText || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.substring(j, I - k);
        }
        return text.substring(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ], d3_format_currencySymbol = "$";
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
      zfill = fill = "0";
      align = "=";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;

     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;

     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;

     case "b":
     case "o":
     case "x":
     case "X":
      if (symbol === "#") symbol = "0" + type.toLowerCase();

     case "c":
     case "d":
      integer = true;
      precision = 0;
      break;

     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (symbol === "#") symbol = ""; else if (symbol === "$") symbol = d3_format_currencySymbol;
    if (type == "r" && !precision) type = "g";
    if (precision != null) {
      if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
    }
    type = d3_format_types.get(type) || d3_format_typeDefault;
    var zcomma = zfill && comma;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      var i = value.lastIndexOf("."), before = i < 0 ? value : value.substring(0, i), after = i < 0 ? "" : d3_format_decimalPoint + value.substring(i + 1);
      if (!zfill && comma) before = d3_format_group(before);
      var length = symbol.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
      if (zcomma) before = d3_format_group(padding + before);
      negative += symbol;
      value = before + after;
      return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_format_group = d3_identity;
  if (d3_format_grouping) {
    var d3_format_groupingLength = d3_format_grouping.length;
    d3_format_group = function(value) {
      var i = value.length, t = [], j = 0, g = d3_format_grouping[0];
      while (i > 0 && g > 0) {
        t.push(value.substring(i -= g, i + g));
        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
      }
      return t.reverse().join(d3_format_thousandsSeparator);
    };
  }
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
          listener.polygonStart();
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          listener.polygonEnd();
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          listener.lineStart();
          while (++i < n) listener.point((point = segment[i])[0], point[1]);
          listener.lineEnd();
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, antimeridian = abs(dλ) > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * Math.sin(dλ), cosφ0 * cosφ + k * Math.cos(dλ)));
        polarAngle += antimeridian ? dλ + (dλ >= 0 ? τ : -τ) : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && isLeft(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && isLeft(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function isLeft(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      var ρ = abs(abs(φ) - halfπ) < ε ? 0 : F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ -_[1], _[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return projection.rotate([ 0, 0 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), n = data.length, vertices, plen = n - 1, points = [], stack = [], d, i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
      if (fx === d3_geom_pointX && y === d3_geom_pointY) vertices = data; else for (i = 0, 
      vertices = []; i < n; ++i) {
        vertices.push([ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ]);
      }
      for (i = 1; i < n; ++i) {
        if (vertices[i][1] < vertices[h][1] || vertices[i][1] == vertices[h][1] && vertices[i][0] < vertices[h][0]) h = i;
      }
      for (i = 0; i < n; ++i) {
        if (i === h) continue;
        y1 = vertices[i][1] - vertices[h][1];
        x1 = vertices[i][0] - vertices[h][0];
        points.push({
          angle: Math.atan2(y1, x1),
          index: i
        });
      }
      points.sort(function(a, b) {
        return a.angle - b.angle;
      });
      a = points[0].angle;
      v = points[0].index;
      u = 0;
      for (i = 1; i < plen; ++i) {
        j = points[i].index;
        if (a == points[i].angle) {
          x1 = vertices[v][0] - vertices[h][0];
          y1 = vertices[v][1] - vertices[h][1];
          x2 = vertices[j][0] - vertices[h][0];
          y2 = vertices[j][1] - vertices[h][1];
          if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
            points[i].index = -1;
            continue;
          } else {
            points[u].index = -1;
          }
        }
        a = points[i].angle;
        u = i;
        v = j;
      }
      stack.push(h);
      for (i = 0, j = 0; i < 2; ++j) {
        if (points[j].index > -1) {
          stack.push(points[j].index);
          i++;
        }
      }
      sp = stack.length;
      for (;j < plen; ++j) {
        if (points[j].index < 0) continue;
        while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
          --sp;
        }
        stack[sp++] = points[j].index;
      }
      var poly = [];
      for (i = sp - 1; i >= 0; --i) poly.push(data[stack[i]]);
      return poly;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = x >= sx, bottom = y >= sy, i = (bottom << 1) + right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = sx; else x2 = sx;
        if (bottom) y1 = sy; else y2 = sy;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    b -= a = +a;
    return function(t) {
      return a + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    a = a + "", b = b + "";
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3_interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? (o = q[0].x, function(t) {
        return o(t) + "";
      }) : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_Color ? d3_interpolateRgb : t === "object" ? Array.isArray(b) ? d3_interpolateArray : d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = +x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, m = candidates.length, x;
        while (++j < m) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function recurse(node, depth, nodes) {
      var childs = children.call(hierarchy, node, depth);
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = new Array(n), v = 0, j = depth + 1, d;
        while (++i < n) {
          d = c[i] = recurse(childs[i], j, nodes);
          d.parent = node;
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else {
        delete node.children;
        if (value) {
          node.value = +value.call(hierarchy, node, depth) || 0;
        }
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, node, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
        node.x *= size[0];
        node.y = node.depth * size[1];
        delete node._tree;
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    return d3.format(format ? format.replace(d3_format_re, function(a, b, c, d, e, f, g, h, i, j) {
      return [ b, c, d, e, f, g, h, i || "." + d3_scale_linearFormatPrecision(j, range), j ].join("");
    }) : ",." + d3_scale_linearPrecision(range[2]) + "f");
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(Math.abs(range[0]), Math.abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || ranger.t === "range" && index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -halfπ, d3_svg_arcMax = τ - ε;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  function d3_transition(groups, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (this.__transition__.count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        var transition = node.__transition__[id];
        (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, delay = transition.delay, duration = transition.duration, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          transition.event && transition.event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, d, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            lineEnter.attr("y2", innerTickSize);
            textEnter.attr("y", Math.max(innerTickSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", innerTickSize);
            textUpdate.attr("x", 0).attr("y", Math.max(innerTickSize, 0) + tickPadding);
            text.attr("dy", ".71em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
            break;
          }

         case "top":
          {
            tickTransform = d3_svg_axisX;
            lineEnter.attr("y2", -innerTickSize);
            textEnter.attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
            text.attr("dy", "0em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
            break;
          }

         case "left":
          {
            tickTransform = d3_svg_axisY;
            lineEnter.attr("x2", -innerTickSize);
            textEnter.attr("x", -(Math.max(innerTickSize, 0) + tickPadding));
            lineUpdate.attr("x2", -innerTickSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(innerTickSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "end");
            pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
            break;
          }

         case "right":
          {
            tickTransform = d3_svg_axisY;
            lineEnter.attr("x2", innerTickSize);
            textEnter.attr("x", Math.max(innerTickSize, 0) + tickPadding);
            lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(innerTickSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "start");
            pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
            break;
          }
        }
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1);
        }
        tickEnter.call(tickTransform, scale0);
        tickUpdate.call(tickTransform, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time = d3.time = {}, d3_date = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  d3_time.format = d3_time_format;
  function d3_time_format(template) {
    var n = template.length;
    function format(date) {
      var string = [], i = -1, j = 0, c, p, f;
      while (++i < n) {
        if (template.charCodeAt(i) === 37) {
          string.push(template.substring(j, i));
          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
          if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0,
        Z: null
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
      if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
        date.setFullYear(d.y, 0, 1);
        date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
      } else date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H + Math.floor(d.Z / 100), d.M + d.Z % 100, d.S, d.L);
      return localZ ? date._ : date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  }
  function d3_time_parse(date, template, string, j) {
    var c, p, t, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c === 37) {
        t = template.charAt(i++);
        p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayLookup = d3_time_formatLookup(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_dayAbbrevLookup = d3_time_formatLookup(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations), d3_time_percentRe = /^%/;
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  };
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3_time_format(d3_time_formatDateTime),
    d: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    e: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    H: function(d, p) {
      return d3_time_formatPad(d.getHours(), p, 2);
    },
    I: function(d, p) {
      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
    },
    j: function(d, p) {
      return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
    },
    L: function(d, p) {
      return d3_time_formatPad(d.getMilliseconds(), p, 3);
    },
    m: function(d, p) {
      return d3_time_formatPad(d.getMonth() + 1, p, 2);
    },
    M: function(d, p) {
      return d3_time_formatPad(d.getMinutes(), p, 2);
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d, p) {
      return d3_time_formatPad(d.getSeconds(), p, 2);
    },
    U: function(d, p) {
      return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d, p) {
      return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
    },
    x: d3_time_format(d3_time_formatDate),
    X: d3_time_format(d3_time_formatTime),
    y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 100, p, 2);
    },
    Y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
    },
    Z: d3_time_zone,
    "%": function() {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    j: d3_time_parseDayOfYear,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    U: d3_time_parseWeekNumberSunday,
    w: d3_time_parseWeekdayNumber,
    W: d3_time_parseWeekNumberMonday,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear,
    Z: d3_time_parseZone,
    "%": d3_time_parseLiteralPercent
  };
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.substring(i, i + 5)) ? (date.Z = +string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  var d3_time_numberRe = /^\s*\d+/;
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(abs(z) / 60), zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.substring(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  d3_time_format.utc = d3_time_formatUtc;
  function d3_time_formatUtc(template) {
    var local = d3_time_format(template);
    function format(date) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date();
        utc._ = date;
        return local(utc);
      } finally {
        d3_date = Date;
      }
    }
    format.parse = function(string) {
      try {
        d3_date = d3_date_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_date = Date;
      }
    };
    format.toString = local.toString;
    return format;
  }
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3_time_format("%Y"), d3_true ], [ d3_time_format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3_time_format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3_time_format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3_time_format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3_time_format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3_time_format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3_time_format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(+start, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3_time_formatUtc("%Y"), d3_true ], [ d3_time_formatUtc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3_time_formatUtc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3_time_formatUtc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3_time_formatUtc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3_time_formatUtc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3_time_formatUtc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3_time_formatUtc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  d3_time_scaleUTCMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  return d3;
}();
/*
 * ************************************************************************
 *
 *  ADOBE CONFIDENTIAL
 *  ___________________
 *
 *   (c) Copyright 2015 Adobe Systems, Inc.
 *   All Rights Reserved.
 *
 *  NOTICE:  All information contained herein is, and remains
 *  the property of Adobe Systems Incorporated and its suppliers,
 *  if any.  The intellectual and technical concepts contained
 *  herein are proprietary to Adobe Systems Incorporated and its
 *  suppliers and may be covered by U.S. and Foreign Patents,
 *  patents in process, and are protected by trade secret or copyright law.
 *  Dissemination of this information or reproduction of this material
 *  is strictly forbidden unless prior written permission is obtained
 *  from Adobe Systems Incorporated.
 * ************************************************************************
 */

/*
 * dv - v3.2.0 - 2015-07-21
 * Copyright (c) 2015 Adobe Systems, Inc. All Rights Reserved.
 */
(function(){
// This class is used to shim in extra events into d3.  These event-types don't ordinarily exist in JS, so I
// shimmed them into D3.
var d3_selectionPrototype = d3.selection.prototype,
	d3_selection_on = d3_selectionPrototype.on;

// The shimmed events we are using in DV.
var shims = {
	// Tap event is generated if a touch is started and ends in 200ms. It requires paying attention to
	// touchstart, touchend, and touchmove events.
	"tap": [["touchstart", "touchend", "touchmove"], tap]
};

var pointer = null,
	touchStarted = false,
	curX = 0,
	curY = 0,
	cachedX = 0,
	cachedY = 0;

/**
 * Overriding d3's selection prototype to watch for special events to shim in new event types.
 */
d3_selectionPrototype.on = function(type, listener, capture) {
	var bits = type.split("."),
		eventType = bits.shift(),
		shim = shims[eventType];
	// If we have a shim candidate, handle that case, otherwise passthrough to normal D3 event handling.
	if (shim) {
		var types = shim[0],
			self = this;
		listener = shim[1].call(null, listener);

		// For each regular event that composes our custom event, add event handlers.
		types.forEach(function(d, i) {
			var eType = [d, bits].join(".");
			d3_selection_on.call(self, eType, listener, capture);
		});
		return d3_selection_on;
	} else {
		return d3_selection_on.apply(this, arguments);
	}
};

/**
 * Detects if a tap event occurred.  If it does, dispatch the event to all bound callbacks.
 */
function tap(callback) {
	return function() {
		if (d3.event.type === "touchstart") {
			pointer = getPointerEvent(d3.event);
			cachedX = curX = pointer.pageX;
			cachedY = curY = pointer.pageY;
			touchStarted = true;

			var ev = d3.event;

			// Check back in 200ms to see if a tap occurred.
			setTimeout(function() {
				if ((cachedX === curX) && !touchStarted && (cachedY === curY)) {
					d3.event = ev;
					callback.apply(this, arguments);
				}
			}, 200);
		}
		if (d3.event.type === "touchend" && touchStarted) {
			touchStarted = false;
		}
		if (d3.event.type === "touchmove" && touchStarted) {
			pointer = getPointerEvent(d3.event);
			curX = pointer.pageX;
			curY = pointer.pageY;
		}
	};
}

function getPointerEvent(event) {
	return event.touches ? event.touches[0] : event;
}
dv = function() {};
dv.version = "3.2.0";
dv.ANIMATION = true;

/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
var initializing = false, fnTest = /xyz/.test(function() { xyz;	}) ? /\b_super\b/ : /.*/;
dv.extend = function(subClass) {
	var _super = this.prototype;
	initializing = true;
	var prototype = new this();
	// execute outer function to obtain prototype for class
	subClass = subClass();
	subClass.init = subClass;

	initializing = false;
	for (var prop in subClass) {
		prototype[prop] = typeof subClass[prop] == "function" &&
			typeof _super[prop] == "function" && fnTest.test(subClass[prop]) ?
			(function(prop, fn) {
				return function() {
					var tmp = this._super;
					this._super = _super[prop];
					var ret = fn.apply(this, arguments);
					this._super = tmp;
					return ret;
				};
			})(prop, subClass[prop]) :
			subClass[prop];
	}

	function Class() {
		if(!initializing){
			initializing = true;
			var clazz = new arguments.callee();
			initializing = false;
			clazz.init.apply(clazz, arguments);
			return clazz;
		}

	}

	Class.prototype = prototype;
	Class.mixin = function(name, value) {
		if (dv.util.isObject(name)) {
			dv.util.each(name, function(mixin, name) {
				prototype[name] = value;
			});
		} else {
			prototype[name] = value;
		}
	};
	Class.extend = arguments.callee;

	return Class;
};

dv.DEFAULT_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
dv.DEFAULT_CATEGORICAL_AES = [ 'color', 'fill', 'stroke', 'shape', 'size', 'linetype' ];

// Returns the absolute coordinates for a pixel value within a plot.
dv.absoluteCoordinates = function(chart, posWithinPlot, panel) {
	// TODO: The coordinate system needs to handle this...
	// We centered the SVG group in the middle of the plot with a transform on the plot group since we're in polar, we need to undo that here.
	if (chart.coord() instanceof dv.coord.polar) {
		var xScale = chart.coord().flip() ? panel.yOuterScale() : panel.xOuterScale(),
			yScale = chart.coord().flip() ? panel.xOuterScale() : panel.yOuterScale(),
			xRange = dv.util.scaleRangeNoReverse(xScale),
			yRange = dv.util.scaleRangeNoReverse(yScale);
		posWithinPlot[0] += (xRange[0] + xRange[1]) / 2;
		posWithinPlot[1] += (yRange[0] + yRange[1]) / 2;
	}

	return posWithinPlot;
};

/**
 * Shows a tooltip at a given position with HTML content.
 * @param targetRect - The bounding rect of the SVG element we are pointing the tooltip to. Has properties: x, y, width, height.
 * @param boundaryRect - The bounding rect which the tooltip can not be displayed outside. If the tooltip gets too close to a boundary, it will try to flip to a different orientation.  Has properties: x, y, width, height.
 * @param content - The HTML content displayed in the tooltip
 * @param padding - The amount of padding we want to add to push the tooltip out further
 * @param parent - The parent the tooltip will be attached to
 */
dv.showTooltip = function(targetRect, boundaryRect, content, orientation, padding, parent) {
	var tipDiv = parent.selectAll(".dv-tooltip").data([targetRect]);

	targetRect.cx = targetRect.cx || targetRect.x + targetRect.width / 2;
	targetRect.cy = targetRect.cy || targetRect.y + targetRect.height / 2;
	targetRect.dx = targetRect.dx || targetRect.x + targetRect.width;
	targetRect.dy = targetRect.dy || targetRect.y + targetRect.height;
	boundaryRect.dx = boundaryRect.dy || boundaryRect.x + boundaryRect.width;
	boundaryRect.dy = boundaryRect.dy || boundaryRect.y + boundaryRect.height;

	var tipDivEnter = tipDiv.enter()
		.append("div")
			.classed("dv-tooltip", true)
			.style("top", 0)
			.style("left", 0);
	tipDivEnter.append('div').classed("content", true);
	tipDivEnter.append('b').classed("notch", true);

	tipDiv.select(".content").html(content);

	var tipDivNotch = tipDiv.select(".notch");

	var tipNode = tipDiv.node(),
		width = tipNode.offsetWidth,
		height = tipNode.offsetHeight,
		top = 0,
		left = 0,
		clamp = function(val, min, max) { return Math.min(Math.max(min, val), max); };

	switch (orientation) {
		case "left" :
			left = targetRect.x - width - padding;
			top = targetRect.cy - height / 2;
			if (left < boundaryRect.x) { // flip to right
				left = targetRect.dx + padding;
				orientation = "right";
			}
			if (top < boundaryRect.y) top = boundaryRect.y; // snap to the top
			if (top + height > boundaryRect.dy) top = boundaryRect.dy - height; // snap to the bottom
			tipDivNotch.style("top", clamp(targetRect.cy - top - 5, 3, height - 13) + "px");
			break;
		case "right" :
			left = targetRect.x + targetRect.width + padding;
			top = targetRect.cy - height / 2;
			if (left + width > boundaryRect.dx) { // flip to left
				left = targetRect.x - width - padding;
				orientation = "left";
			}
			if (top < boundaryRect.y) top = boundaryRect.y; // snap to the top
			if (top + height > boundaryRect.dy) top = boundaryRect.dy - height; // snap to the bottom
			tipDivNotch.style("top", clamp(targetRect.cy - top - 5, 3, height - 13) + "px");
			break;
		case "top" :
			left = targetRect.cx - width / 2;
			top = targetRect.y - height - padding;
			if (top < boundaryRect.y) { // flip to bottom
				top = targetRect.dy + padding;
				orientation = "bottom";
			}
			if (left < boundaryRect.x) left = boundaryRect.x; // snap to the left
			if (left + width > boundaryRect.dx) left = boundaryRect.dx - width; // snap to the right
			tipDivNotch.style("left", clamp(targetRect.cx - left - 5, 3, width - 13) + "px");
			break;
		case "bottom" :
			left = targetRect.cx - width / 2;
			top = targetRect.dy + padding;
			if (top + height > boundaryRect.dy) { // flip to top
				top = targetRect.y - height - padding;
				orientation = "top";
			}
			if (left < boundaryRect.x) left = boundaryRect.x; // snap to the left
			if (left + width > boundaryRect.dx) left = boundaryRect.dx - width; // snap to the right
			tipDivNotch.style("left", clamp(targetRect.cx - left - 5, 3, width - 13) + "px");
			break;
		default :
			orientation = null;
			break;
	}

	top = Math.round(top);
	left = Math.round(left);

	tipDiv
		.classed("top right left bottom hide", false)
		.classed(orientation, true);

	tipDivEnter.style("top", top + "px").style("left", left + "px");

	tipDiv
		.style("top", top + "px")
		.style("left", left + "px");
};

dv.removeTooltip = function(parent) {
	parent.selectAll(".dv-tooltip")
		.classed("hide", true);
};

dv.cancelEvent = function(e) {
	e.stopPropagation();
	e.preventDefault();
};

// Returns the dimensions of the current window.
dv.windowDimensions = function() {
	var size = {
		width: 640,
		height: 480
	};

	if (document.body && document.body.offsetWidth) {
		size.width = document.body.offsetWidth;
		size.height = document.body.offsetHeight;
	}
	if (document.compatMode=='CSS1Compat' &&
		document.documentElement &&
		document.documentElement.offsetWidth ) {
		size.width = document.documentElement.offsetWidth;
		size.height = document.documentElement.offsetHeight;
	}
	if (window.innerWidth && window.innerHeight) {
		size.width = window.innerWidth;
		size.height = window.innerHeight;
	}
	return size;
};

dv.addWindowResizeHandler = function(func) {
	window.addEventListener("resize", func);
};

dv.removeWindowResizeHandler = function(func) {
	window.removeEventListener("resize", func);
};

dv.scale = dv.extend(function (){

	function scale(d3Scale) {
		this._d3Scale = d3Scale;
		this._reverse = false;
		this._parse = dv.util.identity;

		this._includeInDomain = function() { return true; };
	}

	scale._mapToD3Scale = function(val) {
		return this._d3Scale(val);
	};

	scale.trainingProperties = function(val) {
		if (!arguments.length) {
			if (this._trainingProperties) return this._trainingProperties;
			if (this._property) return [this._property];
			return undefined;
		}
		if (!dv.util.isValidValue(val, ["isUndefined", "isArray"])) dv.log.error({msg: "The supplied properties is not an array", data: {range: val}});
		this._trainingProperties = val;
		return this;
	};

	scale.trainDomain = function(data, options) {
		var domain = this.calculateDomain(data, options);
		this.domain(domain);
		return domain;
	};

	scale.parse = function(val) {
		if (!arguments.length) return this._parse;
		this._parse = val;
		return this;
	};

	scale.applyRangePadding = function() { };

	// Allows the scale to look at its domain to see if it is valid.  If it isn't, a default domain can be set instead.
	scale.validateDomain = function() { };

	// Extracts the scale's property from the object.
	scale.mapToProp = function(obj) {
		var val = obj[this.property()],
			self = this;
		// We'll run each value through the d3 scale object that this wraps.
		// If it's an array, we'll apply the d3 scale to each entry.
		if (dv.util.isArray(val)) {
			return dv.util.map(val, function(d) { return self._mapToD3Scale.call(self, d); });
		}
		return this._mapToD3Scale.call(this, val);
	};

	//  Extracts the scale's property value from the object,
	//	which property's values are then mapped to a percent of the scale.
	scale.mapPropToPercent = function(obj) {
		return this.mapValueToPercent(this.mapToProp(obj));
	};

	//	Take each value along the scale and compute
	//	the percent distance along the fixed length of the scale.
	scale.mapValueToPercent = function(val) {
		var range = dv.util.scaleRange(this),
			denom = range[1] - range[0];
		if (dv.util.isArray(val)) {
			return dv.util.map(val, function(d) { return denom ? (d - range[0]) / denom : 0; });
		}
		return denom ? (val - range[0]) / denom : 0;
	};

	scale.mapValue = function(val) {
		if (dv.util.isArray(val)) {
			var self = this;
			return dv.util.map(val, function(d) { return self._mapToD3Scale.call(self, d); });
		}
		return this._mapToD3Scale.call(this, val);
	};



	scale.invertValue = function(val) {
		return this._d3Scale.invert(val);
	};

	scale.rangeBand = function(val) {
		return 0;
	};

	scale.reverse = function(val) {
		if (!arguments.length) return this._reverse;
		this._reverse = val;
		return this;
	};

	scale.property = function(val) {
		if (!arguments.length) return this._property;
		this._property = val;
		return this;
	};

	scale.mapping = function(val) {
		if (!arguments.length) return this._mapping;
		this._mapping = val;
		return this;
	};

	/**
	 * An unreversed domain.  For continuous scales, this represents the limits of the domain (e.g. [0, 50]).
	 * For ordinal scales, this represents a unique set of all values (e.g. ["USA", "Mexico", "Canada", "Brazil"]).
	 */
	scale.domain = function(val) {
		if (!arguments.length) return this._d3Scale.domain();
		if (!this._d3Scale) return this;
		this._d3Scale.domain(val);
		return this;
	};

	/**
	 * returns true if the argument d contains the same values as this scale's domain (no more, no less)
	**/
	scale.hasSameDomain = function(d) {
		var retVal = true,
			domain = this.domain();
		if (domain.length != d.length) {
			retVal = false;
		} else {
			for (var i = 0; i < d.length; i++) {
				if (d[i] != domain[i]) {
					retVal = false;
					break;
				}
			}
		}
		return retVal;
	};

	scale.range = function(val) {
		if (!arguments.length) return this._d3Scale.range();
		if (!this._d3Scale) return this;
		if (!dv.util.isValidValue(val, ["isArray"])) dv.log.error({msg: "The supplied range is not an array", data: {range: val}});
		this._d3Scale.range(val);
		return this;
	};

	scale.expand = function(val) { // TODO: Implement me
		if (!arguments.length) return this._expand;
		this._expand = val;
		return this;
	};

	scale.limits = function(val) { // TODO: Implement me
		if (!arguments.length) return this._limits;
		this._limits = val;
		return this;
	};

	scale.breaks = function(val) { // TODO: Implement me
		if (!arguments.length) return this._breaks;
		this._breaks = val;
		return this;
	};

	scale.orientation = function(val) {
		if (!arguments.length) return this._orientation;
		this._orientation = val;
		return this;
	};

	/**
	 * A function specified by the user which will be called when calculating the scale's domain.  If the function returns true,
	 * the data point will be included in the training of the domain.  Otherwise, it will be left out while the domain is calculated.
	 */
	scale.includeInDomain = function(val) {
		if (!arguments.length) return this._includeInDomain;
		this._includeInDomain = val;
		return this;
	};

	scale.scaleIndex = function(val) {
		if (!arguments.length) return this._scaleIndex;
		this._scaleIndex = val;
		return this;
	};

	scale._copy = function() {
		dv.log.error({msg: "A copy function was not specified for the scale subclass."});
	};
	scale.copy = scale._copy;

	scale.isDefault = function(val) {
		if (!arguments.length) return this._isDefault;
		this._isDefault = val;
		return this;
	};

	return scale;
});
/**
 * dv.scale.constant is simply a placeholder for constant values that shouldn't be mapped.
 * It is used internally when an aesthetic is supplied with a primitive value instead of
 * an aesthetic.
 */
dv.scale.constant = dv.scale.extend(function(){
	function constant() {
		this._super(null);
	}

	constant.trainDomain = function(data) {
		return;
	};

	constant.map = function(val) {
		return this._value; // There is no translation required.
	};

	constant.mapToProp = function(val) {
		return this._value; // There is no translation required.
	};

	constant.value = function(val) {
		if (!arguments.length) return this._value;
		this._value = val;
		return this;
	};

	constant._copy = function(val) {
		var	trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		return dv.scale.constant()
			.isDefault(this.isDefault())
			.value(this.value())
			.property(this.property())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
	};
	constant.copy = constant._copy;
	return constant;
});
dv.scale.continuous = dv.scale.extend(function() {
	function continuous(scale) {
		this._super(scale ? scale : d3.scale.linear());

		// to is just an alias function for range since range won't be apparent to those who aren't familiar
		// with D3.
		this.to = this.range;
		this._parse = function(d) {
			if (d == null) {
				return undefined;
			}
			return parseFloat(d);
		};
	}

	/**
	 * Returns an unreversed continuous domain.  Reversing should automatically be done when the returned value
	 * is passed to the scale's domain setter if it is required.
	 */
	continuous.calculateDomain = function(data, options) {
		var domain = [],
			self = this,
			_min,
			_max;

		if (!this.trainingProperties()) this.trainingProperties([ this.property() ]);
		var trainingProps = this.trainingProperties();
		if (!options) options = {};
		if (!data) data = [];

		for (var p = 0; p < trainingProps.length; p++) {
			var prop = trainingProps[p];
			for(var j = 0; j < data.length; j++) {
				if (!options.filter || !options.filter.call(this, data[j].key)) {
					var series = data[j].values;
					for (var i = 0; i < series.length; i++) {
						var dataObj = series[i];
						if (!this._includeInDomain(dataObj, i)) continue;

						// If the scale has an index different than 0, let's append to the data object the index of the scale.
						if (this.scaleIndex() !== 0) dataObj[this.property() + "-index"] = this.scaleIndex();
						var val = (options.stack) ? dataObj.y0 : dataObj[prop];
						if (!dv.util.isArray(val)) {
							val = this._parse.call(this, val);
						}

						var minVal = dv.util.isArray(val) ? d3.min(val) : val;
						_min = ((dv.util.isUndefined(_min) || isNaN(_min)) || minVal < _min) ? minVal : _min;

						if(options.stack) {
							// With polygons, the stacking occurs along the maximum value in that dimension
							// (i.e., on the bounding box).
							var addVal = dataObj[prop];
							val += dv.util.isArray(addVal) ? d3.max(addVal) : self._parse.call(this, addVal);
						}
						var maxVal = dv.util.isArray(val) ? d3.max(val) : val;
						_max = ((dv.util.isUndefined(_max) || isNaN(_max)) || maxVal > _max) ? maxVal : _max;
					}
				}
			}
		}

		// This probably means there is no data property matching the mapping. This is ok in cases where a geom
		// is inheriting mappings from the chart, but has data that doesn't contain the mapped properties.
		if (isNaN(_min) && isNaN(_max)) {
			domain = [];
			this._naturalDomain = [];
		}
		else {
			domain = [_min, _max];
			this._naturalDomain = [_min, _max];
		}

		if (options.fill) {
			domain = [0, 100]; // 0 to 100 percent
		}
		if (!dv.util.isUndefined(this._upperLimit) && !dv.util.isFunction(this._upperLimit) &&
			!dv.util.isUndefined(this._lowerLimit) && !dv.util.isFunction(this._lowerLimit)) {
			domain = this.limits(); // Explicitly set limits always trump implicit limits.
		}
		else {
			this._reconcileLimits(domain);
		}

		return domain;
	};

	continuous.unionDomain = function(scale, isReversed) {
		if (!scale || !(scale instanceof dv.scale.continuous)) {
			dv.log.error({msg: "The supplied scale is not continuous.", data: { scale: scale, isReversed: isReversed }});
		}

		var domain = scale.domain(),
			naturalDomain = scale.naturalDomain(),
			unionedDomain = this.domain() ? d3.extent(this.domain().concat(domain)) : d3.extent(domain),
			unionedNatDomain = this._naturalDomain ? d3.extent(this._naturalDomain.concat(naturalDomain)) : d3.extent(naturalDomain);

		if (isNaN(unionedDomain[0]) && isNaN(unionedDomain[1])) {
			unionedDomain = [];
		}
		if (isNaN(unionedNatDomain[0] && isNaN(unionedNatDomain[1]))) {
			unionedNatDomain = [];
		}

		// TODO: We eventually need to get smarter about situations where we are unioning a reversed and
		// unreversed domain.  This will ideally create a situation where we have multiple axes.  For now
		// we'll say if one of them is reversed, the current unioned scale will be reversed as well.
		this.reverse(isReversed || this._reverse);
		this.domain(unionedDomain);
		this._naturalDomain = unionedNatDomain;
		return this;
	};

	// Allows the scale to look at its domain to see if it is valid.  If it isn't, a default domain can be set instead.
	continuous.validateDomain = function() {
		var domain = this.domain();
		if (!domain || !domain.length) {
			this.domain([0, 1]);
		}
	};

	continuous.unionRange = function(range) {
		if (!dv.util.isValidValue(range, ["isArray"])) dv.log.error({msg: "The supplied range is not an array", data: {range: range}});

		this.range(this.range() ? d3.extent(this.range().concat(range)) : range);
		return this;
	};

	continuous.applyRangePadding = function() {
		var domain = this.domain(),
			range = this.range();

		if (this._lowerRangePadding) {
			var lExtent = range[0] - range[1],
				lrp = Math.min(Math.abs(lExtent) - 1, this._lowerRangePadding);
			domain[0] = this.invertValue(lExtent / (Math.abs(lExtent) - lrp) * lrp + range[0]);
		}
		if (this._upperRangePadding) {
			var uExtent = range[1] - range[0],
				urp = Math.min(Math.abs(uExtent) - 1, this._upperRangePadding);
			domain[1] = this.invertValue(uExtent / (Math.abs(uExtent) - urp) * urp + range[1]);
		}

		this.domain(domain);
		return this;
	};

	/**
	 *
	 */
	continuous.upperLimit = function(val) {
		if (!arguments.length) return this._upperLimit;
		if (dv.util.isValidValue(val, ["isUndefined", "isFinite", "isDate", "isFunction"])) this._upperLimit = val;
		else dv.log.error({msg: "Invalid value, cannot set upperLimit with: " + val});
		return this;
	};

	continuous.lowerLimit = function(val) {
		if (!arguments.length) return this._lowerLimit;
		if (dv.util.isValidValue(val, ["isUndefined", "isFinite", "isDate", "isFunction"])) this._lowerLimit = val;
		else dv.log.error({msg: "Invalid value, cannot set lowerLimit with: " + val});
		return this;
	};

	continuous.limits = function(val) {
		if (!arguments.length) return [this._lowerLimit, this._upperLimit];
		if (!val || val.length != 2) dv.log.error({msg: "Incorrect number of arguments, the limits function must supply an array containing both a lower and upper limit"});
		this.lowerLimit(val[0]);
		this.upperLimit(val[1]);
		return this;
	};

	/**
	 * Returns the domain of the data without taking limits into account.  This is essentially the natural min/max
	 * values of the entire dataset.  This is only calculated when calculateDomain is executed on a scale. It cannot
	 * be set externally.
	 */
	continuous.naturalDomain = function() {
		return this._naturalDomain;
	};

	/**
	 * Adds range padding to the end of the scale by adjusting the domain to accommodate the padding.
	 */
	continuous.upperRangePadding = function(val) {
		if (!arguments.length) return this._upperRangePadding;
		if (dv.util.isValidValue(val, ["isUndefined", "isFinite", "isDate", "isFunction"])) this._upperRangePadding = val;
		else dv.log.error({msg: "Invalid value, cannot set upperRangePadding with: " + val});
		return this;
	};

	/**
	 * Adds range padding to the beginning of the scale by adjusting the domain to accommodate the padding.
	 */
	continuous.lowerRangePadding = function(val) {
		if (!arguments.length) return this._lowerRangePadding;
		if (dv.util.isValidValue(val, ["isUndefined", "isFinite", "isDate", "isFunction"])) this._lowerRangePadding = val;
		else dv.log.error({msg: "Invalid value, cannot set lowerRangePadding with: " + val});
		return this;
	};

	continuous.rangePadding = function(val) {
		if (!arguments.length) return [this._lowerRangePadding, this._upperRangePadding];
		if (!val || val.length != 2) dv.log.error({msg: "Incorrect number of arguments, the limits function must supply an array containing both a lower and upper limit"});
		this.lowerRangePadding(val[0]);
		this.upperRangePadding(val[1]);
		return this;
	};

	/**
	 * The soft lower limit will tell the scale that it's lower limit of the domain should be zero, unless
	 * the lower limit of the domain is less than zero.  In that case, nothing will be changed.
	 */
	continuous.softLowerLimit = function(val) {
		if (!arguments.length) return this._softLowerLimit;
		this._softLowerLimit = val;
		return this;
	};

	continuous._reconcileLimits = function(domain) {
		if (!domain.length) return;

		if (!dv.util.isUndefined(this._softLowerLimit)) {
			domain[0] = Math.min(domain[0], this._softLowerLimit);
			domain[1] = Math.max(domain[1], this._softLowerLimit);
		}

		if (!dv.util.isUndefined(this._lowerLimit))
			domain[0] = dv.util.isFunction(this._lowerLimit) ? this._lowerLimit(domain[0], domain[1]) : this._lowerLimit;

		if (!dv.util.isUndefined(this._upperLimit))
			domain[1] = dv.util.isFunction(this._upperLimit) ? this._upperLimit(domain[0], domain[1]) : this._upperLimit;
	};

	continuous.labels = function(val) { // TODO: Implement me
		if (!arguments.length) return this._labels;
		this._labels = val;
		return this;
	};

	continuous._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.continuous()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.reverse(this.reverse())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};


	continuous.invert = function(obj) {
		return this._d3Scale.invert(obj[this.mapping()]);
	};

	continuous.invertFromProp = function(obj) {
		return this._d3Scale.invert(obj[this.property()]);
	};

	continuous.copy = continuous._copy;
	return continuous;

});
dv.scale.linear = dv.scale.continuous.extend(function() {
	function linear() {
		this._super(d3.scale.linear());
	}

	linear._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.linear()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};
	linear.copy = linear._copy;
	return linear;
});
dv.scale.gradient = dv.scale.continuous.extend(function(){
	function gradient() {
		this._super(d3.scale.linear());
		this._innerScale = d3.scale.linear().range([0, 1]);

		// this._d3Scale is the outerScale.  It can accept hex and rgb strings.
		this.colors = this.range;

		this._controlPoints = ["0%", "50%", "100%"];
		this.colors(["#FA5A50", "#E1E1E1", "#5FAF69"]);
	}

	gradient._adjustOuterDomain = function() {
		var self = this;
		this._d3Scale.domain(dv.util.map(this._controlPoints, function(d, i) { return dv.util.isPercentString(d) ? self._innerScale.invert(parseInt(d, 10) / 100) : d; }));
	};

	/**
	 * Control points can include both percent string values (which will work off either the computed extent for the scale, or the user specified limits) or
	 * domain values.
	 */
	gradient.controlPoints = function(val) {
		if (!arguments.length) return this._controlPoints;
		this._controlPoints = val;
		this._adjustOuterDomain();
		return this;
	};

	/**
	 * An unreversed domain.  For continuous scales, this represents the limits of the domain (e.g. [0, 50]).
	 * For ordinal scales, this represents a unique set of all values (e.g. ["USA", "Mexico", "Canada", "Brazil"]).
	 */
	gradient.domain = function(val) {
		if (!arguments.length) return this._innerScale.domain();
		if (!this._innerScale) return this;
		this._innerScale.domain(val);
		this._adjustOuterDomain();
		return this;
	};

	gradient._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.gradient()
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.includeInDomain(this.includeInDomain())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.controlPoints(this.controlPoints())
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};
	gradient.copy = gradient._copy;
	return gradient;
});
dv.scale.time = dv.scale.continuous.extend(function() {
	function time() {
		this._super(d3.time.scale());
		this._parse = function(d) { return (d instanceof Date) ? d : new Date(Date.parse(d)); };
	}

	time._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.time()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};
	time.copy = time._copy;

	time._reconcileLimits = function(domain, min, max) {
		if (!dv.util.isUndefined(this._softLowerLimit)) {
			domain[0] = Math.min(domain[0], this._softLowerLimit);
			domain[1] = Math.max(domain[1], this._softLowerLimit);
		}

		if (!dv.util.isUndefined(this._lowerLimit))
			domain[0] = dv.util.isFunction(this._lowerLimit) ? this._parse(this._lowerLimit(new Date(min), new Date(max))) : this._lowerLimit;

		if (!dv.util.isUndefined(this._upperLimit))
			domain[1] = dv.util.isFunction(this._upperLimit) ? this._parse(this._upperLimit(new Date(min), new Date(max))) : this._upperLimit;
	};

	return time;
});
dv.scale.time.utc = dv.scale.continuous.extend(function() {
	function utc() {
		this._super(d3.time.scale.utc());
		this._parse = function(d) { return (d instanceof Date) ? d : new Date(Date.parse(d)); };
	}

	utc._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.time.utc()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};
	utc.copy = utc._copy;

	utc._reconcileLimits = function(domain, min, max) {
		if (!dv.util.isUndefined(this._softLowerLimit)) {
			domain[0] = Math.min(domain[0], this._softLowerLimit);
			domain[1] = Math.max(domain[1], this._softLowerLimit);
		}

		if (!dv.util.isUndefined(this._lowerLimit))
			domain[0] = dv.util.isFunction(this._lowerLimit) ? this._parse(this._lowerLimit(new Date(min), new Date(max))) : this._lowerLimit;

		if (!dv.util.isUndefined(this._upperLimit))
			domain[1] = dv.util.isFunction(this._upperLimit) ? this._parse(this._upperLimit(new Date(min), new Date(max))) : this._upperLimit;
	};

	return utc;
});
dv.scale.ordinal = dv.scale.extend(function() {
	function ordinal() {
		this._super(d3.scale.ordinal());
		this._defaultPadding = 0.1;
		this._defaultOuterPadding = 0;
		this._rangeExtent = [];
		this._rangeBandsSet = false;
	}

	ordinal._mapToD3Scale = function(val) {
		// D3's ordinal scale will automatically add an entry to the domain if that value is requested when mapping.
		// By checking to see if that value is contained in the domain before mapping, we can prevent this from
		// happening.
		var domain = this.domain(),
			i = -1,
			n = domain.length,
			index = -1;
		while (++i < n) {
			var d = domain[i];
			if (d === val || dv.util.isDate(d) && d.getTime() === val.getTime()) {
				index = i;
				break;
			}
		}
		return (index < 0) ? undefined : this._d3Scale(val);
	};

	/**
	 * Returns an unreversed continuous domain.  Reversing should automatically be done when the returned value
	 * is passed to the scale's domain setter if it is required.
	 */
	ordinal.calculateDomain = function(data, options) {
		var uniqValues = {};
		var tuple = [], trainingProps = this.trainingProperties();
		options = options || {};
		for (var p = 0; p < trainingProps.length; p++) {
			var prop = trainingProps[p];
			for(var j = 0; j < data.length; j++) {
				var values = data[j].values;
				if (!options.filter || !options.filter.call(this, data[j].key)) {
					for(var i = 0; i < values.length; i++) {
						var dataObj = values[i];
						if (!this._includeInDomain(dataObj, i)) continue;

						// If the scale has an index different than 0, let's append to the data object the index of the scale.
						if (this.scaleIndex() !== 0) dataObj[this.property() + "-index"] = this.scaleIndex();
						var val = this._parse.call(this, dataObj[prop]);
						if (!dv.util.isUndefined(val) && !uniqValues.hasOwnProperty(val)) {
							uniqValues[val] = val;
							tuple.push(val);
						}
					}
				}
			}
		}
		return tuple.length ? tuple : [];
	};

	ordinal.unionDomain = function(scale, isReversed) {
		if (!scale || !(scale instanceof dv.scale.ordinal)) {
			dv.log.error({msg: "The supplied scale is not ordinal.", data: { scale: scale, isReversed: isReversed }});
		}
		var domain = scale.domain();
		if (domain && !dv.util.isArray(domain)) throw new Error("The supplied domain is not an array");
		if (domain) {
			this.reverse(isReversed || this._reverse);
			this.domain(this.domain() ? dv.util.union(this.domain(), domain) : domain);
		}
		return this;
	};

	ordinal.unionRange = function(range) {
		if (range && !dv.util.isArray(range)) throw new Error("The supplied range is not an array");
		if (range) {
			this.range(this.range() ? dv.util.union(this.range(), range) : range);
		}
		return this;
	};

	ordinal.invertValue = function(val) {
		var index = this.range().indexOf(val),
			domain = this.domain();
		if (index < 0) throw new Error("The supplied value does not exist in the specified range.");

		return domain[index % domain.length];
	};

	ordinal.padding = function(val) {
		if (!arguments.length) return dv.util.isUndefined(this._padding) ? this._defaultPadding : this._padding;
		this._padding = val;

		if (this._rangeBandsSet) {
			this._d3Scale.rangeBands(this.rangeExtent(), this._padding, this.outerPadding());
		}
		return this;
	};

	ordinal.outerPadding = function(val) {
		if (!arguments.length) {
			return dv.util.isUndefined(this._outerPadding) ? (dv.util.isUndefined(this._padding) ? this._defaultOuterPadding : this.padding()) : this._outerPadding;
		}
		this._outerPadding = val;

		if (this._rangeBandsSet) {
			this._d3Scale.rangeBands(this.rangeExtent(), this.padding(), this._outerPadding);
		}
		return this;
	};

	ordinal.rangeBands = function(val) {
		if (!arguments.length) return this._d3Scale.range();
		this._rangeBandsSet = true;
		this._d3Scale.rangeBands(val, this.padding(), this.outerPadding());
		this.rangeExtent(val);
		return this;
	};

	ordinal.rangeBand = function() {
		return this._d3Scale.rangeBand();
	};

	ordinal.range = function(val) {
		if (!arguments.length) return this._d3Scale.range();
		if (!this._d3Scale) return this;
		if (!dv.util.isValidValue(val, ["isArray"])) dv.log.error({msg: "The supplied range is not an array", data: {range: val}});
		this._d3Scale.range(val);
		this.rangeExtent([val[0], val[val.length - 1]]);
		return this;
	};

	ordinal.rangeExtent = function(val) {
		if (!arguments.length) return this._rangeExtent;
		if (!dv.util.isValidValue(val, ["isArray"])) dv.log.error({msg: "The supplied range extent is not an array", data: {range: val}});
		this._rangeExtent = val;
		return this;
	};

	ordinal.values = function(val) {
		if (!arguments.length) return this._d3Scale.range();
		if (!dv.util.isValidValue(val, ["isArray"])) dv.log.error({msg: "The supplied values is not an array", data: {range: val}});
		return this.range(val);
	};

	ordinal.drop = function(val) {
		if (!arguments.length) return this._drop;
		this._drop = val;
		return this;
	};

	ordinal._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.ordinal()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.range(this.range().slice(0))
			.rangeExtent(this.rangeExtent().slice(0))
			.reverse(this.reverse())
			.padding(this._padding)
			.outerPadding(this._outerPadding)
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);

		if (this._rangeBandsSet) {
			scale.rangeBands(this.rangeExtent().slice(0));
		}

		return scale;
	};
	ordinal.copy = ordinal._copy;
	return ordinal;
});
dv.scale.color = dv.scale.ordinal.extend(function() {
	var dv_qualitative16 = [ "#8CC350", "#5A6EAA", "#D755A5", "#1EBED7", "#F0A01E", "#9B8CE6", "#3CB5A0", "#3287D2", "#F0557D", "#C3D250", "#EB782D", "#78B4F5", "#5FAF69", "#AA5FA5", "#FA5A50", "#F5C841" ];

	function color() {
		this._super();
		this.range(dv_qualitative16);
	}

	color._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.ordinal()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.range(this.range())
			.rangeExtent(this.rangeExtent())
			.includeInDomain(this.includeInDomain())
			.reverse(this.reverse())
			.padding(this._padding)
			.outerPadding(this._outerPadding)
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);

		if (this._rangeBandsSet) {
			scale.rangeBands(this.rangeExtent().slice(0))
				.padding(this._padding)
				.outerPadding(this._outerPadding);
		}

		return scale;
	};

	color.copy = color._copy;
	return color;
});

dv.scale.shape = dv.scale.ordinal.extend(function() {
	var dv_shape = [ "circle", "cross", "diamond", "square", "triangle-down", "triangle-up" ];

	function shape() {
		this._super();
		this.range(dv_shape);
	}

	shape._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.ordinal()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.range(this.range().slice(0))
			.rangeExtent(this.rangeExtent().slice(0))
			.reverse(this.reverse())
			.padding(this._padding)
			.outerPadding(this._outerPadding)
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);

		if (this._rangeBandsSet) {
			scale.rangeBands(this.rangeExtent().slice(0))
				.padding(this._padding)
				.outerPadding(this._outerPadding);
		}

		return scale;
	};
	shape.copy = shape._copy;
	return shape;
});

dv.scale.linetype = dv.scale.ordinal.extend(function() {
	var dv_linetype = [ "solid", "dashed", "dotted", "dotdash", "longdash", "twodash" ];

	function linetype() {
		this._super();
		this.range(dv_linetype);
	}

	linetype._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.ordinal()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.range(this.range().slice(0))
			.rangeExtent(this.rangeExtent().slice(0))
			.reverse(this.reverse())
			.padding(this._padding)
			.outerPadding(this._outerPadding)
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);

		if (this._rangeBandsSet) {
			scale.rangeBands(this.rangeExtent().slice(0))
				.padding(this._padding)
				.outerPadding(this._outerPadding);
		}

		return scale;
	};
	linetype.copy = linetype._copy;
	return linetype;
});
dv.scale.size = dv.scale.continuous.extend(function() {
	function size() {
		this._super();
		this.to([2, 10]);
	}

	size._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.size()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};
	size.copy = size._copy;
	return size;
});
dv.scale.identity = dv.scale.ordinal.extend(function() {
	function identity(scale) {
		this._super(d3.scale.ordinal());
	}

	identity.mapToProp = function(obj) { // We should probably be able to remove this if the identity scale is trained correctly.
		return obj[this.property()];
	};

	identity.domain = function(val) {
		if (!arguments.length) return this._d3Scale.domain();
		if (!this._d3Scale) return this;
		this._d3Scale.domain(val);
		this._d3Scale.range(val);
		return this;
	};

	identity.range = function() {
		if (!arguments.length) return this._d3Scale.range();
		return this;
	};

	identity.labels = function(val) { // TODO: Implement me
		if (!arguments.length) return this._labels;
		this._labels = val;
		return this;
	};

	identity._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		return dv.scale.identity()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.range(this.range().slice(0))
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
	};
	identity.copy = identity._copy;
	return identity;
});
dv.scale.log = dv.scale.continuous.extend(function() {
	function log() {
		this._super(d3.scale.log());
	}

	log._copy = function() {
		var domain = this.domain().slice(0),
			trainProps = this.trainingProperties();
		if (!dv.util.isUndefined(trainProps)) trainProps = trainProps.slice(0);

		var scale = dv.scale.log()
			.isDefault(this.isDefault())
			.property(this.property())
			.mapping(this.mapping())
			.domain(domain)
			.includeInDomain(this.includeInDomain())
			.upperLimit(this.upperLimit())
			.lowerLimit(this.lowerLimit())
			.upperRangePadding(this.upperRangePadding())
			.lowerRangePadding(this.lowerRangePadding())
			.softLowerLimit(this.softLowerLimit())
			.range(this.range().slice(0))
			.reverse(this.reverse())
			.trainingProperties(trainProps)
			.scaleIndex(this._scaleIndex);
		scale._naturalDomain = this._naturalDomain;
		return scale;
	};

	log.domain = function(val) {
		if (val) {
			// Check to see if the domain is valid
			var extent = d3.extent(val);
			if (extent[0] <= 0 && extent[1] >= 0) {
				throw new Error('Data mapped to the logarithmic "' + this.property() + '" property must be entirely positive or entirely negative. The data values cannot cross zero.');
			}
		}
		return this._super.apply(this, arguments);
	};

	log.copy = log._copy;
	return log;
});
dv.svg = dv.svg || {};

dv.svg.text = function() {
	var x = dv_svg_textX,
		y = dv_svg_textY,
		label = dv_svg_textLabel,
		defined = dv_svg_textDefined,
		duration = dv_svg_textDuration;

	function text(selection) {
		return selection
			.select(function(d, i) { return defined.call(this, d, i) ? this : null; }) // filter out the undefined results.
			.attr('x', function(d, i) { return x.call(this, d, i); })
			.attr('y', function(d, i) { return y.call(this, d, i); })
			.text(function(d, i) { return label.call(this, d, i); });
	}

	text.x = function(val) {
		if (!arguments.length) return x;
		x = val;
		return text;
	};

	text.y = function(val) {
		if (!arguments.length) return y;
		y = val;
		return text;
	};

	text.label = function(val) {
		if (!arguments.length) return label;
		label = val;
		return text;
	};

	text.defined = function(val) {
		if (!arguments.length) return defined;
		defined = val;
		return text;
	};

	text.duration = function(val) {
		if (!arguments.length) return duration;
		duration = val;
		return text;
	};

	return text;
};

dv.svg.text.radial = function() {
	var angle = dv_svg_textX,
		radius = dv_svg_textY,
		label = dv_svg_textLabel,
		defined = dv_svg_textDefined,
		duration = dv_svg_textDuration;

	function text(selection) {
			var a = function(d, i) { return angle.call(this, d, i) + dv_svg_arcOffset; },
				r = function(d, i) { return radius.call(this, d, i); };
			return selection
				.select(function(d, i) { return defined.call(this, d, i) ? this : null; }) // filter out the undefined results.
				.attr('x', function(d, i) { return r(d, i) * Math.cos(a(d, i)); })
				.attr('y', function(d, i) { return r(d, i) * Math.sin(a(d, i)); })
				.text(function(d, i) { return label.call(this, d, i); });
	}

	text.angle = function(val) {
		if (!arguments.length) return angle;
		angle = val;
		return text;
	};

	text.radius = function(val) {
		if (!arguments.length) return radius;
		radius = val;
		return text;
	};

	text.label = function(val) {
		if (!arguments.length) return label;
		label = val;
		return text;
	};

	text.defined = function(val) {
		if (!arguments.length) return defined;
		defined = val;
		return text;
	};

	text.duration = function(val) {
		if (!arguments.length) return duration;
		duration = val;
		return text;
	};

	return text;
};

function dv_svg_textX(d) {
	return d[0];
}

function dv_svg_textY(d) {
	return d[1];
}

function dv_svg_textLabel(d) {
	return d[2];
}

function dv_svg_textDefined() {
	return true;
}

function dv_svg_textDuration() {
	return 0;
}

dv.svg.rect = function() {
	var x0 = dv_svg_rectX0,
		x1 = dv_svg_rectX1,
		y0 = dv_svg_rectY0,
		y1 = dv_svg_rectY1,
		defined = dv_svg_rectDefined;

	function rect(d, i) {
		if (defined.call(this, d, i)) {
			return dv_svg_rect(x0.call(this, d, i), x1.call(this, d, i), y0.call(this, d, i), y1.call(this, d, i));
		}
		return null;
	}

	rect.x0 = function(val) {
		if (!arguments.length) return x0;
		x0 = val;
		return rect;
	};

	rect.x1 = function(val) {
		if (!arguments.length) return x1;
		x1 = val;
		return rect;
	};

	rect.y0 = function(val) {
		if (!arguments.length) return y0;
		y0 = val;
		return rect;
	};

	rect.y1 = function(val) {
		if (!arguments.length) return y1;
		y1 = val;
		return rect;
	};

	rect.defined = function(x) {
		if (!arguments.length) return defined;
		defined = x;
		return rect;
	};

	return rect;
};

function dv_svg_rectX0(d) {
	return d[0];
}

function dv_svg_rectX1(d) {
	return d[1];
}

function dv_svg_rectY0(d) {
	return d[2];
}

function dv_svg_rectY1(d) {
	return d[3];
}

function dv_svg_rectDefined() {
	return true;
}

function dv_svg_rect(x0, x1, y0, y1) {
	// return "M" + x0 + "," + y0 + "L" + x1 + "," + y0 + " A0,0,0,0,1," + x1 + "," + y0 +
	//	" L" + x1 + "," + y1 + " A0,0,0,0,1," + x1 + "," + y1 +
	//	" L" + x0 + "," + y1 + " A0,0,0,0,1," + x0 + "," + y1 +
	//	" L" + x0 + "," + y0 + " A0,0,0,0,1," + x0 + "," + y0 + "Z";
	return "M" + x0 + "," + y0 +
			"L" + x1 + "," + y0 +
			"L" + x1 + "," + y1 +
			"L" + x0 + "," + y1 + "Z";
	//return "M" + x0 + "," + y0 + "A0,0 0 0,1 " + x1 + "," + y0 + "L" + x1 + "," + y1 + "A280000,280000 0 0,0 " + x0 + "," + y1 + "Z";
}

dv.svg.symbol = function() {
	var type = dv_svg_symbolType,
		size = dv_svg_symbolSize,
		x = dv_svg_symbolX,
		y = dv_svg_symbolY,
		defined = dv_svg_symbolDefined;

	function symbol(d, i) {
		if (defined.call(this, d, i)) {
			return (dv_svg_symbols[type.call(this, d, i)]
				|| dv_svg_symbols.circle)
				(size.call(this, d, i), x.call(this, d, i), y.call(this, d, i));
		}
		return null;
	}

	symbol.x = function(val) {
		if (!arguments.length) return x;
		x = val;
		return symbol;
	};

	symbol.y = function(val) {
		if (!arguments.length) return y;
		y = val;
		return symbol;
	};

	symbol.type = function(x) {
		if (!arguments.length) return type;
		type = d3.functor(x);
		return symbol;
	};

	// size of symbol in square pixels
	symbol.size = function(x) {
		if (!arguments.length) return size;
		size = d3.functor(x);
		return symbol;
	};

	symbol.defined = function(x) {
		if (!arguments.length) return defined;
		defined = x;
		return symbol;
	};

	return symbol;
};

dv.svg.symbol.radial = function() {
	var type = dv_svg_symbolType,
		size = dv_svg_symbolSize,
		angle = dv_svg_symbolX,
		radius = dv_svg_symbolY,
		defined = dv_svg_symbolDefined;

	function symbol(d, i) {
		if (defined.call(this, d, i)) {
			var a = angle.call(this, d, i) + dv_svg_arcOffset,
				r = radius.call(this, d, i),
				x = r * Math.cos(a),
				y = r * Math.sin(a);
			return (dv_svg_symbols[type.call(this, d, i)]
				|| dv_svg_symbols.circle)
				(size.call(this, d, i), x, y);
		}
		return null;
	}

	symbol.angle = function(val) {
		if (!arguments.length) return angle;
		angle = val;
		return symbol;
	};

	symbol.radius = function(val) {
		if (!arguments.length) return radius;
		radius = val;
		return symbol;
	};

	symbol.type = function(x) {
		if (!arguments.length) return type;
		type = d3.functor(x);
		return symbol;
	};

	// size of symbol in square pixels
	symbol.size = function(x) {
		if (!arguments.length) return size;
		size = d3.functor(x);
		return symbol;
	};

	symbol.defined = function(x) {
		if (!arguments.length) return defined;
		defined = x;
		return symbol;
	};

	return symbol;
};

d3.svg.symbolTypes = d3.keys(dv_svg_symbols);

// TODO cross-diagonal?
var dv_svg_symbols = {
	"circle": function(size, x, y) {
		var r = Math.sqrt(size / Math.PI);
		return "M" + x + "," + (y + r)
			+ "A" + r + "," + r + " 0 1,1 " + x + "," + (y - r)
			+ "A" + r + "," + r + " 0 1,1 " + x + "," + (y + r)
			+ "Z";
	},
	"cross": function(size, x, y) {
		var r = Math.sqrt(size / 5) / 2;
		return "M" + (x + -3 * r) + "," + (y - r)
			+ "H" + (x - r)
			+ "V" + (y + -3 * r)
			+ "H" + (x + r)
			+ "V" + (y - r)
			+ "H" + (x + 3 * r)
			+ "V" + (y + r)
			+ "H" + (x + r)
			+ "V" + (y + 3 * r)
			+ "H" + (x - r)
			+ "V" + (y + r)
			+ "H" + (x -3 * r)
			+ "Z";
	},
	"diamond": function(size, x, y) {
		var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
		return "M" + x + "," + (y - ry)
			+ "L" + (x + rx) + "," + y
			+ " " + x + "," + (y + ry)
			+ " " + (x - rx) + "," + y
			+ "Z";
	},
	"square": function(size, x, y) {
		var r = Math.sqrt(size) / 2;
		return "M" + (x - r) + "," + (y - r)
			+ "L" + (x + r) + "," + (y - r)
			+ " " + (x + r) + "," + (y + r)
			+ " " + (x - r) + "," + (y + r)
			+ "Z";
	},
	"triangle-down": function(size, x, y) {
		var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
		return "M" + x + "," + (y + ry)
			+ "L" + (x + rx) + "," + (y - ry)
			+ " " + (x - rx) + "," + (y - ry)
			+ "Z";
	},
	"triangle-up": function(size, x, y) {
		var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
		return "M" + x + "," + (y - ry)
			+ "L" + (x + rx) + "," + (y + ry)
			+ " " + (x - rx) + "," + (y + ry)
			+ "Z";
	}
};

function dv_svg_symbolSize() {
	return 64;
}

function dv_svg_symbolType() {
	return "circle";
}

function dv_svg_symbolX(d) {
	return d[0];
}

function dv_svg_symbolY(d) {
	return d[1];
}

function dv_svg_symbolDefined(d) {
	return true;
}

dv.svg.errorBar = function() {
	var x0 = dv_svg_errorBarX0,
		x1 = dv_svg_errorBarX1,
		y0 = dv_svg_errorBarY0,
		y1 = dv_svg_errorBarY1,
		flip = dv_svg_errorBarFlip,
		defined = dv_svg_errorBarDefined;

	function errorBar(d, i) {
		if (defined.call(this, d, i)) {
			return dv_svg_errorBar(x0.call(this, d, i), x1.call(this, d, i), y0.call(this, d, i), y1.call(this, d, i), flip.call(this, d, i));
		}
		return null;
	}

	errorBar.x0 = function(val) {
		if (!arguments.length) return x0;
		x0 = val;
		return errorBar;
	};

	errorBar.x1 = function(val) {
		if (!arguments.length) return x1;
		x1 = val;
		return errorBar;
	};

	errorBar.y0 = function(val) {
		if (!arguments.length) return y0;
		y0 = val;
		return errorBar;
	};

	errorBar.y1 = function(val) {
		if (!arguments.length) return y1;
		y1 = val;
		return errorBar;
	};

	errorBar.flip = function(val) {
		if (!arguments.length) return flip;
		flip = val;
		return errorBar;
	};

	errorBar.defined = function(x) {
		if (!arguments.length) return defined;
		defined = x;
		return errorBar;
	};

	return errorBar;
};

function dv_svg_errorBarX0(d) {
	return d[0];
}

function dv_svg_errorBarX1(d) {
	return d[1];
}

function dv_svg_errorBarY0(d) {
	return d[2];
}

function dv_svg_errorBarY1(d) {
	return d[3];
}

function dv_svg_errorBarFlip() {
	return false;
}

function dv_svg_errorBarDefined() {
	return true;
}

function dv_svg_errorBar(x0, x1, y0, y1, flip) {
	var mid;
	if (flip) {
		mid = y0 + ((y1 - y0) / 2);
		return "M" + x0 + "," + y0 +
				"L" + x0 + "," + y1 +
				"M" + x0 + "," + mid +
				"L" + x1 + "," + mid +
				"M" + x1 + "," + y0 +
				"L" + x1 + "," + y1;
	}
	else {
		mid = x0 + ((x1 - x0) / 2);
		return "M" + x0 + "," + y0 +
				"L" + x1 + "," + y0 +
				"M" + mid + "," + y0 +
				"L" + mid + "," + y1 +
				"M" + x0 + "," + y1 +
				"L" + x1 + "," + y1;
	}
}

var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);

var dv_svg_arcOffset = -Math.PI / 2;

//---------------------- Polygons

dv.svg.poly = function() {
	var defined = dv_svg_polyDefined,
		xs = dv_svg_poly_Xs,
		ys = dv_svg_poly_Ys;

	function poly(d, i) {
		if (defined.call(this, d, i)) {
			return dv_svg_poly(xs.call(this, d, i), ys.call(this, d, i));
		}

		return null;
	}

	poly.xs = function (val) {
		if (!arguments.length)
			return xs;
		xs = val;

		return poly;
	};

	poly.ys = function (val) {
		if (!arguments.length)
			return ys;
		ys = val;

		return poly;
	};

	poly.defined = function (val) {
		if (!arguments.length)
			return defined;
		defined = val;

		return defined;
	};

	return poly;
};

dv.svg.poly.radial = function() {
	var defined = dv_svg_polyDefined,
		angles = dv_svg_poly_Xs,
		radii = dv_svg_poly_Ys;

	function poly(d, i) {
		if (defined.call(this, d, i)) {
			var angs = angles.call(this, d, i);
			var rads = radii.call(this, d, i);
			var max_i = d3.max([angs.length, rads.length]);
			var rval = "M";

			for (var j = 0; j < max_i; j++) {
				if (j > 0) {
					rval += "L";
				}
				var a = angs[j] + dv_svg_arcOffset,
					r = rads[j],
					x = r * Math.cos(a),
					y = r * Math.sin(a);

				rval += (j < angs.length ? x : "0");
				rval += ",";
				rval += (j < rads.length ? y : "0");
			}

			rval += "Z";
			return rval;
		}

		return null;
	}

	poly.angles = function (val) {
		if (!arguments.length) return angles;
		angles = val;
		return poly;
	};

	poly.radii = function (val) {
		if (!arguments.length) return radii;
		radii = val;
		return poly;
	};

	poly.defined = function (val) {
		if (!arguments.length) return defined;
		defined = val;
		return defined;
	};

	return poly;
};

// Default poly functions
function dv_svg_polyDefined(d) {
	return true;
}

function dv_svg_poly_Xs(d) {
	return d[0];
}

function dv_svg_poly_Ys(d) {
	return d[1];
}

function dv_svg_poly(xs, ys) {
	var max_i = d3.max([xs.length, ys.length]);
	var rval = "M";

	for (var i = 0; i < max_i; i++) {
		if (i > 0) {
			rval += "L";
		}
		rval += (i < xs.length ? xs[i] : "0");
		rval += ",";
		rval += (i < ys.length ? ys[i] : "0");
	}

	rval += "Z";
	return rval;
}
dv.util = {};

/**
 * Converts a data format from an object of tuples:
 * {
 *      x: [0, 0, 1, 1, 2, 2],
 *      y: [10, 22, 43, 17, 23, 34],
 *      series: ['one', 'two', 'one', 'two', 'one', 'two']
 * }
 * into a zip array:
 * [
 *      {x: 0, y: 10, series: 'one'}
 *      {x: 1, y: 43, series: 'one'}
 *      {x: 2, y: 23, series: 'one'}
 * ]
 *
 * where the filterKey is the tuple we are grouping (ex. series) and filterValue is the value for which an object is included (ex. 'one').  If
 * no filterKey or filterValue are specified, no filtering will occur, but the tuples will still be transformed into a zip array.
 */
dv.util.filterAndZip = function(data, filterKey, filterValue) {
	var sampleArray = [],
		result = [];

	if (!filterKey) {
		// Grab the first tuple -- we assume they all have the same length.
		// TODO: How will this work if stats produces data of different length?
		for (var k in data) {
			sampleArray = data[k];
			break;
		}
	}
	else {
		sampleArray = data[filterKey]; // Otherwise we'll use the filter tuple instead.
	}

	var i = -1,
		len = sampleArray.length;
	while (++i < len) {
		var cursor = sampleArray[i];

		if (!filterValue || cursor == filterValue) {
			var sliceObj = {};
			for (var k2 in data) {
				if (k2 === "data") {
					sliceObj[k2] = {};
					for (var k3 in data[k2]) {
						sliceObj[k2][k3] = data[k2][k3][i];
					}
				} else {
					sliceObj[k2] = data[k2][i];
				}
			}
			result.push(sliceObj);
		}
	}

	return result;
};

dv.util.binaryCompare = function(a, x, f, lo, hi) {
	var tempLo = lo;

	if (arguments.length < 4) tempLo = 0;
	if (arguments.length < 5) hi = a.length;
	while (tempLo < hi) {
		var mid = (tempLo + hi) >> 1;
		if (x < f(a[mid])) hi = mid;
		else tempLo = mid + 1;
	}

	if (tempLo == lo || Math.abs(f(a[tempLo]) - x) < Math.abs(f(a[tempLo - 1]) - x)) return tempLo;
	else return tempLo - 1;
};

dv.util.uniqueValues = function(array, comparator) {
	var results = [];
	dv.util.each(array, function(value, index) {
		var i = -1,
			n = results.length,
			found = false;
		while (++i < n) {
			var seenVal = results[i];
			if (comparator(value, seenVal)) {
				found = true;
				break;
			}
		}

		if (!found) {
			results.push(array[i]);
		}
	});

	return results;
};

/**
 * Returns the range of the given scale.
 */
dv.util.scaleRange = function(scale, range) {
	if (arguments.length === 1) return scale.rangeExtent ? scale.rangeExtent() : scale.range();
	if (scale.rangeExtent)
		scale.rangeBands(range);
	else
		scale.range(range);
	return scale;
};

/**
 * Calculates the minimum distance between points. prop represents the property we are applying the distance
 * calculation to while nestData is a multidimensional array spanning facets and groups.
 */
dv.util.minRangeDistance = function(prop, nestData) {
	var minDistanceBetweenPoints = Number.MAX_VALUE,
		value,
		previousValue;

	dv.util.each(nestData, function(seriesData) {
		dv.util.each(seriesData.values, function(pointData) {
			value = pointData.panel.xScale(pointData).mapValue(pointData[prop]);
			if (!dv.util.isUndefined(previousValue)) {
				minDistanceBetweenPoints = Math.min(minDistanceBetweenPoints, Math.abs(value - previousValue));
			}
			previousValue = value;
		});
	});

	return minDistanceBetweenPoints;
};

/**
 * Returns the range of the given scale from min to max always.
 */
dv.util.scaleRangeNoReverse = function(scale) {
	return scale.rangeExtent ? scale.rangeExtent() : dv.util.scaleExtent(scale.range());
};

/**
 * Returns the extent of a given domain array.  It will always be ordered from min to max.
 */
dv.util.scaleExtent = function(domain) {
	var start = domain[0], stop = domain[domain.length - 1];
	return start < stop ? [ start, stop ] : [ stop, start ];
};

/**
 * Returns an object which is the result of merging the properties of the two objects. obj2 takes
 * precedence over obj1 when they have like properties.  Neither objects are changed.
 */
dv.util.merge = function(obj1, obj2) {
	var retVal = {};
	var prop;
	for (prop in obj1) { retVal[prop] = obj1[prop]; }
	for (prop in obj2) { retVal[prop] = obj2[prop]; }
	return retVal;
};

/**
 *	Returns the hard value based on the percent in "value" relative to "relativeValue".
 */
dv.util.getPercentValue = function(value, relativeValue) {
	return (dv.util.isPercentString(value)) ? (relativeValue * parseInt(value, 10) / 100) : value;
};

dv.util.isPercentString = function(value) {
	return (typeof value === "string" && /^(-?[0-9]+)%$/.test(value));
};

dv.util.isValidValue = function(val, tests) {
	for (var i = 0; i < tests.length; i++) {
		if (dv.util[tests[i]](val)) return true;
	}
	return false;
};

dv.util.identity = function(value) {
	return value;
};

dv.util.clamp = function(val, min, max) {
	return Math.min(Math.max(val, min), max);
};

dv.util.clone = function(obj) {
	if (!dv.util.isObject(obj)) return obj;
	return dv.util.isArray(obj) ? obj.slice() : dv.util.extend({}, obj);
};

dv.util.isArray = function(obj) {
	if (Array.isArray) return Array.isArray(obj);
	return Object.prototype.toString.call(obj) == '[object Array]';
};

dv.util.isObject = function(obj) {
	return obj === Object(obj);
};

dv.util.isFunction = function(obj) {
	return Object.prototype.toString.call(obj) == '[object Function]';
};

dv.util.isUndefined = function(obj) {
	return obj === void 0;
};

dv.util.isFinite = function(obj) {
	return isFinite(obj) && !isNaN(parseFloat(obj));
};

dv.util.isDate = function(obj) {
	return obj instanceof Date;
};

dv.util.isEmpty = function(obj) {
	return Object.keys(obj).length === 0;
};

dv.util.extend = function(obj) {
	dv.util.each(Array.prototype.slice.call(arguments, 1), function(source) {
		for (var prop in source) {
			obj[prop] = source[prop];
		}
	});
	return obj;
};

dv.util.each = function(obj, iterator, context) {
	if (obj == null) return;
	if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
		obj.forEach(iterator, context);
	} else if (obj.length === +obj.length) {
		for (var i = 0, l = obj.length; i < l; i++) {
			if (iterator.call(context, obj[i], i, obj) === {}) return;
		}
	} else {
		for (var key in obj) {
			if (dv.util.has(obj, key)) {
				if (iterator.call(context, obj[key], key, obj) === {}) return;
			}
		}
	}
};

dv.util.has = function(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
};

dv.util.uniq = function(array, isSorted, iterator, context) {
	if (dv.util.isFunction(isSorted)) {
		context = iterator;
		iterator = isSorted;
		isSorted = false;
	}
	var initial = iterator ? dv.util.map(array, iterator, context) : array;
	var results = [];
	var seen = [];
	dv.util.each(initial, function(value, index) {
		if (isSorted ? (!index || seen[seen.length - 1] !== value) : !dv.util.contains(seen, value)) {
			seen.push(value);
			results.push(array[index]);
		}
	});
	return results;
};

dv.util.union = function() {
	return dv.util.uniq(Array.prototype.concat.apply(Array.prototype, arguments));
};

dv.util.contains = function(obj, target) {
	if (obj == null) return false;
	if (Array.prototype.indexOf && obj.indexOf === Array.prototype.indexOf) return obj.indexOf(target) != -1;
	return dv.util.any(obj, function(value) {
		return value === target;
	});
};

dv.util.any = function(obj, iterator, context) {
	if (!iterator)
		iterator = dv.util.identity;
	var result = false;
	if (obj == null) return result;
	if (Array.prototype.some && obj.some === Array.prototype.some) return obj.some(iterator, context);
	dv.util.each(obj, function(value, index, list) {
		if (result || (result = iterator.call(context, value, index, list))) return {};
	});
};

dv.util.sortBy = function(obj, value, context) {
	var lookupIterator = function(value) { return dv.util.isFunction(value) ? value : function(obj) { return obj[value]; }; };
	var iterator = lookupIterator(value);
	return dv.util.pluck(dv.util.map(obj, function(value, index, list) {
		return {
			value: value,
			index: index,
			criteria: iterator.call(context, value, index, list)
		};
	}).sort(function(left, right) {
		var a = left.criteria;
		var b = right.criteria;
		if (a !== b) {
			if (a > b || a === void 0) return 1;
			if (a < b || b === void 0) return -1;
		}
		return left.index < right.index ? -1 : 1;
	}), 'value');
};

dv.util.pluck = function(obj, key) {
	return dv.util.map(obj, function(value) { return value[key]; });
};

dv.util.map = function(obj, iterator, context) {
	var results = [];
	if (obj === null) return results;
	if (Array.prototype.map && obj.map === Array.prototype.map) return obj.map(iterator, context);
	dv.util.each(obj, function(value, index, list) {
		results[results.length] = iterator.call(context, value, index, list);
	});
	return results;
};

dv.util.reduce = function(obj, iterator, memo, context) {
	var initial = arguments.length > 2;
	if (obj === null) obj = [];
	if (Array.prototype.reduce && obj.reduce === Array.prototype.reduce) {
		if (context) iterator = dv.util.bind(iterator, context);
		return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	}
	dv.util.each(obj, function(value, index, list) {
		if (!initial) {
			memo = value;
			initial = true;
		} else {
			memo = iterator.call(context, memo, value, index, list);
		}
	});
	if (!initial) throw new TypeError("Reduce of empty array with no initial value");
	return memo;
};

dv.util.bind = function(func, context) {
	if (func.bind === Function.prototype.bind && Function.prototype.bind) return Function.prototype.bind.apply(func, Array.prototype.slice.call(arguments, 1));
	var args = Array.prototype.slice.call(arguments, 2);
	return function() {
		return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
	};
};

dv.util.noop = function() {};

dv.util.each(['Arguments', 'String', 'Number', 'RegExp'], function(name) {
    dv.util['is' + name] = function(obj) {
		return toString.call(obj) == '[object ' + name + ']';
	};
});

dv.util.validateParam = function(param, type, range, defaultVal) {
	if (type === 'isString') {
		if (dv.util.isString(param)) {
			if (dv.util.isArray(range) && (range.indexOf(param.toLowerCase()) !== -1)) return param.toLowerCase();
		}
		return defaultVal;
	} else if (type === 'isNumber') {
		if (dv.util.isNumber(param)){
			if (dv.util.isArray(range) && (param <= range[1] && param >= range[0])) return param;
		}
		return defaultVal;
	} else if (type === 'isFunction') {
		if (dv.util.isFunction(param)) return param;
		return defaultVal;
	} else if (type === 'isDimension') {
		if (param === 'x' || param === 'X') return 'x';
		if (param === 'y' || param === 'Y') return 'y';
		if (param === ['x','y'] || param === ['X','y'] || param === ['x','Y'] || param === ['X','Y']) return ['x','y'];
		return defaultVal;
	} else if (type === 'isRange') {
		var minVal = range[0], maxVal = range[1];
		if (dv.util.isArray(param) && param.length === 2){
			if (dv.util.isNumber(param[0]) && dv.util.isNumber(param[1])){
				minVal = Math.max(Math.min(param[0],param[1]),range[0]);
				maxVal = Math.min(Math.max(param[0],param[1]),range[1]);
			}
			return [minVal,maxVal];
		}
		return defaultVal;
	}
};

dv.util = dv.util || {};
dv.util.svg = {};

// Allows passing in user-friendly linetype formats such as solid, dashed, dotted, etc (see dv.scale.linetype for accepted values) and
// returns a dasharray. If the key is already in dasharray format, it just returns itself.
dv.util.svg.getDasharray = function(key) {
	if (key.indexOf(',') != -1 || key.indexOf(' ') != -1) return key; // It's already in dasharray format just return it.
	if (dv_dasharray.hasOwnProperty(key)) return dv_dasharray[key];
	throw new Error("The dashed line format is invalid");
};

var dv_dasharray = {
	"solid": "",
	"dashed": "7,4",
	"dotted": "2,3",
	"dotdash": "2,3,7,4",
	"longdash": "11,4",
	"twodash": "5,2,11,2"
};
dv.container = dv.extend(function() {
	var dv_container_defaultScales = {
		'x': dv.scale.linear,
		'y': dv.scale.linear,
		'yMin': dv.scale.linear,
		'yMax': dv.scale.linear,
		'xMin': dv.scale.linear,
		'xMax': dv.scale.linear,
		'color': dv.scale.color,
		'fill': dv.scale.color,
		'stroke': dv.scale.color,
		'alpha': dv.scale.linear,
		'shape': dv.scale.shape,
		'size': dv.scale.size,
		'radius': dv.scale.linear,
		'group': dv.scale.ordinal,
		'linetype': dv.scale.linetype,
		'label': dv.scale.identity
	};

	function container() {
		this._aes = {};
	}

	container.render = function() {
		throw new Error("render() must be implemented in a subclass");
	};

	container._calculateStats = function() {
		throw new Error("_calculateStats() must be implemented in a subclass");
	};

	container._handlePositions = function() {
		throw new Error("_handlePositions() must be implemented in a subclass");
	};

	container.getTrainedScale = function(prop) {
		throw new Error("getTrainedScale() must be implemented in a subclass");
	};

	container.getExplicitScalesMap = function() {
		return this._aes;
	};

	container._normalizeData = function(data) {
		// The data is already normalized, return it back out.
		if (data.hasOwnProperty("data") && !dv.util.isArray(data.data)) return data;

		var normalizedData = {},
			map = this.getExplicitScalesMap(),
			scale,
			self = this;
		dv.util.each(map, function(d, i) {
			for (var scaleIndex in d) {
				scale = d[scaleIndex];
				if (!(scale instanceof dv.scale.constant)) {
					var arr = data[scale.mapping()];

					if (dv.util.isArray(arr)) {
						var parsedArr = arr.map(function(d) {
							if (dv.util.isArray(d)) {
								return d.map(function(subD) {
									return scale._parse(subD);
								});
							}
							else {
								return scale._parse(d);
							}
						});
						normalizedData[scale.property()] = parsedArr;
					}
				}
			}
		});
		normalizedData.data = data;
		return normalizedData;
	};

	container.map = function(property, mapping, scale, scaleIndex) {
		//	We capture when the default is used, so that we can determine if chart settings should override the individual scale's.
		//	For example, if the chart defines explicit bounds (which the default scale doesn't), then properties mapped with the
		//	default scale, will not train to honor the chart's bounds.
		if (!scale) scale = dv_container_defaultScales[property]().copy().isDefault(true);
		if (!scale) throw new Error("There is no default scale associated with this property. Either the property isn't valid or the scale default doesn't exist.");
		if (arguments.length < 4) scaleIndex = 0;
		if (!this._aes[property]) this._aes[property] = {};
		this._aes[property][scaleIndex] = scale.property(property).mapping(mapping).scaleIndex(scaleIndex);
		return this;
	};

	// TODO: container.set may want to accept a scaleIndex in the future to make it match with map, although this isn't
	// necessary at this point in time.
	container.set = function(property, val) {
		if (!this._aes[property]) this._aes[property] = {};
		var scale = this._aes[property][0] = dv.scale.constant();
		if (dv.util.isFunction(val)) {
			scale.map = scale.mapToProp = val;
		}
		else scale.value(val);
		return this;
	};

	container.on = function(eventType, callback, capture) {
		if (arguments.length < 3) {
			capture = false;
		}
		var adding = callback && dv.util.isFunction(callback);
		if (adding) {
			this.eventMap = this.eventMap || {};
			this.eventMap[eventType] = {callback: callback, capture: capture};
		}
		else {
			if (this.eventMap) delete this.eventMap[eventType];
			this.unregisterEventMap = this.unregisterEventMap || {};
			this.unregisterEventMap[eventType] = capture;
		}

		this._removeRegisteredEvents();
		this._addRegisteredEvents();

		return this;
	};

	// Positions include:
	// dodge
	// fill
	// identity
	// jitter -- not currently supported
	// stack
	// Grammar of Graphics, p. 59
	container.position = function(val) {
		if (!arguments.length) return (this._chart && !this._position) ? this._chart.position() : this._position;
		this._position = val;
		return this;
	};

	container.delay = function(val) {
		if (!arguments.length) return (this._chart && dv.util.isUndefined(this._delay)) ? this._chart.delay() : this._delay;
		this._delay = d3.functor(val);
		return this;
	};

	container.duration = function(val) {
		if (!arguments.length) return (this._chart && dv.util.isUndefined(this._duration)) ? this._chart.duration() : this._duration;
		this._duration = d3.functor(val);
		return this;
	};

	container.ease = function(val) {
		if (!arguments.length) return (this._chart && dv.util.isUndefined(this._ease)) ? this._chart.ease() : this._ease;
		this._ease = val;
		return this;
	};

	return container;
});
dv.coord = dv.extend(function() {
	function coord() {
		this._flip = false;
	}

	coord.flip = function(val) {
		if (!arguments.length) return this._flip;
		this._flip = val;
		return this;
	};

	coord.startX = function(val) {
		if (!arguments.length) return this._startX;
		if (!dv.util.isValidValue(val, ["isFinite", "isPercentString"])) dv.log.error({msg: "Invalid value type, startX/startAngle must be a number or percent string", data: {val: val}});
		this._startX = val;
		return this;
	};

	coord.endX = function(val) {
		if (!arguments.length) return this._endX;
		if (!dv.util.isValidValue(val, ["isFinite", "isPercentString"])) dv.log.error({msg: "Invalid value type, endX/endAngle must be a number or percent string", data: {val: val}});
		this._endX = val;
		return this;
	};

	coord.startY = function(val) {
		if (!arguments.length) return this._startY;
		if (!dv.util.isValidValue(val, ["isFinite", "isPercentString"])) dv.log.error({msg: "Invalid value type, startY/innerRadius must be a number or percent string", data: {val: val}});
		this._startY = val;
		return this;
	};

	coord.endY = function(val) {
		if (!arguments.length) return this._endY;
		if (!dv.util.isValidValue(val, ["isFinite", "isPercentString"])) dv.log.error({msg: "Invalid value type, endY/outerRadius must be a number or percent string", data: {val: val}});
		this._endY = val;
		return this;
	};
	return coord;
});

dv.coord.cartesian = dv.coord.extend(function() {
	function cartesian() {
		this._super();
		this.startX(0);
		this.endX(0);
		this.startY(0);
		this.endY(0);
		this._type = "cartesian";
	}

	cartesian._translatePercentToX = function(scale, percent) {
		var range = dv.util.scaleRange(scale),
			val = this._translatePercent(percent, range, this.startX(), this.endX()),
			rangeDist = Math.abs(range[1] - range[0]) * 3;
		// Depending on the domain, we can get into situations where the y value we are returning is extremely negative (e.g. -15023491243.234871)
		// or extremely positive.  When this happens, we get some rendering artifacts introduced by the browser.  By constraining how far out
		// these points can be rendered (should be outside the visible area), we can avoid some of these rendering pitfalls.
		return dv.util.clamp(val, range[0] - rangeDist, range[1] + rangeDist);
	};

	cartesian._translatePercentToY = function(scale, percent) {
		var range = dv.util.scaleRange(scale),
			val = this._translatePercent(percent, range, this.startY(), this.endY()),
			rangeDist = Math.abs(range[1] - range[0]) * 3;
		// Depending on the domain, we can get into situations where the y value we are returning is extremely negative (e.g. -15023491243.234871)
		// or extremely positive.  When this happens, we get some rendering artifacts introduced by the browser.  By constraining how far out
		// these points can be rendered (should be outside the visible area), we can avoid some of these rendering pitfalls.
		return dv.util.clamp(val, range[1] - rangeDist, range[0] + rangeDist);
	};

	cartesian._translatePercent = function(percent, range, start, end) {
		return (((range[1] - range[0]) - end - start) * percent + start + range[0]);
	};

	cartesian._translatePercentArrToY = function(scale, percentArr) {
		var self = this;
		return dv.util.map(percentArr, function(percent) {
			return self._translatePercentToY(scale, percent);
		});
	};

	cartesian._translatePercentArrToX = function(scale, percentArr) {
		var self = this;
		return dv.util.map(percentArr, function(percent) {
			return self._translatePercentToX(scale, percent);
		});
	};

	cartesian._text = function() {
		var self = this;

		function text() {
			var renderer = dv.svg.text();
			if (self._flip) {
				return renderer
					.x( function(d, i) { return self._translatePercentToY(d.panel.yOuterScale(), text.y()(d, i)); })
					.y( function(d, i) { return self._translatePercentToX(d.panel.xOuterScale(), text.x()(d, i)); });
			}
			else {
				return renderer
					.x( function(d, i) { return self._translatePercentToX(d.panel.xOuterScale(), text.x()(d, i)); })
					.y( function(d, i) { return self._translatePercentToY(d.panel.yOuterScale(), text.y()(d, i)); });
			}
		}

		text.x = function(val) {
			if (!arguments.length) return this._x;
			this._x = val;
			return this;
		};

		text.y = function(val) {
			if (!arguments.length) return this._y;
			this._y = val;
			return this;
		};

		return text;
	};

	cartesian._point = function() {
		var self = this,
			point = {};

		point.renderer = dv.svg.symbol()
			.x(function(d, i) { return d.bounds.x; })
			.y(function(d, i) { return d.bounds.y; });

		point.getBounds = function(d, i) {
			if (!d.hasOwnProperty('y')) d.y = 0;
			if (!d.hasOwnProperty('x')) d.x = 0;
			if (!point._defined(d, i)) return null;
			if (self._flip) {
				d.bounds = {
					x: self._translatePercentToY(d.panel.yOuterScale(), point.y()(d, i)),
					y: self._translatePercentToX(d.panel.xOuterScale(), point.x()(d, i))
				};
			}
			else {
				d.bounds =  {
					x: self._translatePercentToX(d.panel.xOuterScale(), point.x()(d, i)),
					y: self._translatePercentToY(d.panel.yOuterScale(), point.y()(d, i))
				};
			}
			return d;
		};

		point.getPath = function(obj) {
			return (obj === null || obj.bounds === undefined) ? null : point.renderer(obj);
		};

		point.x = function(val) {
			if (!arguments.length) return this._x;
			this._x = val;
			return point;
		};

		point.y = function(val) {
			if (!arguments.length) return this._y;
			this._y = val;
			return point;
		};

		point.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return point;
	};

	cartesian._line = function() {
		var self = this,
			line = {};

		line.renderer = d3.svg.line()
				.x(function(d, i) { return d.bounds.x; })
				.y(function(d, i) { return d.bounds.y; });

		line.getBounds = function(seriesD, seriesI) {
			var retVal = [];
			dv.util.each(seriesD, function(d, i) {
				if (!d.hasOwnProperty('y')) d.y = 0;
				if (!d.hasOwnProperty('x')) d.x = 0;
				if (line._defined(d, i)) {
					if (self._flip) {
						d.bounds = {
							x: self._translatePercentToY(d.panel.yOuterScale(), line.y()(d, i)),
							y: self._translatePercentToX(d.panel.xOuterScale(), line.x()(d, i))
						};
					} else {
						d.bounds = {
							x: self._translatePercentToX(d.panel.xOuterScale(), line.x()(d, i)),
							y: self._translatePercentToY(d.panel.yOuterScale(), line.y()(d, i))
						};
					}
					retVal.push(seriesD[i]);
				}
			});
			return retVal;
		};

		line.getPath = function(obj) {
			return (obj === null) ? null : line.renderer(obj);
		};

		line.x = function(val) {
			if (!arguments.length) return this._x;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.x must be a function", data: {val: val}});
			this._x = val;
			return this;
		};

		line.y = function(val) {
			if (!arguments.length) return this._y;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.y must be a function", data: {val: val}});
			this._y = val;
			return this;
		};

		line.defined = function(val) {
			if (!arguments.length) return this._defined;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.defined must be a function", data: {val: val}});
			this._defined = val;
			return this;
		};

		return line;
	};

	cartesian._area = function() {
		var self = this,
			area = {};

		area.renderer = d3.svg.area();

		area.getBounds = function(seriesD, seriesI) {
			var sd = [];
			area.setupRenderer();
			dv.util.each(seriesD, function(d, i) {
				if (!d.hasOwnProperty('y')) d.y = 0;
				if (!d.hasOwnProperty('x')) d.x = 0;
				if (area._defined(d, i)) {
					var newD = dv.util.clone(d);
					newD.bounds = {
						x: self._translatePercentToX(d.panel.xOuterScale(), area.x()(d, i)),
						y0: self._translatePercentToY(d.panel.yOuterScale(), area.y0()(d, i)),
						y1: self._translatePercentToY(d.panel.yOuterScale(), area.y1()(d, i))
					};
					sd.push(newD);
				}
			});
			return sd;
		};

		area.getPath = function(obj) {
			area.setupRenderer();
			return (obj === null) ? null : area.renderer(obj);
		};

		area.setupRenderer = function() {
			if (self._flip) {
				area.renderer.x(null)
					.y0(null)
					.y1(null)
					.y(function(d, i) { return d.bounds.x; })
					.x0(function(d, i) { return d.bounds.y0; })
					.x1(function(d, i) { return d.bounds.y1; });
			}
			else {
				area.renderer.y(null)
					.x0(null)
					.x1(null)
					.x(function(d, i) { return d.bounds.x; })
					.y0(function(d, i) { return d.bounds.y0; })
					.y1(function(d, i) { return d.bounds.y1; });
			}
		};

		area.x = function(val) {
			if (!arguments.length) return this._x;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, area.x must be a function", data: {val: val}});
			this._x = val;
			return this;
		};

		area.y0 = function(val) {
			if (!arguments.length) return this._y0;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, area.y0 must be a function", data: {val: val}});
			this._y0 = val;
			return this;
		};

		area.y1 = function(val) {
			if (!arguments.length) return this._y1;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, area.y1 must be a function", data: {val: val}});
			this._y1 = val;
			return this;
		};

		area.defined = function(val) {
			if (!arguments.length) return this._defined;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, area.defined must be a function", data: {val: val}});
			this._defined = val;
			return this;
		};

		return area;
	};

	cartesian._rect = function() {
		var self = this,
			rect = {};

		rect.renderer = dv.svg.rect()
			.x0(function(d, i) { return d.bounds.x0; })
			.x1(function(d, i) { return d.bounds.x1; })
			.y0(function(d, i) { return d.bounds.y0; })
			.y1(function(d, i) { return d.bounds.y1; });

		rect.getBounds = function(d, i) {
			var newD = dv.util.clone(d);
			var xVal = newD[d.panel.xScale(d).property()];
			if (dv.util.isArray(xVal)) {
				newD.x0 = xVal[0];
				newD.x1 = xVal[1];
			}
			var yVal = newD[d.panel.yScale(d).property()];
			if (dv.util.isArray(yVal)) {
				newD.y0 = yVal[0];
				newD.y1 = yVal[1];
			}
			if (!rect._defined(newD, i)) return null;
			if (self._flip) {
				newD.bounds = {
					x0: self._translatePercentToY(d.panel.yOuterScale(), rect.y0()(newD, i)),
					x1: self._translatePercentToY(d.panel.yOuterScale(), rect.y1()(newD, i)),
					y0: self._translatePercentToX(d.panel.xOuterScale(), rect.x0()(newD, i)),
					y1: self._translatePercentToX(d.panel.xOuterScale(), rect.x1()(newD, i))
				};
			} else {
				newD.bounds = {
					x0: self._translatePercentToX(d.panel.xOuterScale(), rect.x0()(newD, i)),
					x1: self._translatePercentToX(d.panel.xOuterScale(), rect.x1()(newD, i)),
					y0: self._translatePercentToY(d.panel.yOuterScale(), rect.y0()(newD, i)),
					y1: self._translatePercentToY(d.panel.yOuterScale(), rect.y1()(newD, i))
				};
			}
			return newD;
		};

		rect.getPath = function(obj) {
			return (obj === null) ? null : rect.renderer(obj);
		};

		rect.x0 = function(val) {
			if (!arguments.length) return this._x0;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.x0 must be a function", data: {val: val}});
			this._x0 = val;
			return this;
		};

		rect.x1 = function(val) {
			if (!arguments.length) return this._x1;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.x1 must be a function", data: {val: val}});
			this._x1 = val;
			return this;
		};

		rect.y0 = function(val) {
			if (!arguments.length) return this._y0;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.y0 must be a function", data: {val: val}});
			this._y0 = val;
			return this;
		};

		rect.y1 = function(val) {
			if (!arguments.length) return this._y1;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.y1 must be a function", data: {val: val}});
			this._y1 = val;
			return this;
		};

		rect.defined = function(val) {
			if (!arguments.length) return this._defined;
			if (!dv.util.isValidValue(val, ["isFunction"])) dv.log.error({msg: "Invalid value, line.defined must be a function", data: {val: val}});
			this._defined = val;
			return this;
		};

		return rect;
	};

	cartesian._errorBar = function() {
		var self = this,
			errorBar = {};

		errorBar.renderer = dv.svg.errorBar()
			.x0(function(d, i) { return d.bounds.x0; })
			.x1(function(d, i) { return d.bounds.x1; })
			.y0(function(d, i) { return d.bounds.y0; })
			.y1(function(d, i) { return d.bounds.y1; })
			.flip(function() { return self._flip; });

		errorBar.getBounds = function(d, i) {
			var newD = dv.util.clone(d);
			if (!errorBar._defined(newD, i)) return null;
			if (self._flip) {
				newD.bounds = {
					x0: self._translatePercentToY(d.panel.yOuterScale(), errorBar.y0()(newD, i)),
					x1: self._translatePercentToY(d.panel.yOuterScale(), errorBar.y1()(newD, i)),
					y0: self._translatePercentToX(d.panel.xOuterScale(), errorBar.x0()(newD, i)),
					y1: self._translatePercentToX(d.panel.xOuterScale(), errorBar.x1()(newD, i))
				};
			} else {
				newD.bounds = {
					x0: self._translatePercentToX(d.panel.xOuterScale(), errorBar.x0()(newD, i)),
					x1: self._translatePercentToX(d.panel.xOuterScale(), errorBar.x1()(newD, i)),
					y0: self._translatePercentToY(d.panel.yOuterScale(), errorBar.y0()(newD, i)),
					y1: self._translatePercentToY(d.panel.yOuterScale(), errorBar.y1()(newD, i))
				};
			}
			return newD;
		};

		errorBar.getPath = function(obj) {
			return (obj === null) ? null : errorBar.renderer(obj);
		};

		errorBar.x0 = function(val) {
			if (!arguments.length) return this._x0;
			this._x0 = val;
			return this;
		};

		errorBar.x1 = function(val) {
			if (!arguments.length) return this._x1;
			this._x1 = val;
			return this;
		};

		errorBar.y0 = function(val) {
			if (!arguments.length) return this._y0;
			this._y0 = val;
			return this;
		};

		errorBar.y1 = function(val) {
			if (!arguments.length) return this._y1;
			this._y1 = val;
			return this;
		};

		errorBar.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return errorBar;
	};

	cartesian._poly = function() {
		var self = this,
			poly = {};

		poly.renderer = dv.svg.poly()
			.xs(function(d, i) { return d.bounds.x; })
			.ys(function(d, i) { return d.bounds.y; });

		poly.getBounds = function(d, i) {
			var newD = dv.util.clone(d);
			if (poly._defined(d, i)) {
				if (self._flip) {
					newD.bounds = {
						x: self._translatePercentArrToY(d.panel.yOuterScale(), poly.ys()(d, i)),
						y: self._translatePercentArrToX(d.panel.xOuterScale(), poly.xs()(d, i))
					};
				} else {
					newD.bounds = {
						x: self._translatePercentArrToX(d.panel.xOuterScale(), poly.xs()(d, i)),
						y: self._translatePercentArrToY(d.panel.yOuterScale(), poly.ys()(d, i))
					};
				}
			}
			return newD;
		};

		poly.getPath = function(obj) {
			return (obj === null) ? null : poly.renderer(obj);
		};

		poly.xs = function(val) {
			if (!arguments.length) return this._xs;
			this._xs = val;
			return this;
		};

		poly.ys = function(val) {
			if (!arguments.length) return this._ys;
			this._ys = val;
			return this;
		};

		poly.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return poly;
	};

	return cartesian;
});
dv.coord.polar = dv.coord.extend(function() {
	function polar() {
		this._super();
		this.innerRadius = this.startY;
		this.outerRadius = this.endY;
		this.startAngle = this.startX;
		this.endAngle = this.endX;
		this.innerRadius(0);
		this.outerRadius(0);
		this.startAngle(0);
		this.endAngle(360);
		this._type = "polar";
	}

	polar._transformAngleRadiusToXY = function(angle, radius) {
		angle += -1.570796327; // -Math.PI / 2;
		return [radius * Math.cos(angle), radius * Math.sin(angle)];
	};

	polar._translatePercentToRadius = function(range, percent) {
		var radius = Math.abs(range[1] - range[0]) / 2,
			innerRadius = dv.util.getPercentValue(this.innerRadius(), radius),
			outerRadius = dv.util.getPercentValue(this.outerRadius(), radius);
		return (radius - outerRadius - innerRadius) * percent + innerRadius;
	};

	polar._translatePercentToTheta = function(scale, percent) {
		var maxAngle = 360,
			sa = dv.util.getPercentValue(this.startAngle(), maxAngle),
			ea = dv.util.getPercentValue(this.endAngle(), maxAngle),
			degrees = (ea - sa) * percent + sa;
		return degrees * 0.017453293; // Math.PI / 180
	};

	polar._translatePercentArrToRadius = function(range, percentArr) {
		var self = this;
		return dv.util.map(percentArr, function(percent) {
			return self._translatePercentToRadius(range, percent);
		});
	};

	polar._translatePercentArrToTheta = function(scale, percentArr) {
		var self = this;
		return dv.util.map(percentArr, function(percent) {
			return self._translatePercentToTheta(scale, percent);
		});
	};

	polar._getRadiusRange = function(scale1, scale2) {
		var range1 = dv.util.scaleRange(scale1),
			range2 = dv.util.scaleRange(scale2);
		return [0, Math.min(Math.abs(range1[1] - range1[0]), Math.abs(range2[1] - range2[0]))];
	};

	polar._text = function() {
		var self = this;

		function text() {
			var renderer = dv.svg.text.radial();
			if (self._flip) {
				return renderer
					.angle(function(d, i) { return self._translatePercentToTheta(d.panel.yOuterScale(), text.y()(d, i)); })
					.radius(function(d, i) { return self._translatePercentToRadius(self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale()), text.x()(d, i)); });
			}
			else {
				return renderer
					.angle(function(d, i) { return self._translatePercentToTheta(d.panel.xOuterScale(), text.x()(d, i)); })
					.radius(function(d, i) { return self._translatePercentToRadius(self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale()), text.y()(d, i)); });
			}
		}

		text.x = function(val) {
			if (!arguments.length) return this._x;
			this._x = val;
			return this;
		};

		text.y = function(val) {
			if (!arguments.length) return this._y;
			this._y = val;
			return this;
		};

		return text;
	};

	polar._point = function() {
		var self = this,
			point = {};

		point.renderer = dv.svg.symbol.radial()
			.angle(function(d, i) { return d.bounds.x; })
			.radius(function(d, i) { return d.bounds.y; });

		point.getBounds = function(d, i) {
			if (!d.hasOwnProperty('y')) d.y = 0;
			if (!d.hasOwnProperty('x')) d.x = 0;
			if (point._defined(d, i)) {
				var radiusRange = self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale());
				if (self._flip) {
					d.bounds = {
						x: self._translatePercentToTheta(d.panel.xOuterScale(), point.y()(d, i)),
						y: self._translatePercentToRadius(radiusRange, point.x()(d, i))
					};
				}
				else {
					d.bounds = {
						x: self._translatePercentToTheta(d.panel.xOuterScale(), point.x()(d, i)),
						y: self._translatePercentToRadius(radiusRange, point.y()(d, i))
					};
				}
			}
			return d;
		};

		point.getPath = function(obj) {
			return (obj === null || dv.util.isUndefined(obj.bounds)) ? null : point.renderer(obj);
		};

		point.x = function(val) {
			if (!arguments.length) return this._x;
			this._x = val;
			return this;
		};

		point.y = function(val) {
			if (!arguments.length) return this._y;
			this._y = val;
			return this;
		};

		point.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return point;
	};

	polar._line = function() {
		var self = this,
			line = {};

		line.renderer = d3.svg.line.radial()
				.angle(function(d, i) { return d.bounds.x; })
				.radius(function(d, i) { return d.bounds.y; });

		line.getBounds = function(seriesD, seriesI) {
			var retVal = [];
			dv.util.each(seriesD, function(d, i) {
				var radiusRange = self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale());
				if (!d.hasOwnProperty('y')) d.y = 0;
				if (!d.hasOwnProperty('x')) d.x = 0;
				if (line._defined(d, i)) {
					if (self._flip) {
						d.bounds = {
							x: self._translatePercentToTheta(d.panel.xOuterScale(), line.y()(d, i)),
							y: self._translatePercentToRadius(radiusRange, line.x()(d, i))
						};
					} else {
						d.bounds = {
							x: self._translatePercentToTheta(d.panel.xOuterScale(), line.x()(d, i)),
							y: self._translatePercentToRadius(radiusRange, line.y()(d, i))
						};
					}
					retVal.push(seriesD[i]);
				}
			});
			return retVal;
		};

		line.getPath = function(obj) {
			return (obj === null) ? null : line.renderer(obj);
		};

		line.x = function(val) {
			if (!arguments.length) return this._x;
			this._x = val;
			return this;
		};

		line.y = function(val) {
			if (!arguments.length) return this._y;
			this._y = val;
			return this;
		};

		line.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return line;
	};

	polar._area = function() {
		var self = this,
			area = {};

		area.renderer = d3.svg.area.radial();

		area.getBounds = function(seriesD, seriesI) {
			var sd = [];
			area.setupRenderer();
			dv.util.each(seriesD, function(d, i) {
				var radiusRange = self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale());
				if (!d.hasOwnProperty('y')) d.y = 0;
				if (!d.hasOwnProperty('x')) d.x = 0;
				if (area._defined(d, i)) {
					var newD = dv.util.clone(d);
					if (self._flip) {
						newD.bounds = {
							x: self._translatePercentToRadius(radiusRange, area.x()(d, i)),
							y0: self._translatePercentToTheta(d.panel.xOuterScale(), area.y0()(d, i)),
							y1: self._translatePercentToTheta(d.panel.xOuterScale(), area.y1()(d, i))
						};
					} else {
						newD.bounds = {
							x: self._translatePercentToTheta(d.panel.xOuterScale(), area.x()(d, i)),
							y0: self._translatePercentToRadius(radiusRange, area.y0()(d, i)),
							y1: self._translatePercentToRadius(radiusRange, area.y1()(d, i))
						};
					}
					sd.push(newD);
				}
			});
			return sd;
		};

		area.getPath = function(obj) {
			area.setupRenderer();
			return (obj === null) ? null : area.renderer(obj);
		};

		area.setupRenderer = function() {
			if (self._flip) {
				area.renderer.angle(null)
					.innerRadius(null)
					.outerRadius(null)
					.radius(function(d, i) { return d.bounds.x; })
					.startAngle(function(d, i) { return d.bounds.y0; })
					.endAngle(function(d, i) { return d.bounds.y1; });
			}
			else {
				area.renderer.radius(null)
					.startAngle(null)
					.endAngle(null)
					.angle(function(d, i) { return d.bounds.x; })
					.innerRadius(function(d, i) { return d.bounds.y0; })
					.outerRadius(function(d, i) { return d.bounds.y1; });
			}
		};

		area.x = function(val) {
			if (!arguments.length) return this._x;
			this._x = val;
			return this;
		};

		area.y0 = function(val) {
			if (!arguments.length) return this._y0;
			this._y0 = val;
			return this;
		};

		area.y1 = function(val) {
			if (!arguments.length) return this._y1;
			this._y1 = val;
			return this;
		};

		area.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return area;
	};

	polar._rect = function() {
		var self = this,
			rect = {};

		rect.renderer = d3.svg.arc()
			.startAngle(function(d, i) { return d.bounds.x0; })
			.endAngle(function(d, i) { return d.bounds.x1; })
			.innerRadius(function(d, i) { return d.bounds.y0; })
			.outerRadius(function(d, i) { return d.bounds.y1; });

		rect.getBounds = function(d, i) {
			var newD = dv.util.clone(d);
			if (!rect._defined(newD, i)) return null;

			var radiusRange = self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale());

			if (self._flip) {
				newD.bounds = {
					x0: self._translatePercentToTheta(d.panel.yOuterScale(), rect.y0()(newD, i)),
					x1: self._translatePercentToTheta(d.panel.yOuterScale(), rect.y1()(newD, i)),
					y0: self._translatePercentToRadius(radiusRange, rect.x0()(newD, i)),
					y1: self._translatePercentToRadius(radiusRange, rect.x1()(newD, i))
				};
			} else {
				newD.bounds = {
					x0: self._translatePercentToTheta(d.panel.xOuterScale(), rect.x0()(newD, i)),
					x1: self._translatePercentToTheta(d.panel.xOuterScale(), rect.x1()(newD, i)),
					y0: self._translatePercentToRadius(radiusRange, rect.y0()(newD, i)),
					y1: self._translatePercentToRadius(radiusRange, rect.y1()(newD, i))
				};
			}
			return newD;
		};

		rect.getPath = function(obj) {
			return (obj === null) ? null : rect.renderer(obj);
		};

		rect.x0 = function(val) {
			if (!arguments.length) return this._x0;
			this._x0 = val;
			return this;
		};

		rect.x1 = function(val) {
			if (!arguments.length) return this._x1;
			this._x1 = val;
			return this;
		};

		rect.y0 = function(val) {
			if (!arguments.length) return this._y0;
			this._y0 = val;
			return this;
		};

		rect.y1 = function(val) {
			if (!arguments.length) return this._y1;
			this._y1 = val;
			return this;
		};

		rect.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return rect;
	};

	polar._poly = function() {
		var self = this,
			poly = {};

		poly.renderer = dv.svg.poly.radial()
			.angles(function(d, i) { return d.bounds.x; })
			.radii(function(d, i) { return d.bounds.y; });

		poly.getBounds = function(d, i) {
			var newD = dv.util.clone(d);
			if (poly._defined(d, i)) {
				var radiusRange = self._getRadiusRange(d.panel.xOuterScale(), d.panel.yOuterScale());
				if (self._flip) {
					newD.bounds = {
						x: self._translatePercentArrToTheta(d.panel.xOuterScale(), poly.ys()(d, i)),
						y: self._translatePercentArrToRadius(radiusRange, poly.xs()(d, i))
					};
				} else {
					newD.bounds = {
						x: self._translatePercentArrToTheta(d.panel.xOuterScale(), poly.xs()(d, i)),
						y: self._translatePercentArrToRadius(radiusRange, poly.ys()(d, i))
					};
				}
			}
			return newD;
		};

		poly.getPath = function(obj) {
			return (obj === null) ? null : poly.renderer(obj);
		};

		poly.xs = function(val) {
			if (!arguments.length) return this._xs;
			this._xs = val;
			return this;
		};

		poly.ys = function(val) {
			if (!arguments.length) return this._ys;
			this._ys = val;
			return this;
		};

		poly.defined = function(val) {
			if (!arguments.length) return this._defined;
			this._defined = val;
			return this;
		};

		return poly;
	};

	return polar;
});
dv.guide = dv.extend(function() {
	function guide() {
		this._renderer = null;
	}

	guide._render = function() {
		dv.log.warn({msg: "dv.guide._render should not be called directly, try using dv.guide.legend.render or dv.guide.axis.render"});
	};

	guide._scale = function(val) {
		if (!arguments.length) return this.__scale;
		this.__scale = val;
		return this;
	};

	guide.orientation = function(val) {
		if (!arguments.length) return this._orientation;
		this._orientation = val;
		return this;
	};

	guide._parent = function(val) {
		if (!arguments.length) return this.__parent;
		this.__parent = val;
		return this;
	};

	guide.scaleIndex = function(val) {
		if (!arguments.length) return this._scaleIndex;
		this._scaleIndex = val;
		return this;
	};

	guide.title = function(val) {
		if (!arguments.length) return this._title;
		this._title = val;
		return this;
	};

	return guide;
});
dv.guide.axes = dv.extend(function() {
	function axes() {
		this._axes = {};
		this._emptyTickFormat = function() { return ""; };
	}

	/**
	 * Make sure orientation has been set and adjust that orientation based on whether coordinates are flipped.
	 */
	axes._initializeAxisRenderers = function() {
		this._eachAxis(function(prop, scaleIndex, axis) {
			// Make sure every valid axis has an orientation before we perform flip logic.
			if (!axis.hasOwnProperty("_orientation") && prop === "x") {
				axis._orientation = "bottom";
			}
			if (!axis.hasOwnProperty("_orientation") && prop === "y") {
				axis._orientation = "left";
			}

			if (this._chart._coord.flip()) {
				switch (axis._orientation) {
					case "top" : axis._orientation = "right"; break;
					case "right": axis._orientation = "top"; break;
					case "bottom": axis._orientation = "left"; break;
					case "left": axis._orientation = "bottom"; break;
				}
			}
		});
	};

	axes._measure = function(panel) {
		var parent = this._chart._g.select(".panels"),
			labelContainer = this._chart._axisLabelContainer;

		this._eachAxis(function(prop, scaleIndex, axis) {
			var scaleGroup = this._changeScaleRangeToLocal(panel.getOuterScale(prop));

			// Remove axis if "none" is specified
			if (!(this._chart._coord instanceof dv.coord.polar) && axis !== "none") {
				axis._chart(this._chart)
					._scale(scaleGroup[scaleIndex])
					._parent(parent)
					._labelParent(labelContainer);

				panel.margins(axis._measure(panel.margins(), panel.bounds(), panel));
			}
		});

		return this;
	};

	axes._getAllOrientations = function() {
		var orientations = {};
		this._eachAxis(function(prop, scaleIndex, axis) {
			orientations[axis._orientation] = prop;
		});
		return orientations;
	};

	axes._render = function(parent, labelParent, panel) {
		// Render the axes for real
		this._eachAxis(function(prop, scaleIndex, axis) {
			var scaleGroup = this._changeScaleRangeToLocal(panel.getOuterScale(prop));

			// Remove axis if "none" is specified
			if (this._chart._coord instanceof dv.coord.polar || axis === "none") {
				// TODO: Create a function called axis.remove();
				parent.selectAll(".axis-" + prop + ".axis-index-" + scaleIndex)
					.transition()
						.duration(this._chart._duration)
					.style("opacity", 0)
					.remove();

				this._chart._chartContainer.select(".axes-labels .axis-" + prop + ".axis-index-" + scaleIndex)
					.transition()
						.duration(this._chart._duration)
					.style("opacity", 0)
					.remove();
			} else {
				axis
					._chart(this._chart)
					._parent(parent)
					._scale(scaleGroup[scaleIndex])
					._labelParent(labelParent)
					._render(parent, panel, panel.bounds());
			}
		});

		return this;
	};

	axes._measureTitles = function(bounds) {
		var parent = this._chart._axisLabelContainer;
		this._eachAxis(function(prop, scaleIndex, axis) {
			if (axis !== "none") {
				var axisTitleBounds = axis
					._chart(this._chart)
					._measureAxisTitle(parent, prop, scaleIndex, bounds);

				bounds.left += axisTitleBounds.left;
				bounds.top += axisTitleBounds.top;
				bounds.right -= axisTitleBounds.right;
				bounds.bottom -= axisTitleBounds.bottom;
			}
		});

		return bounds;
	};

	axes._renderTitles = function(bounds, originsByOrientation) {
		var parent = this._chart._axisLabelContainer;
		this._eachAxis(function(prop, scaleIndex, axis) {
			if (axis === "none" || !axis.title()) {
				parent.selectAll(".axis-title-" + prop + ".axis-title-index-" + scaleIndex)
					.transition()
						.duration(this._chart._duration)
					.style("opacity", 0)
					.remove();
			} else {
				axis
					._chart(this._chart)
					._renderAxisTitle(parent, originsByOrientation, prop, scaleIndex, bounds);
			}
		});
	};

	axes._changeScaleRangeToLocal = function(outerScale) {
		var outerScaleRange = outerScale.range();
		var scaleGroup = outerScale.innerScaleGroup();
		for (var scaleIndex in scaleGroup) {
			dv.util.scaleRange(scaleGroup[scaleIndex], [outerScaleRange[0], outerScaleRange[1]]);
		}
		return scaleGroup;
	};

	axes._eachAxis = function(func) {
		for (var prop in this._axes) {
			var axisGroup = this._axes[prop];
			for (var scaleIndex in axisGroup) {
				func.call(this, prop, +scaleIndex, axisGroup[scaleIndex]);
			}
		}
	};

	axes._add = function(key, axis, scaleIndex) {
		scaleIndex = scaleIndex === undefined ? 0 : scaleIndex;
		var axes = this._axes[key];
		if (!axes) {
			this._axes[key] = axes = {};
		}
		axes[scaleIndex] = axis;
		return this;
	};

	axes._axes = function(val) {
		if (!arguments.length) return this._axes;
		this._axes = val;
		return this;
	};

	axes._get = function(key) {
		return this._axes[key];
	};

	axes._empty = function() {
		for (var prop in this._axes) {
			delete this._axes[prop];
		}
		this._axes = {};
		return this;
	};

	axes._chart = function(val) {
		if (!arguments.length) return this._chart;
		this._chart = val;
		return this;
	};

	return axes;
});
dv.guide.axis = dv.guide.extend(function() {
	function axis() {
		this._ticks = d3.functor(5);
		this._tickInterval = undefined;
		this._labelGroup = null;
		this._htmlLabels = false;
	}

	function dv_percent_tick_format(val, index) {
		return val + "%";
	}

	axis._measure = function(axisPadding, bounds, panel) {
		// 1. Determine the position of the axis
		var axisOffset = this._getAxisOffset(bounds),
			scaleRange = dv.util.scaleRange(this._scale()),
			ticks = this._ticks.call(this, Math.abs(scaleRange[1] - scaleRange[0])),
			labelGroup,
			self = this;

		// 2. Build d3 axis
		var tempParent = this._parent().append("g").classed("temp-axis", true);

		if (this._shouldDrawAxisLabels(panel)) { // should axis labels be drawn?
			labelGroup = this._constructLabelGroup(this.__labelParent, axisOffset, true);
		}
		var d3Axis = this._constructD3Axis(labelGroup, bounds, ticks, panel);

		// 3. Measure the axis for the axis title position (just place it on the temp axis)
		var axisBounds = this._measureAxis(tempParent, axisOffset, d3Axis);

		// 4. Clean up temp-axis and return measurement.
		var maxLabelBounds = {
				left: axisBounds.x + axisOffset[0],
				top: axisBounds.y + axisOffset[1],
				right: axisBounds.x + axisBounds.width + axisOffset[0],
				bottom: axisBounds.y + axisBounds.height + axisOffset[1]
			};

		if (labelGroup) {
			labelGroup.selectAll("span").each(function() {
				var e = this,
					d3Span = d3.select(this),
					labelContent = self._htmlLabels ? d3Span.html() : d3Span.text();
				// Only measure this if there is a visible label begin with.
				if (labelContent) {
					var leftOrientOffset = self._orientation === "right" ? e.offsetWidth / 2 : 0,
						topOrientOffset = self._orientation === "bottom" ? e.offsetHeight / 2 : 0,
						pos = [ e.parentNode.parentNode.offsetLeft + e.parentNode.offsetLeft + leftOrientOffset, e.parentNode.parentNode.offsetTop + e.parentNode.offsetTop + topOrientOffset ];
					maxLabelBounds.left = Math.min(pos[0], maxLabelBounds.left);
					maxLabelBounds.top = Math.min(pos[1], maxLabelBounds.top);
					maxLabelBounds.right = Math.max(pos[0] + leftOrientOffset, maxLabelBounds.right);
					maxLabelBounds.bottom = Math.max(pos[1] + topOrientOffset, maxLabelBounds.bottom);
				}
			});
		}

		tempParent.remove();

		if (labelGroup) {
			labelGroup.remove();
		}

		var newAxisPadding = {};
		newAxisPadding.left = Math.abs(Math.min(maxLabelBounds.left - bounds.left, 0));
		newAxisPadding.top = Math.abs(Math.min(maxLabelBounds.top - bounds.top, 0));
		newAxisPadding.right = Math.max(maxLabelBounds.right - bounds.right, 0);
		newAxisPadding.bottom = Math.max(maxLabelBounds.bottom - bounds.bottom, 0);

		return this._unionAxisPadding(newAxisPadding, axisPadding);
	};

	axis._render = function(parent, panel, bounds) {
		if (!this._scale()) throw new Error("The axis does not have a scale associated with it.");
		var scaleRange = dv.util.scaleRange(this._scale()),
			ticks = this._ticks.call(this, Math.abs(scaleRange[1] - scaleRange[0])),
			labelGroup;

		var axisOffset = this._getAxisOffset(bounds);
		if (this._shouldDrawAxisLabels(panel)) { // should axis labels be drawn?
			labelGroup = this._constructLabelGroup(this.__labelParent, axisOffset);
		}
		else {
			this.__labelParent.selectAll(".axis-" + this._scale().property() + ".axis-index-" + this._scale().scaleIndex()).remove();
		}
		var d3Axis = this._constructD3Axis(labelGroup, bounds, ticks, panel);
		this._renderAxis(this._parent(), panel.bounds(), axisOffset, d3Axis, labelGroup);

		return this;
	};

	axis._shouldDrawAxisLabels = function(panel) {
		var facet = panel.facet(),
			prop = this._scale().property(),
			orientation = this.orientation();
		return (facet._isFree(prop) && facet._showAllPanelLabelsIfFree()) || panel.visibleAxisLabelOrientations()[orientation];
	};

	axis._unionAxisPadding = function(newAxisPadding, axisPadding) {
		axisPadding.left = Math.max(axisPadding.left, newAxisPadding.left);
		axisPadding.top = Math.max(axisPadding.top, newAxisPadding.top);
		axisPadding.right = Math.max(axisPadding.right, newAxisPadding.right);
		axisPadding.bottom = Math.max(axisPadding.bottom, newAxisPadding.bottom);

		return axisPadding;
	};

	axis._constructLabelGroup = function(labelParent, axisOffset, isTemporary) {
		var query = ".axis-" + this._scale().property() + ".axis-index-" + this._scale().scaleIndex() + (isTemporary ? " .temp-axis" : "");
		var labelGroup = labelParent.selectAll(query).data([0]);

		labelGroup.enter().append('div')
			.classed('axis-' + this._scale().property() + " axis-index-" + this._scale().scaleIndex(), true)
			.classed('temp-axis', isTemporary)
			.style("left", axisOffset[0] + "px")
			.style("top", axisOffset[1] + "px");

		if (dv.ANIMATION) {
			labelGroup.transition()
				.delay(this._chart().delay())
				.duration(this._chart().duration())
				.ease(this._chart().ease())
				.style("left", axisOffset[0] + "px")
				.style("top", axisOffset[1] + "px");
		}
		else {
			labelGroup
				.style("left", axisOffset[0] + "px")
				.style("top", axisOffset[1] + "px");
		}

		return labelGroup;
	};

	axis._getAxisOffset = function(bounds) {
		switch (this._orientation) {
			case "bottom": return [0, bounds.bottom];
			case "left": return [bounds.left, 0];
			case "top": return [0, bounds.top];
			case "right": return [bounds.right, 0];
		}
	};

	axis._constructD3Axis = function(labelGroup, bounds, ticks, panel) {
		var defaultTickSize = this._getDefaultTickSize(bounds),
			size = dv.util.isUndefined(this._tickSize) ? defaultTickSize : this._tickSize,
			minorSize = dv.util.isUndefined(this._minorTickSize) ? defaultTickSize : this._minorTickSize,
			orient; // In D3, orient refers to how labels are aligned.

		if (this._orientation === "left") orient = "right";
		if (this._orientation === "right") orient = "left";
		if (this._orientation === "top") orient = "bottom";
		if (this._orientation === "bottom") orient = "top";

		if (this._scale().property() === "x") {
			var range = dv.util.scaleRange(this._scale());
			range[0] += this._chart().coord().startX();
			range[1] -= this._chart().coord().endX();
			if (this._scale() instanceof dv.scale.ordinal) {
				this._scale().rangeBands(range);
			} else {
				this._scale().range(range);
			}
		}

		return dv.svg.axis()
			._orient(orient)
			._labelParent(labelGroup)
			._panel(panel)
			._ticks(dv.util.isUndefined(ticks) ? 5 : ticks, this._tickInterval)
			._tickSize(size, minorSize, size)
			._defaultTickSize(defaultTickSize())
			._tickDx(dv.util.isUndefined(this._tickDx) ? this._getDefaultTickDx() : this._tickDx)
			._tickDy(dv.util.isUndefined(this._tickDy) ? this._getDefaultTickDy() : this._tickDy)
			._tickAnchor(dv.util.isUndefined(this._tickAnchor) ? this._getDefaultTickAnchor() : this._tickAnchor)
			._tickFormat(dv.util.isUndefined(this._tickFormat) && this._chart().position() === "fill" && this._scale().property() === "y" ? dv_percent_tick_format : this._tickFormat)
			._tickValues(this._tickValues)
			._htmlLabels(this._htmlLabels)
			._tickSubdivide(this._tickSubdivide)
			._scale(this._scale()._d3Scale);
	};

	axis._renderAxis = function(p, bounds, axisOffset, d3Axis, labelGroup) {
		var axis = p.selectAll('.axis-' + this._scale().property() + ".axis-index-" + this._scale().scaleIndex()).data([0]);
		d3Axis._labelParent(labelGroup);

		axis.enter().append('g')
			.classed('axis axis-' + this._scale().property() + " axis-index-" + this._scale().scaleIndex(), true)
			.attr('transform', 'translate(' + axisOffset[0] + ',' + axisOffset[1] + ')');

		if (dv.ANIMATION) {
			axis = axis.transition()
				.delay(this._chart().delay())
				.duration(this._chart().duration())
				.ease(this._chart().ease());
		}

		axis.attr('transform', 'translate(' + axisOffset[0] + ',' + axisOffset[1] + ')')
			.call(d3Axis);
	};

	// render the axis as it should be on an invisible group, then measure it and immediately remove it.
	axis._measureAxis = function(tempParent, axisOffset, d3Axis) {
		tempParent.attr('transform', 'translate(' + axisOffset[0] + ',' + axisOffset[1] + ')').call(d3Axis);
		return tempParent.node().getBBox();
	};

	axis._measureAxisTitle = function(parent, prop, scaleIndex, bounds) {
		var titleBounds = { "left": 0, "top": 0, "right": 0, "bottom": 0 };

		if (this._title) {
			var tempAxisTitleContainer = parent.append("div").classed("temp-axis-title", true),
				orientation = this._titleOrientation || this._orientation,
				titleWidth = orientation === "top" || orientation === "bottom" ? bounds.right - bounds.left : bounds.bottom - bounds.top,
				axisTitle = this._createAndSizeAxisTitle(tempAxisTitleContainer, orientation, prop, scaleIndex, titleWidth),
				axisTitleBBox = axisTitle.node().getBoundingClientRect();

			if (orientation === "top" || orientation === "bottom") {
				titleBounds[orientation] += axisTitleBBox.height;
			}
			else {
				titleBounds[orientation] += axisTitleBBox.width;
			}

			tempAxisTitleContainer.remove();
		}

		return titleBounds;
	};

	axis._renderAxisTitle = function(parent, originsByOrientation, prop, scaleIndex, bounds) {
		var titlePadding = 6,
			labelHeight = 0,
			orientation = this._titleOrientation || this._orientation,
			axisTitleAnim;

		if (!this._title) return;

		var firstRender = parent.selectAll(".axis-title-" + prop + ".axis-title-index-" + scaleIndex).empty(),
			isVerticalTitle = orientation === 'left' || orientation === 'right',
			center = isVerticalTitle ? originsByOrientation[orientation][1] - bounds.top : originsByOrientation[orientation][0] - bounds.left,
			width = center * 2,
			axisTitle = this._createAndSizeAxisTitle(parent, orientation, prop, scaleIndex, width);

		// EXIT is handled in dv.guide.axes.
		// UPDATE
		if (dv.ANIMATION) {
			axisTitleAnim = axisTitle.transition()
				.duration(this._chart().duration())
				.delay(this._chart().delay())
				.ease(this._chart().ease());
		}
		this._positionAxisTitle((firstRender || !dv.ANIMATION) ? axisTitle : axisTitleAnim, originsByOrientation[orientation], orientation);

		if (axisTitleAnim) {
			axisTitleAnim.style("opacity", 1);
		} else {
			axisTitle.style("opacity", 1);
		}
	};

	axis._createAndSizeAxisTitle = function(parent, orientation, prop, scaleIndex, width) {
		var axisTitle = parent.selectAll(".axis-title-" + prop + ".axis-title-index-" + scaleIndex)
			.data([axis]);

		// ENTER
		axisTitle.enter()
			.append("div")
				.classed("axis-title axis-title-" + prop + " axis-title-index-" + scaleIndex, true)
				.style("opacity", dv.ANIMATION ? 0 : 1);

		// Clear out old orientations and apply the actual one.
		return axisTitle
			.text(this._title)
			.style('width', (width - 10) + 'px')
			.classed({
				'top' : orientation === 'top',
				'bottom' : orientation === 'bottom',
				'left' : orientation === 'left',
				'right' : orientation === 'right'
			});
	};

	axis._positionAxisTitle = function(axisTitle, origin, orientation) {
		axisTitle
			.style("left", function() {
				var offset = 0;
				return origin[0] + offset + "px";
			})
			.style("top", function() {
				var offset = 0;
				if (orientation === "top") offset = -this.offsetHeight;
				return origin[1] + offset + "px";
			});
	};

	axis._getDefaultTickSize = function(bounds) {
		if (this._orientation === 'bottom') {
			return d3.functor(bounds.bottom - bounds.top);
		}
		else if (this._orientation === 'left') {
			return d3.functor(bounds.right - bounds.left);
		}
		else if (this._orientation === 'top') {
			return d3.functor(bounds.bottom - bounds.top);
		}
		else { // right
			return d3.functor(bounds.right - bounds.left);
		}
	};

	axis._getDefaultTickDx = function() {
		return (this._orientation === "bottom" || this._orientation === "top") ? d3.functor(0) : d3.functor(-12);
	};

	axis._getDefaultTickDy = function() {
		return (this._orientation === "bottom" || this._orientation === "top") ? d3.functor(-12) : d3.functor(0);
	};

	axis._getDefaultTickAnchor = function() {
		if (this._orientation === "left") return d3.functor("end");
		if (this._orientation === "right") return d3.functor("start");
		return d3.functor("middle");
	};

	axis._labelParent = function(val) {
		if (!arguments.length) return this.__labelParent;
		this.__labelParent = val;
		return this;
	};

	axis.ticks = function(arg1, arg2) {
		if (!arguments.length) return dv.util.isFinite(this._tickInterval) ? [this._ticks, this._tickInterval] : this._ticks;
		if (arguments.length > 1) {
			this._ticks = function() { return arg1; };
			this._tickInterval = arg2;
		}
		else {
			this._ticks = d3.functor(arg1);
			this._tickInterval = undefined;
		}
		return this;
	};

	axis.tickSubdivide = function(val) {
		if (!arguments.length) return this._tickSubdivide;
		this._tickSubdivide = val;
		return this;
	};

	axis.tickSize = function(val) {
		if (!arguments.length) return this._tickSize;
		this._tickSize = d3.functor(val);
		return this;
	};

	axis.minorTickSize = function(val) {
		if (!arguments.length) return this._minorTickSize;
		this._minorTickSize = d3.functor(val);
		return this;
	};

	axis.tickDx = function(val) {
		if (!arguments.length) return this._tickDx;
		this._tickDx = d3.functor(val);
		return this;
	};

	// Whether or not to render labels as HTML.  This allows for HTML elements to be embedded inside of a label.
	// There are some performance costs here by enabling this mode.  Do so only if absolutely necessary.
	axis.htmlLabels = function(val) {
		if (!arguments.length) return this._htmlLabels;
		this._htmlLabels = val;
		return this;
	};

	axis.tickDy = function(val) {
		if (!arguments.length) return this._tickDy;
		this._tickDy = d3.functor(val);
		return this;
	};

	axis.tickAnchor = function(val) {
		if (!arguments.length) return this._tickAnchor;
		this._tickAnchor = d3.functor(val);
		return this;
	};

	axis.tickFormat = function(val) {
		if (!arguments.length) {
			var d3Scale = this._scale()._d3Scale;
			if (this._tickFormat) return this._tickFormat;
			if (d3Scale.tickFormat) return d3Scale.tickFormat(d3Scale);
			return function(d) { return d; };
		}
		this._tickFormat = val;
		return this;
	};

	axis.tickValues = function(val) {
		if (!arguments.length) return this._tickValues;
		this._tickValues = val;
		return this;
	};

	axis.titleOrientation = function(val) {
		if (!arguments.length) return this._titleOrientation;
		this._titleOrientation = val;
		return this;
	};

	axis._chart = function(val) {
		if (!arguments.length) return this.__chart;
		this.__chart = val;
		return this;
	};

	return axis;
});

dv.svg.axis = function() {
	var scale = d3.scale.linear(),
		orient = "bottom",
		tickMajorSize = d3.functor(6),
		tickMinorSize = d3.functor(6),
		tickEndSize = d3.functor(6),
		defaultTickSize = 0,
		tickDx = d3.functor(0),
		tickDy = d3.functor(0),
		tickAnchor = d3.functor("start"),
		tickArguments_ = [10],
		tickValues = null,
		htmlLabels = false,
		tickFormat_,
		tickSubdivide = 0,
		labelParent;

	function d3_svg_axisX(selection, x) {
		selection.attr("transform", function(d) {
			var xVal = x(d);
			return dv.util.isFinite(xVal) ? 'translate(' + xVal + ',0)' : null;
		});
	}

	function d3_svg_axisY(selection, y) {
		selection.attr("transform", function(d) {
			var yVal = y(d);
			return dv.util.isFinite(yVal) ? 'translate(0,' + yVal + ')' : null;
		});
	}

	function getLeftPosition(elem, tickDx, anchor) {
		var offsetWidth = d3.select(elem).select("span").node().offsetWidth;
		var leftAdj = anchor === "end" ? -offsetWidth : anchor === "middle" ? -offsetWidth / 2 : 0;
		return tickDx + leftAdj;
	}

	function getTopPosition(elem, tickDy, anchor) {
		var offsetHeight = d3.select(elem).select("span").node().offsetHeight;
		var topAdj = anchor === "top" ? 0 : anchor === "middle" ? -offsetHeight / 2 : -offsetHeight;
		return tickDy + topAdj;
	}

	function d3_svg_axisSubdivide(scale, ticks, m) {
		var subticks = [];
		if (m && ticks.length > 1) {
			var extent = dv.util.scaleExtent(scale.domain()),
				i = -1,
				n = ticks.length,
				d = (ticks[1] - ticks[0]) / ++m,
				j,
				v;
			while (++i < n) {
				for (j = m; --j > 0;) {
					if ((v = +ticks[i] - j * d) >= extent[0]) {
						subticks.push(v);
					}
				}
			}
			for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
				subticks.push(v);
			}
		}
		return subticks;
	}

	function axis(g) {
		/**
		 * For a given label, determine and return its expected position.
		 *
		 * @param label The label DOM element
		 * @param d The datum for the label
		 * @param i The index of the label in the selection
		 * @param scale The scale to use for retrieving the position
		 * @param orient
		 * @returns { top:Number, left:Number }
		 */
		var getLabelPos = function(label, d, i, scale, orient) {
			var pos = {};

			switch (orient) {
				case 'top':
					pos.top = getTopPosition(label, -tickDy.call(label, d, i), "top");
					pos.left = scale(d) + getLeftPosition(label, tickDx.call(label, d, i), tickAnchor.call(label, d, i));
					break;
				case 'bottom':
					pos.top = getTopPosition(label, tickDy.call(label, d, i), "bottom");
					pos.left = scale(d) + getLeftPosition(label, tickDx.call(label, d, i), tickAnchor.call(label, d, i));
					break;
				case 'right':
					pos.top = scale(d) + getTopPosition(label, tickDy.call(label, d, i), "middle");
					pos.left = getLeftPosition(label, tickDx.call(label, d, i), tickAnchor.call(label, d, i));
					break;
				case 'left':
					pos.top = scale(d) + getTopPosition(label, tickDy.call(label, d, i), "middle");
					pos.left = getLeftPosition(label, -tickDx.call(label, d, i), tickAnchor.call(label, d, i));
					break;
			}

			pos.top = (isNaN(pos.top) ? 0 : pos.top) + 'px';
			pos.left = (isNaN(pos.left) ? 0 : pos.left) + 'px';

			var anchor = tickAnchor.call(label, d, i);
			d3.select(label).classed({
				'start' : anchor === 'start',
				'middle' : anchor === 'middle',
				'end' : anchor === 'end'
			});

			return pos;
		};

		/**
		 * Position a selection of labels using precalculated positions.
		 *
		 * @param labels A selection of labels.
		 * @param positions An array of position objects (with top and left attributes) indexed to match
		 * the labels selection.
		 */
		var applyLabelPositions = function(labels, positions) {
			['top', 'left'].forEach(function(side) {
				labels.style(side, function(d, i) {
					return positions[i][side];
				});
			});
		};

		/**
		 * Add/update/remove axis labels and position them.
		 *
		 * @param ticks
		 * @param oldScale
		 * @param newScale
		 */
		var updateLabels = function(ticks, oldScale, newScale) {
			if (!labelParent) return;

			var tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_,
				label, labelEnter, labelExit, labelUpdate;

			// Create/remove DOM.
			labelParent.style("position", "absolute");

			label = labelParent.selectAll(".axis-label").data(ticks, String);
			labelEnter = label.enter().append("div").classed("axis-label", true).style("opacity", 1e-6).style("position", "absolute");//.style("pointer-events", "none");
			labelExit = d3.transition(label.exit()).style("opacity", 1e-6).remove();
			labelUpdate = d3.transition(label).style("opacity", 1);

			labelEnter.append("span");

			// We have to create a flat selection instead of a nested selection (e.g., label.select('span')) so that the
			// index that comes through the tickFormat function is relative to other axis labels and not other spans
			// within the individual axis-label divs (which would result in the index always coming through as 0).
			var labelSpans = label.selectAll("span"),
				tickFormatWrapper = function(d, i, j) { return tickFormat.call(this, d, j, panel); };
			if (htmlLabels) {
				labelSpans.html(tickFormatWrapper);
			} else {
				labelSpans.text(tickFormatWrapper);
			}

			// Calculate DOM positions.
			// We calculate all positions before we apply them for optimization purposes. If we were to calculate the
			// position of an individual label, then apply the position to the label, then repeat the process
			// for all remaining labels, it would trigger a costly, large number of document layouts. We purposefully
			// refactored code away from such an approach because of the considerable speed cost observed.
			var labelEnterPositions = [],
				labelUpdateReorientPositions = [],
				labelUpdatePositions = [],
				labelExitPositions = [];

			// If scale.ticks does not exist then it is an ordinal scale. We wrap the scale to position the label
			// in the middle of the range band bucket.
			var ordinalScaleWrapper;
			if (!scale.ticks) {
				var rangeBandHalfWidth = scale.rangeBand() / 2;
				ordinalScaleWrapper = function(d) { return newScale(d) + rangeBandHalfWidth; };
			}

			labelEnter.each(function(d, i) {
				// In the case of ordinal scales, we'll use the ordinal scale wrapper which positions the
				// labels in the middle of the range band in the new scale.
				// In the case of quantitative scales, position the entering labels at the old scale. This will happen
				// immediately. The enter labels when then be tweened to the new scale with the labelUpdate
				// selection (below).

				// We need to add to the array using i instead of push() because .each() skips over null values
				// and we need to retain proper indexing for when we apply positions.
				labelEnterPositions[i] = getLabelPos(this, d, i, ordinalScaleWrapper || oldScale, orient);
			});

			labelUpdate.each(function(d, i) {
				// We need to add to the array using i instead of push() because .each() skips over null values
				// and we need to retain proper indexing for when we apply positions.
				labelUpdateReorientPositions[i] = getLabelPos(this, d, i, ordinalScaleWrapper || oldScale, orient);
				labelUpdatePositions[i] = getLabelPos(this, d, i, ordinalScaleWrapper || newScale, orient);
			});

			// If scale.ticks exists, then it is a quantitative scale so we have a location we can move exiting
			// labels. If scale.ticks does not exist, then it is an ordinal scale and there's not really an
			// appropriate location to move the exiting labels.
			if (scale.ticks) {
				labelExit.each(function(d, i) {
					// We need to add to the array using i instead of push() because .each() skips over null values
					// and we need to retain proper indexing for when we apply positions.
					labelExitPositions[i] = getLabelPos(this, d, i, newScale, orient);
				});
			}

			applyLabelPositions(labelEnter, labelEnterPositions);
			applyLabelPositions(label, labelUpdateReorientPositions);
			applyLabelPositions(labelUpdate, labelUpdatePositions);

			// If scale.ticks exists, then it is a quantitative scale so we have a location we can move exiting
			// labels. If scale.ticks does not exist, then it is an ordinal scale and there's not really an
			// appropriate location to move the exiting labels.
			if (scale.ticks) {
				applyLabelPositions(labelExit, labelExitPositions);
			}
		};

		g.each(function() {
			var g = d3.select(this);

			// Ticks, or domain values for ordinal scales.
			var ticks = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain()) : tickValues;

			// Minor ticks.
			var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),
				subtick = g.selectAll(".minor").data(subticks, String),
				subtickEnter = subtick.enter().insert("line", "g").attr("class", "tick minor").style("opacity", 1e-6),
				subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(),
				subtickUpdate = d3.transition(subtick).style("opacity", 1);

			// Major ticks.
			var tick = g.selectAll(".axis-tick").data(ticks, String),
				tickEnter = tick.enter().insert("g", "path").classed("axis-tick", true).style("opacity", 1e-6),
				tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(),
				tickUpdate = d3.transition(tick).style("opacity", 1),
				tickTransform;

			// Domain.
			var range = dv.util.scaleRangeNoReverse(scale);
				path = g.selectAll(".domain").data([0]);
				pathEnter = path.enter().append("path").attr("class", "domain");
				pathUpdate = d3.transition(path);

			// Stash a snapshot of the new scale, and retrieve the old snapshot.
			var scale1 = scale.copy(),
				scale0 = this.__chart__ || scale1;
			this.__chart__ = scale1;

			tickEnter.append("line").attr("class", "tick");

			var lineEnter = tickEnter.select("line"),
				lineUpdate = tickUpdate.select("line"),
				tickSizeFn = function(tickSize, d, i, panel) {
					var size = tickSize.call(this, d, i, panel);
					if (size == null || isNaN(size)) {
						return defaultTickSize;
					}
					return size;
				};

			switch (orient) {
				case "bottom":
					tickTransform = d3_svg_axisX;
					subtickEnter.attr("y2", function(d, i) { return tickSizeFn.call(this, tickMinorSize, d, i, panel); });
					subtickUpdate.attr("x2", 0).attr("y2", function(d, i) { return tickSizeFn.call(this, tickMinorSize, d, i, panel); });
					lineEnter.attr("y2", function(d, i) { return tickSizeFn.call(this, tickMajorSize, d, i, panel); });
					lineUpdate.attr("x2", 0).attr("y2", function(d, i) { return tickSizeFn.call(this, tickMajorSize, d, i, panel); });
					pathUpdate.attr("d", function(d, i) { return "M" + range[0] + "," + tickSizeFn.call(this, tickEndSize, d, i, panel) + "V0H" + range[1] + "V" + tickSizeFn.call(this, tickEndSize, d, i, panel); });
					break;

				case "top":
					tickTransform = d3_svg_axisX;
					subtickEnter.attr("y2", function(d, i) { return -tickSizeFn.call(this, tickMinorSize, d, i, panel); });
					subtickUpdate.attr("x2", 0).attr("y2", function(d, i) { return -tickSizeFn.call(this, tickMinorSize, d, i, panel); });
					lineEnter.attr("y2", function(d, i) { return -tickSizeFn.call(this, tickMajorSize, d, i, panel); });
					lineUpdate.attr("x2", 0).attr("y2", function(d, i) { return -tickSizeFn.call(this, tickMajorSize, d, i, panel); });
					pathUpdate.attr("d", function(d, i) { return "M" + range[0] + "," + -tickSizeFn.call(this, tickEndSize, d, i, panel) + "V0H" + range[1] + "V" + -tickSizeFn.call(this, tickEndSize, d, i, panel); });
					break;

				case "left":
					tickTransform = d3_svg_axisY;
					subtickEnter.attr("x2", function(d, i) { return -tickSizeFn.call(this, tickMinorSize, d, i, panel); });
					subtickUpdate.attr("x2", function(d, i) { return -tickSizeFn.call(this, tickMinorSize, d, i, panel); }).attr("y2", 0);
					lineEnter.attr("x2", function(d, i) { return -tickSizeFn.call(this, tickMajorSize, d, i, panel); });
					lineUpdate.attr("x2", function(d, i) { return -tickSizeFn.call(this, tickMajorSize, d, i, panel); }).attr("y2", 0);
					pathUpdate.attr("d", function(d, i) { return "M" + -tickSizeFn.call(this, tickEndSize, d, i, panel) + "," + range[0] + "H0V" + range[1] + "H" + -tickSizeFn.call(this, tickEndSize, d, i, panel); });
					break;

				case "right":
					tickTransform = d3_svg_axisY;
					subtickEnter.attr("x2", function(d, i) { return tickSizeFn.call(this, tickMinorSize, d, i, panel); });
					subtickUpdate.attr("x2", function(d, i) { return tickSizeFn.call(this, tickMinorSize, d, i, panel); }).attr("y2", 0);
					lineEnter.attr("x2", function(d, i) { return tickSizeFn.call(this, tickMajorSize, d, i, panel); });
					lineUpdate.attr("x2", function(d, i) { return tickSizeFn.call(this, tickMajorSize, d, i, panel); }).attr("y2", 0);
					pathUpdate.attr("d", function(d, i) { return "M" + tickSizeFn.call(this, tickEndSize, d, i, panel) + "," + range[0] + "H0V" + range[1] + "H" + tickSizeFn.call(this, tickEndSize, d, i, panel); });
					break;
			}

			// For quantitative scales:
			// - enter new ticks from the old scale
			// - exit old ticks to the new scale
			if (scale.ticks) {
				if (scale0.ticks) {
					tickEnter.call(tickTransform, scale0);
					subtickEnter.call(tickTransform, scale0);
				}
				tickUpdate.call(tickTransform, scale1);
				tickExit.call(tickTransform, scale1);
				subtickUpdate.call(tickTransform, scale1);
				subtickExit.call(tickTransform, scale1);
			}

			// For ordinal scales:
			// - any entering ticks are undefined in the old scale
			// - any exiting ticks are undefined in the new scale
			// Therefore, we only need to transition updating ticks.
			else {
				var dx = scale1.rangeBand() / 2, x = function(d) { return scale1(d) + dx; };
				tickEnter.call(tickTransform, x);
				tickUpdate.call(tickTransform, x);
			}

			updateLabels(ticks, scale0, scale1);
		});
	}

	axis._scale = function(x) {
		if (!arguments.length) return scale;
		scale = x;
		return axis;
	};

	axis._orient = function(x) {
		if (!arguments.length) return orient;
		orient = x;
		return axis;
	};

	axis._ticks = function() {
		if (!arguments.length) return tickArguments_;
		tickArguments_ = arguments;
		return axis;
	};

	axis._tickValues = function(x) {
		if (!arguments.length) return tickValues;
		tickValues = x;
		return axis;
	};

	axis._tickFormat = function(x) {
		if (!arguments.length) return tickFormat_;
		tickFormat_ = x;
		return axis;
	};

	axis._htmlLabels = function(val) {
		if (!arguments.length) return htmlLabels;
		htmlLabels = val;
		return axis;
	};

	axis._tickSize = function(x, y, z) {
		if (!arguments.length) return tickMajorSize;
		var n = arguments.length - 1;
		tickMajorSize = d3.functor(x);
		tickMinorSize = n > 1 ? d3.functor(y) : tickMajorSize;
		tickEndSize = n > 0 ? d3.functor(arguments[n]) : tickMajorSize;
		return axis;
	};

	axis._defaultTickSize = function(val) {
		if (!arguments.length) return defaultTickSize;
		defaultTickSize = val;
		return axis;
	};

	axis._tickDx = function(x) {
		if (!arguments.length) return tickDx;
		tickDx = x;
		return axis;
	};

	axis._tickDy = function(y) {
		if (!arguments.length) return tickDy;
		tickDy = y;
		return axis;
	};

	axis._tickAnchor = function(anchor) {
		if (!arguments.length) return tickAnchor;
		tickAnchor = anchor;
		return axis;
	};

	axis._tickSubdivide = function(x) {
		if (!arguments.length) return tickSubdivide;
		tickSubdivide = +x;
		return axis;
	};

	axis._panel = function(val) {
		if (!arguments.length) return panel;
		panel = val;
		return axis;
	};

	axis._labelParent = function(x) {
		if (!arguments.length) return labelParent;
		labelParent = x;
		return axis;
	};

	return axis;
};

dv.guide.legends = dv.extend(function() {
	function legends() {
		this._legArr = [];
		this.__hide = false;
		this._ad = {left: 0, right: 0, width: 0, height: 0};
	}

	legends._render = function(chartOps) {
		this._w = 0;
		this._h = 0;

		if (!this.__hide) {
			var	parent = chartOps.el.select('.legends'),
				self = this;

			var legends = parent.selectAll(".legend")
				.data(this._legArr);

			legends.exit()
				.transition()
					.duration(chartOps.duration)
					.style("opacity", 0)
					.remove();

			var enterG = legends.enter()
				.append('g')
					.classed("legend", true);

			if (dv.ANIMATION) {
				enterG.style("opacity", 0);
			}

			legends.each(function(d, i) {
				var scales = {},
					prop = d.props[0],
					scale = self._getScale(chartOps, d.props[0]),
					domain = scale.domain();

				for (var j = 0; j < d.props.length; j++) {
					var otherProp = d.props[j],
						otherScale = self._getScale(chartOps, d.props[j]);

					if (otherScale.hasSameDomain(domain)) {
						scales[otherProp] = chartOps.scales[otherProp];
					} else {
						throw new Error("Can't render single legend from multiple domains");
					}
				}
				d.guide._render(d3.select(this), scales, { dims: self._ad, renderOpts: chartOps } );
				self._w += d.guide._getUsedWidth();
				self._h += d.guide._getUsedHeight();
				self._ad = d.guide._getAdjustedDimensions(self._ad);
			});
		}
		return this;
	};

	legends._getScale = function(chartOpts, prop) {
		var scaleGroup = chartOpts.scales[prop],
			scale;
		if (prop === undefined || scaleGroup === undefined || scaleGroup[0] === undefined) {
			throw new Error("A '" + prop + "'' legend has been called for, but '" + prop + " hasn't been mapped to data.");
		}
		return scaleGroup[0];
	};

	legends._add = function(legend) {
		this._legArr.push(legend);
		return this;
	};

	legends._remove = function(properties) {
		for (var p in properties) {
			var prop = properties[p];
			for (var i = 0; i < this._legArr.length; i++) {
				var props = this._legArr[i].props,
					include = true;
				for (var j = 0; j < props.length; j++) {
					if (props[j] === prop) {
						props.splice(j, 1);
						j--;
					}
					if (props.length === 0) include = false;
				}
				if (!include) {
					this._legArr.splice(i, 1);
					i--;
				}
			}
		}
	};

	legends._legends = function(val) {
		if (!arguments.length) return this._legArr;
		this._legArr = val;
		return this;
	};

	legends._allowedDimensions = function(val) {
		if (!arguments.length) return this._ad;
		this._ad = val;
		return this;
	};

	legends._getWidth = function() {
		return this._w;
	};

	legends._getHeight = function() {
		return this._h;
	};

	legends._hide = function(val) {
		if (!arguments.length) return this.__hide;
		this.__hide = val;
		return this;
	};

	legends._empty = function() {
		for (var i = 0; i < this._legArr.length; i++) {
			delete this._legArr[i];
		}
		this._legArr = [];
		return this;
	};

	return legends;
});
dv.guide.legend = dv.guide.extend(function() {
	function legend() {
		this._overlay = false;
		this._orientation = "top";
		this._vGap = 5;
		this._hGap = 15;
		this._defaultPadding = this._padding = {"top": 10, "left": 10, "right": 10, "bottom": 10};
		this._swatchWidth = 15;
		this._swatchHeight = 10;
		this._innerPadding = 5;
		this._spanPercent = 0.75;
		this._lineHeight = 0;
		this._entriesWidth = [];
	}

	legend._render = function(p, scales, options) {
		var pTransition = p,
			maxDimensions = options.dims,
			self = this;

		this._renderingOptions = options.renderOpts;
		this._scales = scales;
		this._transformData = [];
		this._width = maxDimensions.width - this._padding.left - this._padding.right;
		this._height = maxDimensions.height - this._padding.top - this._padding.bottom;

		var entries = this._drawEntries(p);

		this._legendWidths = calc_legends_widths.call(this, entries);
		var colMeta = calc_columns.call(this, Math.min(this._legendWidths.length, Math.floor(this._width / this._swatchWidth)));
		var retVal = calc_offsets.call(this, colMeta);
		var offsets = retVal.offsets;
		colMeta = retVal.cols;

		this._width = this._width - colMeta.padding + (this._hGap * (colMeta.data.length - 1));
		this._height = this._lineHeight + offsets[offsets.length - 1].y;

		entries.each(function(d, i) {
			var el = d3.select(this);
			if (dv.ANIMATION) {
				el = el.transition()
					.duration(self._renderingOptions.duration)
					.delay(self._renderingOptions.delay)
					.ease(self._renderingOptions.ease);
			}
			el.attr("transform", "translate(" + offsets[i].x + ", " + offsets[i].y + ")");
		});

		if (!this._renderingOptions.firstRender) {
			pTransition = p.transition()
				.duration(this._renderingOptions.duration)
				.style("opacity", 1);
		}

		var left = (this._orientation === "right") ? maxDimensions.left + maxDimensions.width - this._width - this._padding.right: maxDimensions.left + this._padding.left;
		var top = (this._orientation === "bottom") ? maxDimensions.top + maxDimensions.height - this._height - this._padding.bottom: maxDimensions.top + this._padding.top;

		pTransition.attr('transform', 'translate(' + (left) + ',' + (top) + ')');

		if (this._renderingOptions.firstRender) {
			pTransition.transition()
				.duration(this._renderingOptions.duration)
				.style("opacity", 1);
		}
	};

	legend._drawEntries = function(p) {
		var self = this,
			domain = [];

		this._entryWidths = [];


		// since all these domains are the same we just need to grab the first one
		for (var prop in this._scales) {
			domain = this._scales[prop][0].domain();
			break;
		}

		var entries = p.selectAll(".legend-entry")
			.data(domain);

		entries.exit()
			.transition()
				.duration(this._renderingOptions.duration)
				.style("opacity", 0)
				.remove();

		var entry = entries.enter()
			.append('g')
			.classed('legend-entry', true);

		entry.append('path');
		entry.append('text')
			.classed('legend-entry-label', true);
		entry.append('text')
			.classed('legend-entry-value', true);

		entries.select("path")
			.attr("d", function(d, i) { return get_path.call(self, d, i); })
			.call(function(selection) {
				selection.attr("style", "");
				if (self._scales.hasOwnProperty("fill"))
					selection.style("fill", function(d, i) { return self._scales["fill"][0].mapValue(d); });
				if (self._scales.hasOwnProperty("stroke"))
					selection.style("stroke", function(d, i) { return self._scales["stroke"][0].mapValue(d); })
						.style("stroke-width", 2);
				if (self._scales.hasOwnProperty("linetype")) {
					selection.style('stroke-dasharray', function(d, i) { return dv.util.svg.getDasharray(self._scales["linetype"][0].mapValue(d)); });
					if (!self._scales.hasOwnProperty("stroke")) selection.style("stroke", "#000");
					selection.style("stroke-width", 2);
				}
				if (self._scales.hasOwnProperty("size")) {
					selection.style("stroke-width", function(d, i) {
						return self._scales["size"][0].mapValue(d);
					});
				}
			})
			.each(function(d, i) {
				self._entryWidths[i] = this.getBBox().width;
			});

		entries.select("text.legend-entry-label")
			.attr("x", this._swatchWidth + this._innerPadding)
			.attr("y", 10)
			.text(function(d, i) {
				if (dv.util.isUndefined(self._labels)) return d;
				else return self._labels[i % self._labels.length];
			})
			.each(function(d, i) {
				self._entryWidths[i] += self._innerPadding + this.getBBox().width;
			});

		entries.select("text.legend-entry-value")
			.attr("y", 10)
			.attr("x", function(d, i) {
				return self._entryWidths[i] + self._innerPadding;
			})
			.text(function(d, i) {
				if (dv.util.isUndefined(self._values)) return "";
				else return self._values[i];
			})
			.style("fill", function(d, i) {
				if (!dv.util.isUndefined(self._scales["stroke"])) return self._scales["stroke"][0].mapValue(d);
				else if (!dv.util.isUndefined(self._scales["fill"])) return self._scales["fill"][0].mapValue(d);
				return;
			})
			.each(function(d, i) {
				var width = this.getBBox().width;
				self._entryWidths[i] += width + ((width > 0) ? self._innerPadding : 0); // Don't add extra padding if there is no value.
			});

		return entries;
	};

	function calc_legends_widths(entries) {
		var self = this;

		entries.each(function(d, i) {
			self._entryWidths[i] = Math.min(self._entryWidths[i], self._width);
			self._lineHeight = Math.max(self._lineHeight, this.getBBox().height);
		});

		return self._entryWidths;
	}

	function calc_offsets(cols) {
		var cursor = 0,
			colIndex = 0,
			d,
			spanned = 0,
			hasMaxCols = false,
			rowOffset = 0,
			colOffset = 0,
			offsets = [];

		for (var i = 0; i < this._legendWidths.length; i++) {
			cursor += ((colIndex === 0) ? 0 : this._hGap) + this._legendWidths[i];
			if (colIndex < cols.data.length && cursor <= this._width) {
				if (this._legendWidths[i] <= cols.data[colIndex] + spanned) {
					colOffset += ((colIndex === 0) ? 0 : this._hGap);
					offsets.push({ x: colOffset, y: rowOffset });
					colOffset += cols.data[colIndex] + spanned;
					spanned = 0;
				} else if ((d = this._legendWidths[i] - cols.data[colIndex]) <= cols.padding) {
					cols.padding -= d;
					cols.data[colIndex] = this._legendWidths[i];
					return calc_offsets.call(this, cols);
				} else if ((colIndex + 1 < cols.data.length) && this._legendWidths[i] >= cols.data[colIndex] + (cols.data[colIndex+1] * this._spanPercent) + spanned) {
					if (colIndex + 1 <= cols.data.length) {
						spanned += ((colIndex === 0) ? 0 : this._hGap) + cols.data[colIndex];
						cursor -= ((colIndex === 0) ? 0 : this._hGap) + this._legendWidths[i];
						i--;
					} else {
						cursor = cursor - this._legendWidths[i] + spanned + cols.data[colIndex];
						spanned = 0;
						colOffset += ((colIndex === 0) ? 0 : this._hGap);
						offsets.push({ x: colOffset, y: rowOffset });
						colOffset += cols.data[colIndex] + spanned;
						colIndex++;
					}
				} else {
					cols = calc_columns.call(this, cols.data.length - 1);
					return calc_offsets.call(this, cols);
				}
				colIndex++;
			} else if (colIndex + 1 === cols.data.length && cols.data.length > 1) {
				cols = calc_columns.call(this, cols.data.length - 1);
				return calc_offsets.call(this, cols);
			} else {
				if (colIndex === cols.data.length) hasMaxCols = true;
				rowOffset += this._lineHeight + this._vGap;
				cursor = colOffset = 0;
				colIndex = 0;
				spanned = 0;
				i--;
			}
		}
		if (colIndex === cols.data.length) hasMaxCols = true;

		if (!hasMaxCols) {
			cols = calc_columns.call(this, cols.data.length - 1);
			return calc_offsets.call(this, cols);
		}

		return {offsets: offsets, cols: cols};
	}

	// Recursively calculates the number of columns needed based on the first "n" legend widths where numCols defines "n"
	function calc_columns(numCols) {
		var colMeta = { data: [], padding: this._width },
			sum = 0,
			i = 0;

		if (this._isVAligned()) {
			numCols = Math.ceil(this._legendWidths.length / Math.floor(this._height / (this._lineHeight + this._vGap)));
		}
		for (i = 0; i < numCols; i++) {
			sum += this._legendWidths[i] + this._hGap;
		}
		sum -= this._hGap;
		if (sum > this._width && numCols > 1) return calc_columns.call(this, numCols-1);

		colMeta.data = this._legendWidths.slice(0, numCols);
		colMeta.padding -= sum;
		if (colMeta.padding < 0) colMeta.padding = 0;

		return colMeta;
	}

	function draw_rect(x, y, w, h) {
		return "M" + x + "," + y +
			"L" + (x + w) + "," + y +
			"L" + (x + w) + "," + (y + h) +
			"L" + x + "," + (y + h) + "Z";
	}

	function draw_line(x0, y0, x1, y1) {
		var midPoint = ((y0 + y1) >> 1);
		return "M" + x0 + "," + midPoint +
			"L" + x1 + "," + midPoint;
	}

	function get_path(d, i) {
		if (this._scales.hasOwnProperty("fill"))
			return draw_rect.call(this, 0, 0, this._swatchWidth, this._swatchHeight);
		else
			return draw_line.call(this, 0, 0, this._swatchWidth, this._swatchHeight);
	}

	legend._getAdjustedDimensions = function(maxDims) {
		if (this._overlay) return maxDims;

		var totalWidth = this._padding.left + this._width + this._padding.right,
			totalHeight = this._padding.top + this._height + this._padding.bottom;

		if (this._orientation === "left") {
			maxDims.left += totalWidth;
			maxDims.width -= totalWidth;
		}
		else if (this._orientation === "top") {
			maxDims.top += totalHeight;
			maxDims.height -= totalHeight;
		}
		else if (this._orientation === "right") maxDims.width -= totalWidth;
		else if (this._orientation === "bottom") maxDims.height -= totalHeight;

		return maxDims;
	};

	legend._getUsedWidth = function() {
		if (this._overlay) return 0;
		else return (this._isVAligned() ? this._width + this._padding.left + this._padding.right: 0);
	};

	legend._getUsedHeight = function() {
		if (this._overlay) return 0;
		else return (this._isVAligned() ? 0 : this._height + this._padding.top + this._padding.bottom);
	};

	legend._isVAligned = function() {
		return (this._orientation === "left" || this._orientation === "right");
	};

	legend.vGap = function(val) {
		if (!arguments.length) return this._vGap;
		this._vGap = val;
		return this;
	};

	legend.hGap = function(val) {
		if (!arguments.length) return this._hGap;
		this._hGap = val;
		return this;
	};

	legend.padding = function(val) {
		if (!arguments.length) return this._padding;
		this._padding = dv.util.merge(this._defaultPadding, val);
		return this;
	};

	legend.align = function(val) {
		if (!arguments.length) return this._align;
		this._align = val;
		return this;
	};

	legend.labels = function(val) {
		if (!arguments.length) return this._labels;
		this._labels = val;
		return this;
	};

	legend.values = function(val) {
		if (!arguments.length) return this._values;
		this._values = val;
		return this;
	};

	legend.overlay = function(val) {
		if (!arguments.length) return this._overlay;
		this._overlay = val;
		return this;
	};

	return legend;
});
dv.guide.custom = dv.guide.extend(function() {
	function custom(config) {
		this._render = function() { dv.log.warn({msg: "empty render function on custom guide"}); return this; };
		this._getAdjustedDimensions = function(maxDims) { return maxDims; };
		this._getUsedWidth = function() { return 0; };
		this._getUsedHeight = function() { return 0; };
	}

	// Allows overwriting of functions
	custom.setFunc = function(funcName, func) {
		this[funcName] = func;
		return this;
	};

	return custom;
});
dv.geom = dv.container.extend(function() {

	function geom() {
		this._super();
		this._defaultAes = {};
		this._behaviorsLayer = null;
		this._dodgePadding = 0;

		this._initializeDefaultAes();
	}

	// These are the default attributes for all geometries
	geom._initializeDefaultAes = function() {
		this._defaultAes['x'] = 1;
		this._defaultAes['y'] = 1;
		this._defaultAes['shape'] = 'circle';
		this._defaultAes['linetype'] = 'solid';
	};

	//
	geom._prerender = function(chart) {
		this._trainedScales = {};
		// Assign the chart for this geom.
		this._chart = chart;
		// Rename the columns to be understandable to this geom and other objects
		// Before this is done, unnormalized data may have any labels assigned
		this.normalizedData(this._normalizeData(this.data()));
		this._calculateStats();
		this._inheritChartAesthetics(chart);
	};

	geom._inheritChartAesthetics = function(chart) {
		for(var prop in chart._aes) {
			// We'll inherit any aesthetics on the chart that aren't defined explicitly on the geom.
			var chartAesGroup = chart._aes[prop];
			if (!this._aes[prop]) this._aes[prop] = {};
			for (var scaleIndex in chartAesGroup) {
				if (!this._aes[prop][scaleIndex]) {
					this._aes[prop][scaleIndex] = chartAesGroup[scaleIndex];
				}
			}
		}
	};

	geom._trainScales = function() { /* Override in subclasses if needed */ };

	geom._createDefaultScales = function() {
		for (var prop in this._defaultAes) {
			if (!this._aes.hasOwnProperty(prop)) {
				this._aes[prop] = {};
				this._aes[prop][0] = dv.scale.constant().value(this._defaultAes[prop]).property(prop);
			}
			delete this._defaultAes[prop];
		}
	};

	geom._render = function(geomGroup) {
		var self = this;
		this._geomGroup = d3.select(geomGroup);

		var seriesGroups = this._geomGroup
			.selectAll('.series')
			.data(this._nestData);

		seriesGroups.exit()
			.call(self.exitSeriesGroup, self);

		seriesGroups.enter()
			.append('g')
			.classed('series', true);

		seriesGroups.call(self.updateGroups, self.enterPen, self.pen, self.enterPen, self)
			.call(self.updateDataPoints, self.enterPen, self.pen, self.enterPen, self);

		self._renderBehaviors(self._geomGroup);

		// Clean up our geom events.  They should have all been removed by now.
		self.unregisterEventMap = null;
	};

	geom._renderBehaviors = function(geomGroup) {
		var self = this;
		if (this._behaviors && this._behaviors.length) {
			this._behaviorsLayer = geomGroup.select('.behavior-layer');

			if (this._behaviorsLayer.empty()) {
				this._behaviorsLayer = geomGroup.append('g')
					.classed("behavior-layer", true);
			} else {
				this._behaviorsLayer.node().parentNode.appendChild(this._behaviorsLayer.node());
			}

			dv.util.each(this._behaviors, function(behavior) {
				behavior._geom(self)._render(self._behaviorsLayer);
			});
		}
	};

	geom.updateGroups = function(seriesGroups, enterPen, pen, exitPen, self) {
		seriesGroups.each(function(d, i) {
			var x = 0,
				y = 0,
				selection = d3.select(this),
				previousTransform = selection.attr("transform");

			if (self._chart._coord instanceof dv.coord.polar) {
				var firstDataPoint = d.values[0],
					xRange = dv.util.scaleRange(firstDataPoint.panel.xOuterScale()),
					yRange = dv.util.scaleRange(firstDataPoint.panel.yOuterScale()),
					xVal = (xRange[0] + xRange[1]) / 2,
					yVal = (yRange[0] + yRange[1]) / 2,
					flipped = self._chart._coord.flip();

				x = flipped ? yVal : xVal;
				y = flipped ? xVal : yVal;
			}

			if (previousTransform && dv.ANIMATION) {
				selection = selection.transition()
					.duration(function(d, i) { return self.duration().call(this, d, i); });
			}

			selection.attr("transform", 'translate(' + x + ',' + y + ')');
		});
	};

	geom.updateDataPoints = function(seriesGroups, enterPen, pen, exitPen, self) {
		var _enterPen = enterPen.call(self),
			_updatePen = pen.call(self),
			_exitPen = exitPen.call(self);

		var nodes = seriesGroups.selectAll('.' + self._dataPointStyleClass)
			.data(function(d) { return self.getValues(d); });

		nodes.exit()
			//.attr('d', _updatePen)
			.transition()
				.delay(function(d, i, j) { return self.delay().call(this, d, i, j); })
				.duration(function(d, i, j) { return self.duration().call(this, d, i, j); })
				.ease(self.ease())
				.each(function() { this.__exiting__ = true; })
				//.style('opacity', 1e-6)
				.attrTween('d', _exitPen.pathTween)
				.remove();

		nodes.enter()
			.append('path') // TODO: This base class shouldn't contain a reference to svg:path.  That should be broken out to another object and used via composition.
				.each(function(d, i, j) { self.setPreviousState.call(this, _enterPen, _exitPen, d, i, j); })
				.attr("class", function(d, i, j) { return "datum-" + i + " series-" + j; })
				.call(self.attributes, self)
				//.style('opacity', 1e-6)
				.attr('d', _enterPen.path);

		var updateTransition = nodes.call(self.attributes, self)
			.call(self._removeRegisteredEvents, self)
			.call(self._addRegisteredEvents, self)
			.each(function() { this.__exiting__ = false; });

		if (dv.ANIMATION) {
			updateTransition = updateTransition.transition()
				.delay(function(d, i, j) { return self.delay().call(this, d, i, j); })
				.duration(function(d, i, j) { return self.duration().call(this, d, i, j); })
				.ease(self.ease())
				.attrTween('d', _updatePen.pathTween);
		} else {
			updateTransition
				.each(function(d, i, j) {
					var bounds = _updatePen.bounds(d, i, j);
					if (bounds) {
						d.bounds = bounds.bounds;
					}
				})
				.attr('d', _updatePen.path);
		}

		updateTransition
			.call(self.addEachFunction, self);
	};

	geom.addEachFunction = function(selection, self) {
		if (self._each) {
			if (!dv.util.isUndefined(self._each["start"])) {
				if (dv.ANIMATION) {
					selection.each("start", function(d, i, j) {
						self._each["start"].call(this, d, i, j);
					});
				} else {
					selection.each(function(d, i, j) {
						self._each["start"].call(this, d, i, j);
					});
				}
			}

			if (!dv.util.isUndefined(self._each["end"])) {
				if (dv.ANIMATION) {
					selection.each("end", function(d, i, j) {
						self._each["end"].call(this, d, i, j);
					});
				} else {
					selection.each(function(d, i, j) {
						self._each["end"].call(this, d, i, j);
					});
				}
			}
		}
	};

	geom.exitSeriesGroup = function(geomGroup, self) {
		self.exitSeries(geomGroup, self.enterPen, self);
	};

	geom.setPreviousState = function(enterPen, exitPen, d, i) {
		var bounds = enterPen.bounds(d, i);
		this.__previousBounds__ = bounds;
		this.__exitTransition__ = exitPen;
	};

	geom.pathTween = function(pathRenderer, selection, d, i, j) {
		var path,
			e = d3.select(selection);

		if (selection.__exiting__) {
			path = selection.__exitTransition__.path(d, i);
			selection.__exiting__ = false;
		}
		else {
			path = pathRenderer.getPath(pathRenderer.getBounds(d, i));
		}

		if (path === null) {
			e.remove();
			return null;
		}
		return d3.interpolate(e.attr("d"), path);
	};

	geom._calculateStats = function() {
	};

	/**
	 * Compute stack/fill position adjustments relative to the facet the data points
	 * belong in rather than the scope of the entire chart (all of the facets).
	 */
	geom._handlePositions = function() {
		if (this.position() !== 'stack' && this.position() !== 'fill' && this.position() !== 'dodge') return;

		var position = this.position(),
			layeredNestData = this._addGroupLayerToNestedData(),
			isFlipped = this._chart.coord().flip(),
			includeInDomain = function(prop) {
				var scaleGroup = self.getExplicitScales(prop)[prop],
					include = false;
				return function(d, i) {
					for (var scaleIndex in scaleGroup) {
						include = scaleGroup[scaleIndex]._includeInDomain(d, i);
						if (include) break;
					}
					return include ? d[prop] : 0;
				};
			},
			self = this;

		dv.util.each(layeredNestData, function(nestedFacetData) {
			var xIncludeInDomain = includeInDomain('x'),
				yIncludeInDomain = includeInDomain('y');

			if (position === 'stack') {
				d3.layout.stack()
					.x(xIncludeInDomain)
					.y(yIncludeInDomain)
					.values(function(d) { return d.values; })
					(nestedFacetData.values);
			}
			else if (position === 'fill') {
				d3.layout.stack()
					.x(xIncludeInDomain)
					.y(yIncludeInDomain)
					.offset(function(data) {
						var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
						for (j = 0; j < m; ++j) {
							for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
							if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
							else for (i = 0; i < n; i++) data[i][j][1] = 0;
						}
						for (j = 0; j < m; ++j) y0[j] = 0;
						return y0;
					})
					.values(function(d) { return d.values; })
					(nestedFacetData.values);
			}
			else if (position === 'dodge') {
				// Give each zipData point a group index so we know how much width to allocate them when we draw.
				var numGroups = nestedFacetData.values.length;
				dv.util.each(nestedFacetData.values, function(nestedGroupData, i) {
					dv.util.each(nestedGroupData.values, function(pointData) {
						// If the series is flipped and we're dodged, render the first series on top instead of bottom.
						pointData.dodge = {
							groupIndex: i,
							numGroups: numGroups
						};
					});
				});
			}
		});
	};

	/**
	 * Converts from our facet-group combo data structure in _nestData:
	 * [
	 *   {
	 *     key: facetId ~ groupId,
	 *     values: [
	 *       {...},
	 *       {...},
	 *       ...
	 *     ]
	 *   },
	 *   ...
	 * ]
	 *
	 * to a completely nested structure for computing stack/fill positions:
	 * [
	 *   {
	 *     key: facetId,
	 *     values: [
	 *       {
	 *         key: groupId,
	 *         values: [
	 *           {...},
	 *           {...},
	 *           ...
	 *         ]
	 *       },
	 *       ...
	 *     ]
	 *   },
	 *   ...
	 * ]
	 */
	geom._addGroupLayerToNestedData = function() {
		var nestedGroups = [],
			facetIdToIndex = {},
			groupIdToIndex = {};


		dv.util.each(this._nestData, function(d, i) {
			var facetId = /(.*) ~ .*/g.exec(d.key)[1],
				groupId = /.* ~ (.*)/g.exec(d.key)[1],
				facet, group;

			if (!facetIdToIndex.hasOwnProperty(facetId)) {
				nestedGroups.push({ key: facetId, values: [] });
				facetIdToIndex[facetId] = nestedGroups.length - 1;
			}
			facet = nestedGroups[facetIdToIndex[facetId]];

			if (!groupIdToIndex.hasOwnProperty(d.key)) {
				facet.values.push({ key: groupId, values: [] });
				groupIdToIndex[d.key] = facet.values.length - 1;
			}
			group = facet.values[groupIdToIndex[d.key]];
			group.values = group.values.concat(d.values);
		});

		return nestedGroups;
	};

	geom.exit = function(geomGroup) {
		d3.select(geomGroup)
			.selectAll('.series')
				.call(this.exitSeriesGroup, this);
	};

	geom.exitSeries = function(seriesGroups, exitPen, self) {
		seriesGroups.selectAll('.' + self._dataPointStyleClass)
			.transition()
				.delay(function(d, i, j) { return self.delay().call(this, d, i, j); })
				.duration(function(d, i, j) { return self.duration().call(this, d, i, j); })
				.ease(self.ease())
				.each(function() { this.__exiting__ = true; })
				.attrTween('d', exitPen.call(self).pathTween)
				.remove()
				.each("end", function(d, i) {
					var seriesGroupNode = this.parentNode;
					if (seriesGroupNode && seriesGroupNode.childNodes && !seriesGroupNode.childNodes.length) {
						// Is the geom container empty now too?
						var geomNode = seriesGroupNode.parentNode;
						if (geomNode && geomNode.childNodes && geomNode.childNodes.length <= 1) {
							d3.select(geomNode).remove();
						} else {
							d3.select(seriesGroupNode).remove();
						}
					}
				});
	};

	geom.coord = function() {
		return this.chart().coord();
	};

	geom._addRegisteredEvents = function(nodes, self) {
		if (!self) self = this;
		if (!self._geomGroup) return;

		nodes = (!nodes ? self._geomGroup.selectAll('.series').selectAll('.' + this._dataPointStyleClass) : nodes);
		self = self || this;
		dv.util.each(self.eventMap, function(e, type) {
			nodes.on(type, function(d, i, j) { // intercept the event and add our own parameters...
					self.eventMap[type].callback.call(this, d, i, j, d3.event);
				}, e.capture);
		});
		dv.util.each(self._chart.eventMap, function(e, type) {
			nodes.on(type + ".dvchart", function(d, i) {
					var e = d3.event,
						interactionGroup = self._chart._interactionGroup.select(".interaction-canvas").node();

					if (self._shouldDispatchChartEvent(e, interactionGroup)) {
						self._chart.eventMap[type].callback.call(interactionGroup, e);
					}
				}, e.capture);
		});

		// Forward this event on to the behaviors
		dv.util.each(self._behaviors, function(behavior) {
			if (behavior._addRegisteredEvents) behavior._addRegisteredEvents();
		});
	};

	geom._removeRegisteredEvents = function(nodes, self) {
		if (!self) self = this;
		if (!self._geomGroup) return;

		nodes = nodes || self._geomGroup.selectAll('.' + this._dataPointStyleClass);
		self = self || this;
		dv.util.each(self.unregisterEventMap, function(capture, type) {
			nodes.on(type, null, capture);
		});
		dv.util.each(self._chart.unregisterEventMap, function(capture, type) {
			nodes.on(type + ".dvchart", null, capture);
		});

		// Forward this event on to the behaviors
		dv.util.each(self._behaviors, function(behavior) {
			if (behavior._removeRegisteredEvents) behavior._removeRegisteredEvents();
		});
	};

	geom._shouldDispatchChartEvent = function(e, interactionGroup) {
		var result = true;

		// Our chart shouldn't dispatch mouse out/over events when rolling over geoms contained within the plot.
		if (e.type === "mouseout" || e.type === "mouseover") {
			var rTarg = e.relatedTarget;
			if (!rTarg)
				rTarg = (e.type === "mouseout") ? e.toElement : e.fromElement;

			var relTarget = d3.select(rTarg);
			if (relTarget && !relTarget.empty()) {
				var className = relTarget.attr('class');
				result = !((relTarget.node() === interactionGroup) || (className && className.indexOf('-geom') >= 0));
			}
		}
		return result;
	};

	/**
	 * Returns all scales which have been explicitly mapped by both geom and chart (geom overrides chart).
	 */
	geom.getExplicitScalesMap = function() {
		// Clone the chart aes so we can alter it without destroying the original.
		var chartScalesMap = dv.util.clone(this._chart.getExplicitScalesMap());
		for (var prop in this._aes) {
			var geomAesGroup = this._aes[prop],
				chartAesGroup = chartScalesMap[prop] || {},
				combinedAesGroup = dv.util.extend({}, chartAesGroup, geomAesGroup);
			chartScalesMap[prop] = combinedAesGroup;
		}
		return chartScalesMap;
	};

	/**
	 * Returns a scale by looking at the aesthetics defined on the geom (preferrably) or on the chart if it's
	 * not defined on the geom.
	 */
	geom.getExplicitScale = function(property, scaleIndex) {
		if (property === 'group') return this._getGroup();

		// If we can find a scaleIndex on the geom aes, get that first, otherwise check to see if the scaleIndex
		// exists on the chart aes.
		var geomAesGroup = this._aes[property];
		var chartAesGroup = this.chart()._aes[property];
		if (scaleIndex !== undefined && geomAesGroup && geomAesGroup[scaleIndex]) return geomAesGroup[scaleIndex];
		if (scaleIndex !== undefined && chartAesGroup && chartAesGroup[scaleIndex]) return chartAesGroup[scaleIndex];
		// As a last resort just use zero for scaleIndex.
		if (geomAesGroup && geomAesGroup[0] !== undefined) return geomAesGroup[0];
		if (chartAesGroup && chartAesGroup[0] !== undefined) return chartAesGroup[0];
		return null;
	};

	/**
	 * Returns a map of all aesthetics by merging any defined on the geom as well as the chart.  Geom
	 * aesthetics take precidence.
	 */
	geom.getExplicitScales = function(property) {
		if (!dv.util.isArray(property)) property = [property];
		var explicitScales = {},
			i = -1,
			n = property.length;
		while (++i < n) {
			var prop = property[i],
				geomAesGroup = this._aes[prop],
				chartAesGroup = this.chart()._aes[prop] || {};
			explicitScales[prop] = dv.util.extend({}, chartAesGroup, geomAesGroup);
		}
		return explicitScales;
	};

	// Checks for a scale on the geom, if one isn't found, we look on the chart and eventually use
	// a default if no scale was explicitly set by the dev.
	geom.getTrainedScale = function(prop, scaleIndex) {
		return this.chart().getTrainedScale(prop, scaleIndex);
	};

	geom.getScale = function(property, scaleIndex) {
		return this.getExplicitScale(property, scaleIndex);
	};

	geom.getScales = function(property) {
		return this.getExplicitScales(property);
	};

	geom.hasScale = function(property, scaleIndex) {
		if (this.getExplicitScale(property, scaleIndex)) {
			return true;
		}
		return false;
	};

	geom._dodgeAdjust = function(d) {
		var seriesIndex = d.dodge.groupIndex,
			numSeries = d.dodge.numGroups,
			rangeBand = d.panel.xScale(d).rangeBand(),
			slicePadding = (numSeries > 1) ? rangeBand / (numSeries - 1) * this._dodgePadding : 0,
			barWidth = (rangeBand - (slicePadding * (numSeries - 1))) / numSeries;
		return (barWidth + slicePadding) * seriesIndex + (barWidth / 2);
	};

	geom.applyAttributeValue = function(selection, self, styleAttr, prop) {
		var scale = self.getScale(prop, 0);
		selection.style(styleAttr, function(d, i, j) {
			return scale ? scale.mapToProp(dv.util.isArray(d) ? d[0] : d, i, j) : null;
		});
	};

	geom._getGroup = function() {
		// If a group has been explicitly defined, we're done.
		if (this._aes.hasOwnProperty('group')) return this._aes.group[0];
		// Does chart has an explicit group?  If so let's use it.
		var chartGroup = this.chart()._getGroup();
		if (chartGroup && chartGroup.property() === 'group') return chartGroup;

		// Otherwise, let's look for a categorical aesthetic which can serve as a grouping element
		// on the geom.
		var i = -1,
			len = dv.DEFAULT_CATEGORICAL_AES.length - 1;
		while (i++ < len) {
			var catAesGroup = this._aes[dv.DEFAULT_CATEGORICAL_AES[i]];
			// If the scale has a mapping (not a dv.scale.constant scale), we'll use it.
			if (catAesGroup &&
					catAesGroup[0] &&
					catAesGroup[0] instanceof dv.scale.ordinal &&
					!dv.util.isUndefined(catAesGroup[0].mapping())) {
				return catAesGroup[0];
			}
		}

		// If no categorical aesthetic has been explicitly defined on the aes, we'll just use the
		// categorical aesthetic returned from the chart (which may be null).
		return chartGroup;
	};

	geom.each = function(arg1, arg2) {
		var timing, f;
		if (!arguments.length) return this._each;
		this._each = this._each || {};
		if (arguments.length < 2) {
			f = arg1;
			timing = "end";
		}
		else {
			f = arg2;
			timing = arg1;
		}
		this._each[timing] = f;
		return this;
	};

	geom.dodgePadding = function(val) {
		if (!arguments) return this._dodgePadding;
		this._dodgePadding = val;
		return this;
	};

	geom.behaviors = function(val) {
		if (!arguments.length) return this._behaviors;
		this._behaviors = val;
		return this;
	};

	geom.stat = function(val) { // TODO: Use me!
		if (!arguments.length) return this._stat;
		this._stat = val;
		return this;
	};

	geom.chart = function(val) {
		if (!arguments.length) return this._chart;
		this._chart = val;
		return this;
	};

	// This property is set by DV and shouldn't be set externally.
	geom.normalizedData = function(val) {
		if (!arguments.length) return this._normalizedData;
		this._normalizedData = val;
		return this;
	};

	geom.data = function(val) {
		if (!arguments.length) return this._data ? this._data : this.chart().data();
		this._data = val;
		return this;
	};

	return geom;
});
dv.geom.point = dv.geom.extend(function() {
	function point() {
		this._super();
		this._rendererClass = dv.geom.point;
	}
	point._dataPointStyleClass = "point-geom";

	point._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['shape'] = 'circle';
		this._defaultAes['size'] = 7;
	};

	point.getValues = function(seriesData) {
		return seriesData.values;
	};

	point.exitSeriesGroup = function(geomGroup, self) {
		self.exitSeries(geomGroup, self.enterPen, self);
	};

	point.attributes = function(selection, self) {
		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'opacity', 'alpha')
			.call(self.applyAttributeValue, self, 'stroke', 'stroke')
			.call(self.applyAttributeValue, self, 'fill', 'fill');
	};

	point.getHighlightColor = function(d, i) {
		var fillScale = this.getScale('fill'),
			strokeScale = this.getScale('stroke');

		if (strokeScale && !(strokeScale instanceof dv.scale.constant))
			return strokeScale.mapToProp(d, i);

		if (fillScale && !(fillScale instanceof dv.scale.constant))
			return fillScale.mapToProp(d, i);

		return strokeScale ? strokeScale.mapToProp(d, i) : "#8CC350";
	};

	point.enterPen = function() {
		var self = this,
			x,
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; };

		if (this.position() === 'dodge') {
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
		}
		else {
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); };
		}

		return this._decoratePen(x, y);
	};

	point.pen = function() {
		var self = this,
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y;

		switch(this.position()) {
			case 'identity':
				y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + y.rangeBand() / 2, i); };
				break;
			case 'stack':
				y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0 + d.y), i); };
				break;
			case 'dodge':
				x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
				y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + y.rangeBand() / 2, i); };
				break;
			case 'fill':
				y = function(d, i) { return (d.y + d.y0); }; // Already in percent
				break;
		}

		return this._decoratePen(x, y);
	};

	point._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i)) && dv.util.isFinite(d.panel.yScale(d).mapToProp(d, i));
	};

	point._decoratePen = function(x, y) {
		var shapeScale = this.getScale('shape'),
			sizeScale = this.getScale('size'),
			self = this;

		var pathRenderer = this.coord()._point().x(x).y(y)
			.defined(this._defined);

		pathRenderer.renderer
			.type(function(d, i) { return shapeScale.mapToProp(d, i); })
			.size(function(d, i) { return Math.pow(sizeScale.mapToProp(d, i), 2); });
			// TODO:
			// We can't use getTrainedScale here because it has no ability to lazily create a default scale with a constant value
			// in the event that no size aesthetic was mapped.  We need a way to either:
			//		1. Continue lazily creating default scales.  Does it make sense to create them in dv.facet?
			//			Seems like dv.geom should be the only one who needs to know it's own defaults, but that
			//			creates the potential for awkward conditional logic in many places.
			//				var sizeScale = d.panel.getTrainedScale('size');
			//				return sizeScale ? sizeScale || this.getDefaultScale('size');
			//		2. We could proactively create default scales after training happens in dv.facet for those
			//			aesthetics that were never mapped. This way we could use d.panel.getTrainedScale('size')
			//			without having to worry about whether a scale has been created. **Seems right to me**
			//
			//.size(function(d, i) { return Math.pow(d.panel.getTrainedScale('size').mapToProp(d, i), 2); });

		return {
			bounds: function(d, i) { return pathRenderer.getBounds(d, i); },
			pathTween: function(d, i) { return self.pathTween(pathRenderer, this, d, i); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return point;
});
dv.geom.text = dv.geom.extend(function() {
	function text() {
		this._super();
		this._rendererClass = dv.geom.text;
		this._dx = d3.functor(0);
		this._dy = d3.functor(0);
		this._textFormat = function(d) { return d; };
		this._textAnchor = "start";
	}
	text._dataPointStyleClass = "text-geom";

	text.dx = function(val) {
		if (!arguments.length) return this._dx;
		this._dx = d3.functor(val);
		return this;
	};

	text.dy = function(val) {
		if (!arguments.length) return this._dy;
		this._dy = d3.functor(val);
		return this;
	};

	text.textAnchor = function(val) {
		if (!arguments.length) return this._textAnchor;
		this._textAnchor = val;
		return this;
	};

	text.textFormat = function(val) {
		if (!arguments.length) return this._textFormat;
		this._textFormat = d3.functor(val);
		return this;
	};

	text.getValues = function(seriesData) {
		return seriesData.values;
	};

	text.updateDataPoints = function(seriesGroups, enterPen, pen, exitPen, self) {
		var alphaScale = self.getScale('alpha'),
			_enterPen = enterPen.call(self),
			_updatePen = pen.call(self),
			_exitPen = exitPen.call(self);

		var nodes = seriesGroups.selectAll('.' + self._dataPointStyleClass)
			.data(function(d) { return self.getValues(d); });

		nodes.exit()
			.transition()
				.delay(function(d, i, j) { return self.delay().call(this, d, i, j); })
				.duration(function(d, i, j) { return self.duration().call(this, d, i, j); })
				.ease(self.ease())
				//.style('opacity', 1e-6)
				.call(_exitPen)
				.each("end.transition", function(d, i) {
					var parentNode = this.parentNode;
					if (parentNode) {
						parentNode.removeChild(this);
					}
				});

		nodes.enter()
			.append('text')
				.attr("class", function(d, i, j) { return "datum-" + i + " series-" + j; })
				.call(self.attributes, self)
				//.style('opacity', 1e-6)
				.call(_enterPen);

		var updateTransition = nodes.call(self.attributes, self)
			.call(self._removeRegisteredEvents, self)
			.call(self._addRegisteredEvents, self);

		if (dv.ANIMATION) {
			updateTransition = updateTransition.transition()
				.delay(function(d, i, j) { return self.delay().call(this, d, i, j); })
				.duration(function(d, i, j) { return self.duration().call(this, d, i, j); })
				.ease(self.ease());
		}

		updateTransition
			//.style('opacity', function(d, i) { return alphaScale.mapToProp(d[0], i); })
			.call(_updatePen)
			.call(self.addEachFunction, self);
	};

	text.exitSeriesGroup = function(geomGroup, self) {
		self.exitSeries(geomGroup, self.enterPen, self);
	};

	text.exitSeries = function(seriesGroups, exitPen, self) {
		seriesGroups.selectAll('.' + self._dataPointStyleClass)
			.transition()
				.delay(function(d, i, j) { return self.delay().call(this, d, i, j); })
				.duration(function(d, i, j) { return self.duration().call(this, d, i, j); })
				.ease(self.ease())
				.call(exitPen.call(self))
				.remove()
				.each("end.transition", function(d, i) {
					var seriesGroupNode = this.parentNode;
					if (seriesGroupNode.parentNode)
						seriesGroupNode.removeChild(this);
					if (seriesGroupNode && seriesGroupNode.childNodes && !seriesGroupNode.childNodes.length) {
						d3.select(seriesGroupNode).remove();
					}
				});
	};

	text.attributes = function(selection, self) {
		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'stroke', 'stroke')
			.call(self.applyAttributeValue, self, 'fill', 'fill')
			.call(self.applyAttributeValue, self, 'opacity', 'alpha')
			.call(self.applyAttributeValue, self, 'font-size', 'size')
			.attr('text-anchor', self._textAnchor);
	};

	text.enterPen = function() {
		var self = this,
			dx = this._dx,
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; },
			x;

		if (this.position() === 'dodge') {
			x = function(d, i, j) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d) + dx(d, i, j), i); };
		}
		else {
			x = function(d, i, j) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2 + dx(d, i, j), i); };
		}

		return this._decoratePen(x, y);
	};

	text.pen = function() {
		var self = this,
			dx = this._dx,
			dy = this._dy,
			x = function(d, i, j) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2 + dx(d, i, j), i); },
			y;

		switch(this.position()) {
			case 'identity':
				y = function(d, i, j) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + dy(d, i, j) + y.rangeBand() / 2, i); };
				break;
			case 'stack':
				y = function(d, i, j) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0 + d.y, i) + dy(d, i, j), i); };
				break;
			case 'dodge':
				x = function(d, i, j) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d) + dx(d, i, j), i); };
				y = function(d, i, j) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + dy(d, i, j) + y.rangeBand() / 2, i); };
				break;
			case 'fill':
				y = function(d, i, j) { var y = d.panel.yScale(d); return (d.y + d.y0) + y.mapValueToPercent(dy(d, i, j) + dv.util.scaleRange(y)[0], i); };
				break;
		}

		return this._decoratePen(x, y);
	};

	text._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i)) && dv.util.isFinite(d.panel.yScale(d).mapToProp(d, i));
	};

	text._decoratePen = function(x, y) {
		var labelScale = this.getScale('label'),
			self = this;

		var textRenderer = this.coord()._text().x(x).y(y);

		return textRenderer()
			.label(function(d, i, j) { return self._textFormat.call(this, labelScale.mapToProp(d, i), i, j); })
			.defined(this._defined);
	};

	return text;
});
dv.geom.line = dv.geom.extend(function() {
	function line() {
		this._super();
		this._tension = 0.7;
		this._interpolate = 'linear';
		this._rendererClass = dv.geom.line;
	}
	line._dataPointStyleClass = "line-geom";

	line.tension = function(val) {
		if (!arguments.length) return this._tension;
		this._tension = val;
		return this;
	};

	// For a list of possible values see:  https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate
	line.interpolate = function(val) {
		if (!arguments.length) return this._interpolate;
		this._interpolate = val;
		return this;
	};

	line._render = function(geomGroup) {
		this._super(geomGroup);

		var sizeScale = this.getScale('size');
		if (sizeScale && sizeScale.to && !sizeScale.to()) sizeScale.to([2, 8]);
	};

	line.getValues = function(seriesData) {
		// A single path within a line geom is mapped to several points (not a 1:1 relationship unlike point)
		return [seriesData.values];
	};

	line.exitSeriesGroup = function(geomGroup, self) {
		self.exitSeries(geomGroup, self.enterPen, self);
	};

	line.attributes = function(selection, self) {
		var lineTypeScale = self.getScale('linetype', 0);

		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'stroke', 'stroke')
			.call(self.applyAttributeValue, self, 'opacity', 'alpha')
			.call(self.applyAttributeValue, self, 'stroke-width', 'size')
			.style('stroke-dasharray', function(d, i, j) { return lineTypeScale ? dv.util.svg.getDasharray(lineTypeScale.mapToProp(d[0], i, j)) : null; })
			.style('fill', 'none');
	};

	line.getHighlightColor = function(d, i) {
		var strokeScale = this.getScale('stroke', 0);
		return strokeScale ? strokeScale.mapToProp(d, i) : "#8CC350";
	};

	line.enterPen = function() {
		var self = this,
			x,
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; };

		if (this.position() === 'dodge') {
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
		}
		else {
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); };
		}

		return this._decoratePen(x, y);
	};

	line.pen = function() {
		var self = this,
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y;

		switch(this.position()) {
			case 'identity':
				y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + y.rangeBand() / 2, i); };
				break;
			case 'stack':
				y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0 + d.y), i); };
				break;
			case 'dodge':
				x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
				y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + y.rangeBand() / 2, i); };
				break;
			case 'fill':
				y = function(d, i) { return (d.y + d.y0); };
				break;
		}

		return this._decoratePen(x, y);
	};

	line._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i)) && dv.util.isFinite(d.panel.yScale(d).mapToProp(d, i));
	};

	line._decoratePen = function(x, y) {
		var self = this;

		var pathRenderer = this.coord()._line().x(x).y(y)
			.defined(this._defined);

		pathRenderer.renderer
			.tension(this.tension())
			.interpolate(this.interpolate());

		return {
			bounds: function(d, i) { return pathRenderer.getBounds(d, i); },
			pathTween: function(d, i) { return self.pathTween(pathRenderer, this, d, i); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};
	return line;
});
dv.geom.area = dv.geom.extend(function() {
	function area() {
		this._super();
		this._tension = 0.7;
		this._interpolate = 'linear';
		this._rendererClass = dv.geom.area;
		this._baseline = 0;
	}

	area._dataPointStyleClass = "area-geom";

	area._initializeDefaultAes =function() {
		this._super();
	};

	area._trainScales = function() {
		// By default we set the domain min to be 0
		if (this._baseline !== undefined) {
			var yScaleGroup = this.getExplicitScales('y')['y'];
			for (var scaleIndex in yScaleGroup) {
				var yScale = yScaleGroup[scaleIndex];
				if (yScale instanceof dv.scale.continuous) {
					yScale.softLowerLimit(this._baseline);
				}
			}
		}

		this._super();
	};

	area.tension = function(val) {
		if (!arguments.length) return this._tension;
		this._tension = val;
		return this;
	};

	// For a list of possible values see:  https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-area_interpolate
	area.interpolate = function(val) {
		if (!arguments.length) return this._interpolate;
		this._interpolate = val;
		return this;
	};

	area.getValues = function(seriesData) {
		return [seriesData.values];
	};

	area.pathTween = function(pathRenderer, selection, d, i, j) {
		var dObj = d,
			currentData,
			previousData = selection.__previousBounds__,
			objTweens = [],
			len,
			_enterPen = this.enterPen.call(this, j),
			current,
			previous,
			xDomain = this.getScale("x").domain(),
			pointI = -1;

		currentData = pathRenderer.getBounds(d, i);
		currentData.coord = this.coord();

		// Transitioning from a polar to a cartesian area is tricky with the area geom.  Let's just make it exit for now and we'll transition the new one in.
		if (previousData && previousData.coord
				&& (currentData.coord._type !== previousData.coord._type)
					|| currentData.coord.flip() != previousData.coord.flip()) {
			previousData = this.enterPen.call(this, j).bounds(d, i);
		}

		len = Math.max(currentData.length, previousData.length);
		while(++pointI < len) {
			current = (pointI < currentData.length) ? currentData[pointI] : null;
			previous = (pointI < previousData.length) ? previousData[pointI] : null;
			if (!previous) {
				current.x = xDomain[xDomain.length - 1];
				previous = _enterPen.bounds([current], i)[0];
			}
			else if (!current) {
				current = _enterPen.bounds([previous], i)[0];
			}
			objTweens.push(d3.interpolateObject(previous.bounds, current.bounds));
		}

		selection.__previousBounds__ = currentData;

		return function(t) {
			if (t === 1) { // When the transition finishes, trim off any other data points that no longer exist.
				objTweens = objTweens.splice(0, currentData.length);
			}

			var bounds = [];
			dv.util.each(objTweens, function(tween, tweenIndex) { // Iterate through all the tweens and execute them.
				var obj = {};
				obj.bounds = tween(t);
				bounds.push(obj);
			});
			return pathRenderer.getPath(bounds);
		};
	};

	area.exitSeriesGroup = function(geomGroup, self) {
		self.exitSeries(geomGroup, self.enterPen, self);
	};

	area.attributes = function(selection, self) {
		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'opacity', 'alpha')
			.call(self.applyAttributeValue, self, 'fill', 'fill');
	};

	area.getHighlightColor = function(d, i) {
		var fillScale = this.getScale('fill');
		return fillScale ? fillScale.mapToProp(d, i) : "#8CC350";
	};

	area.getBaseline = function(yScale) {
		var minDomain = d3.min(yScale.domain());
		if (self._baseline !== undefined) {
			return self._baseline;
		}
		return minDomain < 0 ? 0 : minDomain;
	};

	area.enterPen = function() {
		var self = this,
			x,
			y = function(d, i) { var y = d.panel.yScale(d);	return y.mapValueToPercent(y.mapValue(self.getBaseline(y)), i); };

		if (this.position() === 'dodge') {
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
		}
		else {
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); };
		}

		return this._decoratePen(x, y, y);
	};

	area.pen = function() {
		var x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y0, y1,
			self = this;

		switch(this.position()) {
			case 'identity':
				y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(self.getBaseline(y)), i); };
				y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapPropToPercent(d, i); };
				break;
			case 'stack':
				y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0), i); };
				y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0 + d.y), i); };
				break;
			case 'dodge':
				x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
				y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(self.getBaseline(y)), i); };
				y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapPropToPercent(d, i); };
				break;
			case 'fill':
				y0 = function(d, i) { return d.y0; }; // Already in percent
				y1 = function(d, i) { return (d.y + d.y0); }; // Already in percent
				break;
		}

		return this._decoratePen(x, y0, y1);
	};

	area._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i)) && dv.util.isFinite(d.panel.yScale(d).mapToProp(d));
	};

	area._decoratePen = function(x, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._area().x(x).y0(y0).y1(y1)
			.defined(this._defined);

		pathRenderer.renderer
			.tension(this.tension())
			.interpolate(this.interpolate());

		return {
			bounds: function(d, i) {
				var newD = pathRenderer.getBounds(d, i);
				if (newD) {
					newD.coord = self.coord();
				}
				return newD;
			},
			pathTween: function(d, i) { return self.pathTween(pathRenderer, this, d, i); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	area.baseline = function(val) {
		if (!arguments.length) return this._baseline;
		this._baseline = val;
		return this;
	};

	return area;
});
dv.geom.rect = dv.geom.extend(function() {
	function rect() {
		this._super();
		this._rendererClass = dv.geom.rect;
	}
	rect._dataPointStyleClass = "bar-geom";

	rect._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['yMin'] = 1;
		this._defaultAes['yMax'] = 1;
		this._defaultAes['xMin'] = 1;
		this._defaultAes['xMax'] = 1;

		delete this._defaultAes['x'];
		delete this._defaultAes['y'];
	};

	rect._trainScales = function() {
		// This geom won't have y or x aesthetics by default.  We'll need to make sure they exist.  If they don't, we'll create them using
		// properties off the min and max scales.
		var explicitScales = this.getExplicitScales(['yMin', 'xMin']),
			yMinScales = explicitScales['yMin'],
			xMinScales = explicitScales['xMin'],
			scaleIndex;

		for (scaleIndex in yMinScales) {
			var yScaleGroup = this._aes['y'];
			if (!yScaleGroup) this._aes['y'] = yScaleGroup = {};
			if (!yScaleGroup[scaleIndex]) yScaleGroup[scaleIndex] = yMinScales[scaleIndex].copy().property('y').mapping('y');
			yScaleGroup[scaleIndex].trainingProperties(['yMin', 'yMax']);
		}
		for (scaleIndex in xMinScales) {
			var xScaleGroup = this._aes['x'];
			if (!xScaleGroup) this._aes['x'] = xScaleGroup = {};
			if (!xScaleGroup[scaleIndex]) xScaleGroup[scaleIndex] = xMinScales[scaleIndex].copy().property('x').mapping('x');
			xScaleGroup[scaleIndex].trainingProperties(['xMin', 'xMax']);
		}
	};

	rect.getValues = function(seriesData) {
		return seriesData.values;
	};

	rect._render = function(geomGroup) {
		// The chart's y domain and range have been set, make sure that translates over to yMin, yMax, xMin, xMax aesthetics.
		var explicitScales = this.getExplicitScales(['yMin', 'yMax', 'y', 'xMin', 'xMax', 'x']),
			scaleIndex;
		for (scaleIndex in explicitScales['yMin']) {
			var yMinScale = explicitScales['yMin'][scaleIndex],
				yMaxScale = explicitScales['yMax'][scaleIndex],
				yScale = explicitScales['y'][scaleIndex];
			if (yScale) {
				yMaxScale.range(yScale.range()).domain(yScale.domain());
				yMinScale.range(yScale.range()).domain(yScale.domain());
			}
		}
		for (scaleIndex in explicitScales['xMin']) {
			var xMinScale = explicitScales['xMin'][scaleIndex],
				xMaxScale = explicitScales['xMax'][scaleIndex],
				xScale = explicitScales['x'][scaleIndex];
			if (xScale) {
				xMaxScale.range(xScale.range()).domain(xScale.domain());
				xMinScale.range(xScale.range()).domain(xScale.domain());
			}
		}

		this._super(geomGroup);
	};

	rect.pathTween = function(pathRenderer, selection, d, i, j) {
		var dObj = d,
			currentData,
			previousData = selection.__previousBounds__,
			currentCoord = this.coord()._type;

		if (selection.__exiting__)
			currentData = selection.__exitTransition__.bounds(d, i);
		else
			currentData = pathRenderer.getBounds(d, i);

		// Transitioning from a polar to a cartesian bar is tricky with the bar geom.
		if ((previousData && previousData.coord && currentCoord !== previousData.coord)) {
			previousData = selection.__exitTransition__.bounds(d, i);
		}

		if (!currentData || !previousData) return null; // This shouldn't happen, but just in case...

		currentData.coord = currentCoord;

		var objTween = d3.interpolateObject(previousData.bounds, currentData.bounds);
		selection.__previousBounds__ = currentData;
		return function(t) {
			dObj.bounds = objTween(t);
			return pathRenderer.getPath(dObj);
		};
	};

	rect.attributes = function(selection, self) {
		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'fill', 'fill')
			.call(self.applyAttributeValue, self, 'stroke', 'stroke')
			.call(self.applyAttributeValue, self, 'opacity', 'alpha');
	};

	//	The shape of the geometry when its data enters the picture.
	//	The rectangle will appear from the bottom of the viewport.
	rect.enterPen = function() {
		var y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; },
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapValue(dv.util.isArray(d.x) ? d.x[0] : d.xMin, i)); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapValue(dv.util.isArray(d.x) ? d.x[1] : d.xMax, i)); };

		return this._decoratePen(x0, x1, y, y);
	};

	rect.pen = function() {
		var x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapValue(dv.util.isArray(d.x) ? d.x[0] : d.xMin, i)); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapValue(dv.util.isArray(d.x) ? d.x[1] : d.xMax, i)); },
			y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(dv.util.isArray(d.y) ? d.y[0] : d.yMin, i)); },
			y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(dv.util.isArray(d.y) ? d.y[1] : d.yMax, i)); };

		return this._decoratePen(x0, x1, y0, y1);
	};

	rect._defined = function(d, i) {
		var x = d.panel.xScale(d),
			y = d.panel.yScale(d);
		return dv.util.isFinite(x.mapValue(dv.util.isArray(d.x) ? d.x[0] : d.xMin, i))
			&& dv.util.isFinite(x.mapValue(dv.util.isArray(d.x) ? d.x[1] : d.xMax, i))
			&& dv.util.isFinite(y.mapValue(dv.util.isArray(d.y) ? d.y[0] : d.yMin, i))
			&& dv.util.isFinite(y.mapValue(dv.util.isArray(d.y) ? d.y[1] : d.yMax, i));
	};

	rect._decoratePen = function(x0, x1, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._rect().x0(x0).x1(x1).y0(y0).y1(y1)
			.defined(this._defined);

		return {
			bounds: function(d, i) {
				var newD = pathRenderer.getBounds(d, i);
				if (newD) {
					newD.bounds.coord = self.coord()._type;
				}
				return newD;
			},
			pathTween: function(d, i, j) { return self.pathTween(pathRenderer, this, d, i, j); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return rect;
});
dv.geom.tile = dv.geom.rect.extend(function() {
	function tile() {
		this._super();
		this._rendererClass = dv.geom.tile;
	}
	tile._dataPointStyleClass = "tile-geom";

	tile._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['y'] = 1;
		this._defaultAes['x'] = 1;
	};

	tile.getValues = function(seriesData) {
		return seriesData.values;
	};

	tile.enterPen = function() {
		var y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; },
			x0 = function(d, i) { return d.panel.xScale(d).mapPropToPercent(d, i); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand(), i); };

		return this._decoratePen(x0, x1, y, y);
	};

	tile.pen = function() {
		var x0 = function(d, i) { return d.panel.xScale(d).mapPropToPercent(d, i); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand(), i); },
			y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapPropToPercent(d, i); },
			y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapToProp(d, i) + y.rangeBand(), i); };

		return this._decoratePen(x0, x1, y0, y1);
	};

	tile._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i)) && dv.util.isFinite(d.panel.yScale(d).mapToProp(d, i));
	};

	tile._decoratePen = function(x0, x1, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._rect().x0(x0).x1(x1).y0(y0).y1(y1)
			.defined(this._defined);

		return {
			bounds: function(d, i) {
				var newD = pathRenderer.getBounds(d, i);
				if (newD) {
					newD.bounds.coord = self.coord()._type;
				}
				return newD;
			},
			pathTween: function(d, i, j) { return self.pathTween(pathRenderer, this, d, i, j); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return tile;
});
dv.geom.bar = dv.geom.rect.extend(function() {
	function bar() {
		this._super();
		this._rendererClass = dv.geom.bar;
		this._baseline = 0;

		this._width = 1;
	}

	bar._dataPointStyleClass = "bar-geom";

	bar._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['y'] = 1;
		this._defaultAes['x'] = 1;
	};

	bar._trainScales = function() {
		// By default we set the domain min to be 0
		if (this._baseline !== undefined) {
			var yScaleGroup = this.getExplicitScales('y')['y'];
			for (var scaleIndex in yScaleGroup) {
				var yScale = yScaleGroup[scaleIndex];
				if (yScale instanceof dv.scale.continuous) {
					yScale.softLowerLimit(this._baseline);
				}
			}
		}
	};

	bar.getValues = function(seriesData) {
		return seriesData.values;
	};

	bar.getBaseline = function(yScale) {
		var minDomain = d3.min(yScale.domain());
		if (self._baseline !== undefined) {
			return self._baseline;
		}
		return minDomain < 0 ? 0 : minDomain;
	};

	bar.width = function(val) {
		if (!arguments.length) return this.width;
		this._width = val;
		return this;
	};

	/**
	 * Enforces a minimum size on the bar. This is good when zero values are present, or values that are extremely small comparitively
	 * to other values that the bar isn't even displayed. To prevent this issue, we show at least one pixel of height in the bar.
	 * Issue: DV-397
	 */
	bar._enforceMinSize = function(scale, d, i) {
		var baseline = this.getBaseline(scale),
			difference = d[scale.property()] - baseline,
			percentBaseline = scale.mapValueToPercent(scale.mapValue(baseline)),
			percentDifference = scale.mapPropToPercent(d, i) - percentBaseline,
			scaleExtent = dv.util.scaleExtent(scale.range()),
			minSize = 1 / (scaleExtent[1] - scaleExtent[0]);
		if (scale.reverse()) {
			return percentBaseline + (difference < 0 ? Math.max(minSize, percentDifference) : Math.min(-minSize, percentDifference));
		} else {
			return percentBaseline + (difference < 0 ? Math.min(-minSize, percentDifference) : Math.max(minSize, percentDifference));
		}
	};

	bar.enterPen = function() {
		var self = this,
			y = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(self.getBaseline(y)), i); },
			x0, x1;

		if (this.position() === 'dodge') {
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d, true), i); };
		}
		else {
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); };
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); };
		}

		return this._decoratePen(x0, x1, y, y);
	};

	bar.pen = function() {
		var x0, x1, y0, y1,
			self = this;

		switch (this.position()) {
			case 'identity':
				x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); };
				x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); };
				y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(self.getBaseline(y)), i); };
				y1 = function(d, i) { return self._enforceMinSize(d.panel.yScale(d), d, i); };
				break;
			case 'stack':
				x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); };
				x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); };
				y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0), i); };
				y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.y0 + d.y), i); };
				break;
			case 'dodge':
				x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d), i); };
				x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._dodgeAdjust(d, true), i); };
				y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(self.getBaseline(y)), i); };
				y1 = function(d, i) { return self._enforceMinSize(d.panel.yScale(d), d, i); };
				break;
			case 'fill':
				x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); };
				x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); };
				y0 = function(d, i) { return d.y0; }; // Already in percent
				y1 = function(d, i) { return (d.y + d.y0); }; // Already in percent
				break;
		}

		return this._decoratePen(x0, x1, y0, y1);
	};

	bar._offsetX = function(d, isEnd) {
		var x = d.panel.xScale(d),
			rangeBand = x.rangeBand();
		return rangeBand / 2 + rangeBand / 2 * (isEnd ? this._width : -this._width);
	};

	bar._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i)) && dv.util.isFinite(d.panel.yScale(d).mapToProp(d, i));
	};

	bar._decoratePen = function(x0, x1, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._rect().x0(x0).x1(x1).y0(y0).y1(y1)
			.defined(this._defined);

		return {
			bounds: function(d, i) {
				var newD = pathRenderer.getBounds(d, i);
				if (newD) {
					newD.bounds.coord = self.coord()._type;
				}
				return newD;
			},
			pathTween: function(d, i, j) { return self.pathTween(pathRenderer, this, d, i, j); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	bar._dodgeAdjust = function(d, isEnd) {
		var seriesIndex = d.dodge.groupIndex,
			numSeries = d.dodge.numGroups,
			rangeBand = d.panel.xScale(d).rangeBand(),
			slicePadding = (numSeries > 1) ? rangeBand / (numSeries - 1) * this._dodgePadding : 0,
			barWidth = (rangeBand - (slicePadding * (numSeries - 1))) / numSeries;
		return (barWidth + slicePadding) * seriesIndex + (isEnd ? barWidth : 0);
	};

	bar.baseline = function(val) {
		if (!arguments.length) return this._baseline;
		this._baseline = val;
		return this;
	};

	return bar;
});
dv.geom.barrange = dv.geom.bar.extend(function() {
	function barrange() {
		this._super();
		this._rendererClass = dv.geom.barrange;
	}

	barrange._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['yMin'] = 1;
		this._defaultAes['yMax'] = 1;
		delete this._defaultAes['y'];
	};

	barrange._trainScales = function() {
		// This geom won't have a y aesthetic by default (if just has yMax and yMin). So we'll aggregate the yMin and yMax scales
		// to have a unioned y aesthetic.
		var yMinScales = this.getExplicitScales('yMin')['yMin'],
			yScales,
			yScale;
		for (var scaleIndex in yMinScales) {
			if (!this._aes['y']) this._aes['y'] = {};
			yScales = this._aes['y'];
			yScale = yScales[scaleIndex];
			if (!yScale) yScales[scaleIndex] = yScale = yMinScales[scaleIndex].copy().property('y').mapping('y');
			yScale.trainingProperties(['yMin', 'yMax']);
		}
	};

	barrange._render = function(geomGroup) {
		// The chart's y domain and range have been set, make sure that translates over to yMin and yMax aesthetics.
		var explicitScales = this.getExplicitScales(['yMin', 'yMax', 'y']),
			yMinScales = explicitScales['yMin'];
		for (var scaleIndex in yMinScales) {
			var yMinScale = yMinScales[scaleIndex],
				yMaxScale = explicitScales['yMax'][scaleIndex],
				yScale = explicitScales['y'][scaleIndex];

			// TODO: What if the yScale is ordinal? The range function isn't what we'll want here.
			yMaxScale.range(yScale.range()).domain(yScale.domain());
			yMinScale.range(yScale.range()).domain(yScale.domain());
		}

		this._super(geomGroup);
	};

	barrange.enterPen = function() {
		var self = this,
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; },
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); };

		return this._decoratePen(x0, x1, y, y);
	};

	barrange.pen = function() {
		var self = this,
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); },
			y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.yMin, i), i); },
			y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.yMax, i), i); };

		return this._decoratePen(x0, x1, y0, y1);
	};

	barrange._defined = function(d, i) {
		var x = d.panel.xScale(d),
			y = d.panel.yScale(d);
		return dv.util.isFinite(x.mapToProp(d, i))
			&& dv.util.isFinite(y.mapValue(d.yMin, i))
			&& dv.util.isFinite(y.mapValue(d.yMax, i));
	};

	barrange._decoratePen = function(x0, x1, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._rect().x0(x0).x1(x1).y0(y0).y1(y1)
			.defined(this._defined);

		return {
			bounds: function(d, i) {
				var newD = pathRenderer.getBounds(d, i);
				if (newD) {
					newD.bounds.coord = self.coord()._type;
				}
				return newD;
			},
			pathTween: function(d, i, j) { return self.pathTween(pathRenderer, this, d, i, j); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return barrange;
});
dv.geom.segment = dv.geom.line.extend(function() {
	function segment() {
		this._super();
		this._rendererClass = dv.geom.segment;
	}

	segment.getValues = function(seriesData) {
		return seriesData.values;
	};

	segment.enterPen = function() {
		var x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; };

		return this._decoratePen(x, y);
	};

	segment.pen = function() {
		var x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y = function(d, i) { return d.panel.yScale(d).mapPropToPercent(d, i); };

		return this._decoratePen(x, y);
	};

	return segment;
});
dv.geom.vline = dv.geom.segment.extend(function() {
	function vline() {
		this._super();
		this._rendererClass = dv.geom.vline;
	}
	vline._dataPointStyleClass = "vline-geom";

	vline._render = function(geomGroup) {
		var self = this;

		dv.util.each(this._nestData, function(d, i) {
			var values = [];
			dv.util.each(d.values, function(d, i) {
				var xScale = d.panel.xScale(d),
					yScale = d.panel.yScale(d),
					yDomain = yScale.domain(),
					x = d[xScale.property()];

				if (dv.util.isArray(d)) {
					d[0].x = x;
					d[1].x = x;
				} else {
					var minMax = [];
					d.x = x;
					minMax.push(d);
					minMax.push(dv.util.clone(d));

					values.push(minMax);
				}
			});
			self._nestData[i].values = values;
		});

		this._super(geomGroup);
	};

	vline.enterPen = function() {
		var x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y = function(d, i) { return 0; };

		return this._decoratePen(x, y);
	};

	vline.pen = function() {
		var x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y = function(d, i) { return i === 0 ? 0 : 1; };

		return this._decoratePen(x, y);
	};

	vline._defined = function(d, i) {
		return dv.util.isFinite(d.panel.xScale(d).mapToProp(d, i));
	};

	return vline;
});
dv.geom.hline = dv.geom.segment.extend(function() {
	function hline() {
		this._super();
		this._rendererClass = dv.geom.hline;
	}
	hline._dataPointStyleClass = "hline-geom";

	hline._render = function(geomGroup) {
		var self = this;

		dv.util.each(this._nestData, function(d, i) {
			var values = [];
			dv.util.each(d.values, function(d, i) {
				var xScale = d.panel.xScale(d),
					yScale = d.panel.yScale(d),
					xDomain = xScale.domain(),
					y = d[yScale.property()];

				if (dv.util.isArray(d)) { // We have already transformed the data...
					d[0].y = y;
					d[1].y = y;
				} else {
					var minMax = [];
					d.y = y;
					minMax.push(d);
					minMax.push(dv.util.clone(d));

					values.push(minMax);
				}
			});
			self._nestData[i].values = values;
		});

		this._super(geomGroup);
	};

	hline.enterPen = function() {
		var x = function(d, i) { return i === 0 ? 0 : 1; },
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; };

		return this._decoratePen(x, y);
	};

	hline.pen = function() {
		var x = function(d, i) { return i === 0 ? 0 : 1; },
			y = function(d, i) { return d.panel.yScale(d).mapPropToPercent(d, i); };

		return this._decoratePen(x, y);
	};

	hline._defined = function(d, i) {
		return dv.util.isFinite(d.panel.yScale(d).mapToProp(d, i));
	};

	return hline;
});
// Requires yMax and yMin aesthetics be defined.
dv.geom.ribbon = dv.geom.area.extend(function() {
	function ribbon() {
		this._super();
		this._rendererClass = dv.geom.ribbon;
	}

	ribbon._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['yMin'] = 1;
		this._defaultAes['yMax'] = 1;
		delete this._defaultAes['y'];
	};

	ribbon._trainScales = function() {
		// This geom won't have a y aesthetic by default (if just has yMax and yMin). So we'll aggregate the yMin and yMax scales
		// to have a unioned y aesthetic.
		var yMinScales = this.getExplicitScales('yMin')['yMin'],
			yScales,
			yScale;
		for (var scaleIndex in yMinScales) {
			if (!this._aes['y']) this._aes['y'] = {};
			yScales = this._aes['y'];
			yScale = yScales[scaleIndex];
			if (!yScale) yScales[scaleIndex] = yScale = yMinScales[scaleIndex].copy().property('y').mapping('y');
			yScale.trainingProperties(['yMin', 'yMax']);
		}
	};

	ribbon._render = function(geomGroup) {
		// The chart's y domain and range have been set, make sure that translates over to yMin and yMax aesthetics.
		var explicitScales = this.getExplicitScales(['yMin', 'yMax', 'y']),
			yMinScales = explicitScales['yMin'];
		for (var scaleIndex in yMinScales) {
			var yMinScale = yMinScales[scaleIndex],
				yMaxScale = explicitScales['yMax'][scaleIndex],
				yScale = explicitScales['y'][scaleIndex];

			// TODO: What if the yScale is ordinal? The range function isn't what we'll want here.
			yMaxScale.range(yScale.range()).domain(yScale.domain());
			yMinScale.range(yScale.range()).domain(yScale.domain());
		}

		this._super(geomGroup);
	};

	ribbon.enterPen = function() {
		var self = this,
			x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; };

		return this._decoratePen(x, y, y);
	};

	ribbon.pen = function() {
		var x = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + x.rangeBand() / 2, i); },
			y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.yMin, i)); },
			y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.yMax, i)); };

		return this._decoratePen(x, y0, y1);
	};

	ribbon._defined = function(d, i) {
		var x = d.panel.xScale(d),
			y = d.panel.yScale(d);
		return dv.util.isFinite(x.mapToProp(d, i))
			&& dv.util.isFinite(y.mapValue(d.yMin, i))
			&& dv.util.isFinite(y.mapValue(d.yMax, i));
	};

	ribbon._decoratePen = function(x, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._area().x(x).y0(y0).y1(y1)
			.defined(this._defined);

		pathRenderer.renderer
			.tension(this.tension())
			.interpolate(this.interpolate());

		return {
			bounds: function(d, i) {
				var newD = pathRenderer.getBounds(d, i);
				if (newD) {
					newD.coord = self.coord();
				}
				return newD;
			},
			pathTween: function(d, i) { return self.pathTween(pathRenderer, this, d, i); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return ribbon;
});
// Requires yMax and yMin aesthetics be defined.
dv.geom.errorbar = dv.geom.extend(function() {
	function errorbar() {
		this._super();
		this._rendererClass = dv.geom.errorbar;

		this._width = 1;
	}
	errorbar._dataPointStyleClass = "errorbar-geom";

	errorbar._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['yMin'] = 1;
		this._defaultAes['yMax'] = 1;
		delete this._defaultAes['y'];
	};

	errorbar._trainScales = function() {
		// This geom won't have a y aesthetic by default (if just has yMax and yMin). So we'll aggregate the yMin and yMax scales
		// to have a unioned y aesthetic.
		var yMinScales = this.getExplicitScales('yMin')['yMin'],
			yScale;
		for (var scaleIndex in yMinScales) {
			if (!this._aes['y']) this._aes['y'] = {};
			yScales = this._aes['y'];
			yScale = yScales[scaleIndex];
			if (!yScale) yScales[scaleIndex] = yScale = yMinScales[scaleIndex].copy().property('y').mapping('y');
			yScale.trainingProperties(['yMin', 'yMax']);
		}
	};

	errorbar.getValues = function(seriesData) {
		return seriesData.values;
	};

	errorbar.width = function(val) {
		if (!arguments.length) return this._width;
		this._width = val;
		return this;
	};

	errorbar.attributes = function(selection, self) {
		var lineTypeScale = self.getScale('linetype');

		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'stroke', 'stroke')
			.call(self.applyAttributeValue, self, 'opacity', 'alpha')
			.call(self.applyAttributeValue, self, 'stroke-width', 'size')
			.style('stroke-dasharray', function(d, i, j) { return lineTypeScale ? dv.util.svg.getDasharray(lineTypeScale.mapToProp(d[0], i, j)) : null; })
			.style('fill', 'none');
	};

	errorbar._render = function(geomGroup) {
		var xScale = this.getScale('x');

		// Determine the smallest x gap between points
		if (!(xScale instanceof dv.scale.ordinal)) {
			var minDistanceBetweenPoints = Number.MAX_VALUE,
				value,
				previousValue;

			dv.util.each(this._nestData, function(seriesData) {
				dv.util.each(seriesData.values, function(pointData) {
					value = pointData.panel.xScale(pointData).mapValue(pointData.x);
					if (!dv.util.isUndefined(previousValue)) {
						minDistanceBetweenPoints = Math.min(minDistanceBetweenPoints, Math.abs(value - previousValue));
					}
					previousValue = value;
				});
			});

			this._maxWidthPixels = minDistanceBetweenPoints;
		}

		// The chart's y domain and range have been set, make sure that translates over to yMin and yMax aesthetics.
		var explicitScales = this.getExplicitScales(['yMin', 'yMax', 'y']),
			yMinScales = explicitScales['yMin'];
		for (var scaleIndex in yMinScales) {
			var yMinScale = yMinScales[scaleIndex],
				yMaxScale = explicitScales['yMax'][scaleIndex];
				yScale = explicitScales['y'][scaleIndex];

			yMaxScale.range(yScale.range()).domain(yScale.domain());
			yMinScale.range(yScale.range()).domain(yScale.domain());
		}

		this._super(geomGroup);
	};

	errorbar.enterPen = function() {
		var self = this,
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); },
			y = function(d, i) { return d.panel.yScale(d).reverse() ? 1 : 0; };

		return this._decoratePen(x0, x1, y, y);
	};

	errorbar.pen = function() {
		var self = this,
			x0 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d), i); },
			x1 = function(d, i) { var x = d.panel.xScale(d); return x.mapValueToPercent(x.mapToProp(d, i) + self._offsetX(d, true), i); },
			y0 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.yMin, i)); },
			y1 = function(d, i) { var y = d.panel.yScale(d); return y.mapValueToPercent(y.mapValue(d.yMax, i)); };

		return this._decoratePen(x0, x1, y0, y1);
	};

	errorbar._isOrdinal = function(d) {
		return d.panel.xScale(d) instanceof dv.scale.ordinal;
	};

	errorbar._offsetX = function(d, isEnd) {
		var x = d.panel.xScale(d),
			result;
		if (x instanceof dv.scale.ordinal) {
			result = x.rangeBand() / 2 + x.rangeBand() / 2 * (isEnd ? this._width : -this._width);
		}
		else {
			result = this._maxWidthPixels * (isEnd ? this._width / 2 : -this._width / 2);
		}
		return result;
	};

	errorbar._defined = function(d, i) {
		var x = d.panel.xScale(d),
			y = d.panel.yScale(d);
		return dv.util.isFinite(x.mapToProp(d, i))
			&& dv.util.isFinite(y.mapValue(d.yMin, i))
			&& dv.util.isFinite(y.mapValue(d.yMax, i));
	};

	errorbar._decoratePen = function(x0, x1, y0, y1) {
		var self = this;

		var pathRenderer = this.coord()._errorBar().x0(x0).x1(x1).y0(y0).y1(y1)
			.defined(this._defined);

		return {
			bounds: function(d, i) { return pathRenderer.getBounds(d, i); },
			pathTween: function(d, i) { return self.pathTween(pathRenderer, this, d, i); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return errorbar;
});
dv.geom.poly = dv.geom.extend(function() {
	function poly() {
		this._super();
		this._rendererClass = dv.geom.poly;
	}
	poly._dataPointStyleClass = "poly-geom";

	poly._initializeDefaultAes = function() {
		this._super();
		this._defaultAes['size'] = 1;

		delete this._defaultAes['shape'];
		delete this._defaultAes['x'];
		delete this._defaultAes['y'];
	};

	poly._trainScales = function() {
		// This geom won't have y or x aesthetics by default.  We'll need to make sure they exist.  If they don't, we'll create them using
		// properties off the min and max scales.
		var explicitScales = this.getExplicitScales(['yMin', 'xMin']),
			scaleIndex;
		for (scaleIndex in explicitScales['yMin']) {
			var yScaleGroup = this._aes['y'];
			if (!yScaleGroup) this._aes['y'] = yScaleGroup = {};
			if (!yScaleGroup[scaleIndex]) yScaleGroup[scaleIndex] = yMinScale.copy().property('y').mapping('y');
			yScaleGroup[scaleIndex].trainingProperties(['yMin', 'yMax']);
		}
		for (scaleIndex in explicitScales['xMin']) {
			var xScaleGroup = this._aes['x'];
			if (!xScaleGroup) this._aes['x'] = xScaleGroup = {};
			if (!xScaleGroup[scaleIndex]) xScaleGroup[scaleIndex] = xMinScale.copy().property('x').mapping('x');
			xScaleGroup[scaleIndex].trainingProperties(['xMin', 'xMax']);
		}
	};

	poly.getValues = function(seriesData) {
		return seriesData.values;
	};

	poly.attributes = function(selection, self) {
		var fillScale = self.getScale('fill'),
			strokeScale = self.getScale('stroke'),
			alphaScale = self.getScale('alpha');

		selection.attr('style', '') // Clear out any older styles from previous geoms
			.classed(self._dataPointStyleClass, true)
			.call(self.applyAttributeValue, self, 'stroke', 'stroke')
			.call(self.applyAttributeValue, self, 'fill', 'fill')
			.call(self.applyAttributeValue, self, 'opacity', 'alpha');
	};

	poly.exitSeriesGroup = function(geomGroup, self) {
		self.exitSeries(geomGroup, self.enterPen, self);
	};

	poly.getHighlightColor = function(d, i) {
		var fillScale = this.getScale('fill'),
			strokeScale = this.getScale('stroke');

		if (!(strokeScale instanceof dv.scale.constant))
			return strokeScale.mapToProp(d, i);

		if (!(fillScale instanceof dv.scale.constant))
			return fillScale.mapToProp(d, i);

		return strokeScale.mapToProp(d, i);
	};

	poly.enterPen = function() {
		var x = function(d, i) { return d.panel.xScale(d).mapPropToPercent(d, i); },
			y = function(d, i) { var y = d.panel.yScale(d); return dv.util.map(d[y.property()], function() { return y.reverse() ? 1 : 0; }); };

		return this._decoratePen(x, y);
	};

	poly.pen = function() {
		var x = function(d, i) { return d.panel.xScale(d).mapPropToPercent(d, i); },
			y = function(d, i) { return d.panel.yScale(d).mapPropToPercent(d, i); };

		return this._decoratePen(x, y);
	};

	poly._defined = function(d, i) {
		var xs = d.panel.xScale(d).mapToProp(d, i),
			ys = d.panel.yScale(d).mapToProp(d, i),
			max_i = d3.max([xs.length, ys.length]),
			finite = true;

		for (var j = 0; j < max_i && finite; j++) {
			finite = dv.util.isFinite(xs[j]) && dv.util.isFinite(ys[j]);
		}
		return finite;
	};

	poly._decoratePen = function(x, y) {
		var self = this;

		var pathRenderer = this.coord()._poly().xs(x).ys(y)
			.defined(this._defined);

		return {
			bounds: function(d, i) { return pathRenderer.getBounds(d, i); },
			pathTween: function(d, i, j) { return self.pathTween(pathRenderer, this, d, i, j); },
			path: function(d, i) { return pathRenderer.getPath(pathRenderer.getBounds(d, i)); }
		};
	};

	return poly;
});
dv.behavior = dv.extend(function() {

	function behavior() {}

	// Chrome for Android version 18 has a bug where screen coordinates are used instead of client
	// coordinates.
	// https://code.google.com/p/chromium/issues/detail?id=141840
	var useScreenCoords;
	behavior._testAndroidChromeBug141840 = function() {
		if (useScreenCoords === undefined) {
			var ua = navigator.userAgent;
			useScreenCoords = /Android .* Chrome\/18+/.exec(ua) !== null || /Silk\/2./.exec(ua) !== null;
		}
		return useScreenCoords;
	};

	return behavior;
});

dv.behavior.inspector = dv.behavior.extend(function() {
	function inspector() {
		this._size = undefined;
		this._lastX = NaN;
		this._visible = false;
		this._inspector = null;
		this._thickness = 3;
		this._orientation = "bottom";
		this._currentValue = null;
		this._gutterPadding = -7; // This is the amount of space the inspector title can extend beyond the bounds of the plot (right or left)
		this._calloutPadding = { left: 8, top: 7, right: 8, bottom: 7 }; // The amount of padding the sides of the label text -- this will determine how far the background extends outside of the label.
		this._label = this._defaultLabel();
		this._underGeoms = false;
		this._dragInspect = true; // If true, we can immediately inspect without waiting for a longPress
		this._pressTimer = null; // The timer which determines if a longPress touch occurs to start inspection
	}

	inspector._render = function(selection) {
		this._domain = sort_data.call(this);

		var maxWidth = 0,
			bounds = this._chart.facet().getPanel(0)._bounds;

		if (this._size === undefined) this._size = bounds.bottom - bounds.top;

		this._xGuide = dv.util.clone(this._chart._axes._get('x')[0]);
		this._selection = selection;
		this._inspector = selection.selectAll('.inspector').data([0]);

		this._inspector.call(this._createInspector, this._orientation, bounds, this._calloutPadding, this._thickness);
	};

	inspector._createInspector = function(selection, orientation, bounds, calloutPadding, thickness) {
		var inspectorUpdate = selection,
			inspectorEnter = selection.enter();

		inspectorEnter = inspectorEnter.append('g').classed("inspector", true);

		inspectorUpdate.style("pointer-events", "none")
			.attr('opacity', 1e-6)
			.attr("transform", "translate(0," + bounds.top + ")");

		var markerEnter = inspectorEnter.append('g')
			.classed('inspector-marker', true);

		var lineContainerEnter = markerEnter.append('g')
			.classed('inspector-line-container', true);

		lineContainerEnter.append('path')
			.classed('inspector-callout', true);

		inspectorUpdate.select('.inspector-callout')
			.attr('d', function() {
				var y0 = -3,
					y1 = y0 + 5;
				if (orientation === "bottom") {
					y0 = bounds.bottom - bounds.top + 2;
					y1 = y0 - 5;
				}
				return "M-5," + y0 + "L5," + y0 + "L0," + y1 + "Z";
			});

		lineContainerEnter.append('line')
			.classed('inspector-line', true);

		inspectorUpdate.select('.inspector-line')
			.attr('y1', orientation === "bottom" ? 0 : 4)
			.attr('y2', orientation === "bottom" ? bounds.bottom - bounds.top - 6 : bounds.bottom - bounds.top)
			.style('stroke-width', thickness);

		var tip = markerEnter.append('g')
			.classed('inspector-tip', true);

		inspectorUpdate.select('.inspector-tip')
			.attr("transform", "translate(0," + (orientation === "bottom" ? bounds.bottom - bounds.top + 2 : -30) + ")");

		tip.append('rect')
			.classed('inspector-tip-background', true);

		tip.append('text')
			.classed('inspector-tip-label', true);

		inspectorUpdate.select('.inspector-tip-label')
			.attr('x', calloutPadding.left)
			.attr('y', '1em')
			.attr('dy', calloutPadding.top);
	};

	inspector.moveToIndex = function(index) {
		var xScale = this._chart.getTrainedScale('x'),
			value = this._domain[index],
			label = this._label.call(this, value, index),
			xPos = xScale.mapValue(value);

		move.call(this, value, label, xPos);
	};

	inspector.hide = function() {
		this._inspector.attr('opacity', 1e-6);
		this._visible = false;
		return this;
	};

	inspector.show = function() {
		this._inspector.attr('opacity', 1);
		this._visible = true;
		return this;
	};

	inspector._removeEvents = function() {
		this._chart.on('mousemove.inspector', null);
		this._chart.on('mouseout.inspector', null);
		this._chart.on('touchstart.inspector', null);
		this._chart.on('touchmove.inspector', null);
		this._chart.on('touchend.inspector', null);
	};

	inspector.inspectorMove = function(val) {
		if (!arguments.length) return this._inspectorMove;
		this._inspectorMove = val;
		return this;
	};

	inspector.inspectorOut = function(val) {
		if (!arguments.length) return this._inspectorOut;
		this._inspectorOut = val;
		return this;
	};

	inspector.label = function(val) {
		if (!arguments.length) return this._label;
		this._label = d3.functor(val);
		return this;
	};

	inspector.thickness = function(val) {
		if (!arguments.length) return this._thickness;
		this._thickness = val;
		return this;
	};

	inspector.size = function(val) {
		if (!arguments.length) return this._size;
		this._size = val;
		return this;
	};

	inspector.chart = function(val) {
		if (!arguments.length) return this._chart;
		if (this._chart) this._removeEvents();
		this._chart = val;
		if (this._chart) add_events.call(this);
		return this;
	};

	inspector.orientation = function(val) {
		if (!arguments.length) return this._orientation;
		this._orientation = val;
		return this;
	};

	function sort_data() {
		var allData = [],
			chartXScale = this._chart.getTrainedScale('x'),
			sortedData,
			containsTimeData = false,
			uniqCompareFunc = function(a, b) {
				a = chartXScale._parse(a);
				b = chartXScale._parse(b);
				return containsTimeData && a && b ? a.getTime() === b.getTime() : a === b;
			},
			sortCompareFunc = function(d) { return chartXScale.mapValue(d); },
			chartData = this._chart.data(),
			i = -1,
			n = this._chart._layers.length;

		if (chartData.length)
			allData.concat(chartData[chartXScale.property()]);

		while (++i < n) {
			var geom = this._chart._layers[i],
				geomXScale = geom.getTrainedScale('x'),
				geomData = geom.data()[geomXScale.property()];

			// We've already added the chartData and we want to make sure geoms which just point to the chart's data don't
			// have the same data get added over and over again, so we'll check the reference and add if the data tuple is
			// unique to the geom.
			if (geomData && geomData !== chartData) {
				allData = allData.concat(geomData);
			}
			containsTimeData = containsTimeData || (geomXScale instanceof dv.scale.time || geomXScale instanceof dv.scale.time.utc);
		}

		return allData.length ? dv.util.sortBy(dv.util.uniqueValues(allData, uniqCompareFunc), sortCompareFunc) : allData;
	}

	function add_events() {
		this._chart.on('mousemove.inspector', dv.util.bind(on_mouse_move, this));
		this._chart.on('mouseout.inspector', dv.util.bind(on_mouse_out, this));
		this._chart.on('touchstart.inspector', dv.util.bind(on_touch_start, this));
		this._chart.on('touchmove.inspector', dv.util.bind(on_mouse_move, this));
		this._chart.on('touchend.inspector', dv.util.bind(on_touch_end, this));
	}

	// The default label used for the callout if nothing is specified.
	inspector._defaultLabel = function() {
		var self = this;
		return function(d) {
			var formatter = (self._xGuide.tickFormat) ? self._xGuide.tickFormat() : function(d) { return d; };
			return formatter(d);
		};
	};

	// Set a content function or a static HTML string
	inspector.label = function(lbl) {
		if (!arguments.length) return this._label;
		this._label = d3.functor(lbl);
		return this;
	};

	/**
	 * If true, the inspector is drawn underneath the geom.  False otherwise.
	 */
	inspector.underGeoms = function(val) {
		if (!arguments.length) return this._underGeoms;
		this._underGeoms = val;
		return this;
	};

	/**
	 * The amount of padding from the edges along that x axis that the inspector will not go beyond.
	 */
	inspector.gutterPadding = function(val) {
		if (!arguments.length) return this._gutterPadding;
		this._gutterPadding = val;
		return this;
	};

	function move(value, label, xPos) {
		var calloutWidth = 0,
			calloutHeight = 0;

		if (this._lastX === xPos) return;

		this._inspector.attr('opacity', 1);

		this._inspector.select('.inspector-tip-label')
			.text(label)
			.each(function() {
				var bbox = this.getBBox();
				calloutWidth = Math.max(bbox.width, calloutWidth);
				calloutHeight = Math.max(bbox.height, calloutHeight);
			});

		var panelBounds = this._chart.facet().getPanel(0).bounds(),
			inspectorCalloutXPos;

		calloutWidth += this._calloutPadding.left + this._calloutPadding.right;
		calloutHeight += this._calloutPadding.top + this._calloutPadding.bottom;
		inspectorCalloutXPos = xPos - calloutWidth / 2;
		if (inspectorCalloutXPos < panelBounds.left + this._gutterPadding) {
			inspectorCalloutXPos = panelBounds.left + this._gutterPadding;
		}
		if (inspectorCalloutXPos + calloutWidth > panelBounds.right - this._gutterPadding) {
			inspectorCalloutXPos = panelBounds.right - this._gutterPadding - calloutWidth;
		}

		this._inspector.select('.inspector-marker')
				.attr('transform', 'translate(' + inspectorCalloutXPos + ',0)');

		this._inspector.select('.inspector-tip-background')
			.attr('width', calloutWidth)
			.attr('height', calloutHeight);

		var lineXPos = xPos - inspectorCalloutXPos;
		this._inspector.select('.inspector-line-container')
			.attr('transform', 'translate(' + lineXPos + ',0)');
	}

	function on_touch_start(ev) {
		if (!ev) return;

		var self = this;
		this._dragInspect = false;
		clearTimeout(this._pressTimer);
		// Enter drag inspection mode after 500ms to avoid eating scroll events.
		this._pressTimer = setTimeout(function() {
			// Able to interact with the chart now...
			self._dragInspect = true;
			on_mouse_move.call(self, ev);
		}, 500);
		return false;
	}

	function on_touch_end(ev) {
		clearTimeout(this._pressTimer);
		if (this._dragInspect) {
			this._dragInspect = false;
		}
		on_mouse_out.call(this, ev);
	}

	function on_mouse_move(ev) {
		if (!ev) return;

		if (!this._dragInspect) {
			clearTimeout(this._pressTimer);
			return;
		}

		// If touches exist, grab the first one.  This is needed for Chrome for Android which doesn't add the correct clientX/clientY
		// properties to the main touch event.  For non-touch devices, the raw event should contain the appropriate clientX/clientY.
		var rawEvent = ev.touches ? ev.touches[0] : ev;

		var xScale = this._chart.getTrainedScale('x'),
			xCoord = this._testAndroidChromeBug141840() ? rawEvent.screenX : rawEvent.clientX,
			eventX = xCoord - rawEvent.target.getBoundingClientRect().left + rawEvent.target.getBBox().x,
			index = dv.util.binaryCompare(this._domain, eventX, function(d) { return xScale.mapValue(d); }),
			constrainedIndex = Math.min(Math.max(index || 0, 0), this._domain.length - 1),
			value = this._domain[constrainedIndex],
			label = this._label.call(this, value, constrainedIndex),
			xPos = xScale.mapValue(value);


		if (this._currentValue != value) {
			if (this._inspectorMove) {
				this._inspectorMove.call(this, label, constrainedIndex, xPos, value);
			}
			move.call(this, value, label, xPos);
		}
		this._currentValue = value;
		dv.cancelEvent(ev);
	}

	function on_mouse_out(ev) {
		this._inspector.attr('opacity', 1e-6);
		if (this._inspectorOut) {
			this._inspectorOut.call(this);
		}
		this._currentValue = null;
		dv.cancelEvent(ev);
	}

	return inspector;
});
dv.behavior.brush = dv.behavior.extend(function(){

	// Dimensions refer to which positional scales you can adjust.  You can pass in 'x', which will fix the 'y' to the height of the chart
	// (like you might use in a time series chart), or you can pass in 'y', which will fix the 'x' to the width of the chart.  If you
	// choose ['x', 'y'] which is the default, neither scale will be constrained. This is proper for a scatterplot for example.
	function brush(dimensions) {
		if (arguments.length && !dv.util.isArray(dimensions)) this._dimensions = [this._dimensions];
		this._fluidDimensions = dimensions || ['x', 'y'];
		this._snap = false;
		this._resizing = false;
	}

	brush.initializeBrush = function(chart) {
		var self = this;
		this._brush = dv.brush(chart)
			.on("brushstart.brush", function() {
					self._onBrushStart.call(self);
					if (self._brushStart) self._brushStart.call(this, "start", self._brush.extent(), self);
				})
			.on("brush.brush", function(brush) {
					self._onBrushMove.call(self);
					if (self._brushMove) self._brushMove.call(this, "move", self._brush.extent(), self);
				})
			.on("brushend.brush", function() {
					self._onBrushEnd.call(self);
					if (self._brushEnd) self._brushEnd.call(this, "end", self._brush.extent(), self);
				});
	};

	brush._removeEvents = function() {
		this._brush.on("brushstart.brush", null)
			.on("brush.brush", null)
			.on("brushend.brush", null);
	};

	brush._onBrushStart = function() {
		if (!this.snap() || this._fluidDimensions.length > 1) return;

		this._startPos = d3.mouse(this._brushContainer.node());
		// Are they dragging an existing selection instead of sizing it?
		this._moving = d3.select(d3.event.sourceEvent.target).classed("extent");
	};

	brush._onBrushMove = function() {
		if (!this.snap() || this._fluidDimensions.length > 1) return;

		var movePos = d3.mouse(this._brushContainer.node());

		if (this._startPos[0] !== movePos[0] || this._startPos[1] !== movePos[1])
			this._snapToDataPoints();
	};

	brush._onBrushEnd = function() {
		if (!this.snap() || this._fluidDimensions.length > 1) return;

		var endPos = d3.mouse(this._brushContainer.node());

		if (!this._moving && this._startPos[0] === endPos[0] && this._startPos[1] === endPos[1])
			this.clear();
		else
			this._brushContainer.selectAll(".resize").style("display", null);
	};

	/**
	 * Uses the current extent chosen by the underlying dv.brush to snap them to actual data points.
	 */
	brush._snapToDataPoints = function() {
		var brushExtent = this._brush.extent(),
			extentPixels = [],
			scale = this._chart.getTrainedScale(this._fluidDimensions[0]),
			extentValues = [this._snapToNearestPoint(scale, brushExtent[0], 0), this._snapToNearestPoint(scale, brushExtent[1], 1)];

		// Update the extent on the underlying brush
		this._brush.extent([extentValues[0].value, extentValues[1].value]);

		var plotBounds = this._chart.plotBounds();
		if (this._fluidDimensions === "x") {
			extentPixels[0] = [extentValues[0].rangeValue, 0];
			extentPixels[1] = [extentValues[1].rangeValue, plotBounds.bottom - plotBounds.top];
		}
		else {
			extentPixels[0] = [0, extentValues[0].rangeValue];
			extentPixels[1] = [plotBounds.right - plotBounds.left, extentValues[1].rangeValue];
		}

		this._adjustBounds(this._brushContainer, extentPixels);
	};

	/**
	 * Looks at either the minimum or maximum of the extent and determines how it should be snapped. This function returns an object containing
	 * the nearest point we should snap to.  The obj has two properties:  value - The domain value of the nearest point we're snapping to,
	 * rangeValue - The range value of the nearest point we're snapping to (this value will usually be inbetween two points so it's easy to tell
	 * when one data point is selected).
	 *
	 * @param scale - The scale for the dimension we are snapping on
	 * @param point - The value of the edge we are looking at
	 * @param pointIndex - 0 if we're looking at the minimum of the extent, 1 if we're looking at the maximum.
	 */
	brush._snapToNearestPoint = function(scale, point, pointIndex) {
		var retObj = {},
			constrainedIndex;

		if (scale instanceof dv.scale.ordinal || scale instanceof dv.scale.identity) {
			var range = dv.util.scaleRangeNoReverse(scale);
			var totalRange = range[1] - range[0];
			domain = scale.domain(); // possible columns
			constrainedIndex = Math.round(scale.invertValue(point) / totalRange - 1);
		}
		else {
			domain = dv.util.uniq(this._chart.data()[scale.mapping()]);
			index = dv.util.binaryCompare(domain, point, function(d) { return d; });
			constrainedIndex = Math.min(Math.max(index || 0, 0), domain.length - 1);
		}

		var value = domain[constrainedIndex];
		retObj.value = value;

		if (pointIndex === 0) {
			if (constrainedIndex === 0) {
				retObj.rangeValue = scale.mapValue(value);
			}
			else {
				var previousValue = domain[constrainedIndex - 1],
					previousValueRange = scale.mapValue(previousValue);
				valueRange = scale.mapValue(value);
				retObj.rangeValue = valueRange - (valueRange - previousValueRange) / 2;
			}
		}
		else {
			if (constrainedIndex === domain.length - 1) {
				retObj.rangeValue = scale.mapValue(value);
			}
			else {
				var nextValue = domain[constrainedIndex + 1],
					nextValueRange = scale.mapValue(nextValue);
				valueRange = scale.mapValue(value);
				retObj.rangeValue = valueRange + (nextValueRange - valueRange) / 2;
			}
		}

		return retObj;
	};

	brush._adjustBounds = function(g, extentPixels) {
		if (this._fluidDimensions === "x")
			this._adjustBoundsX(g, extentPixels);
		if (this._fluidDimensions === "y")
			this._adjustBoundsY(g, extentPixels);
		g.selectAll(".resize").attr("transform", function(d) {
			return "translate(" + extentPixels[+(/e$/).test(d)][0] + "," + extentPixels[+(/^s/).test(d)][1] + ")";
		});
	};

	brush._adjustBoundsX = function(g, extentPixels) {
		g.select(".extent").attr("x", extentPixels[0][0]);
		g.selectAll(".extent,.n>rect,.s>rect").attr("width", extentPixels[1][0] - extentPixels[0][0]);
	};

	brush._adjustBoundsY = function(g, extentPixels) {
		g.select(".extent").attr("y", extentPixels[0][1]);
		g.selectAll(".extent,.e>rect,.w>rect").attr("height", extentPixels[1][1] - extentPixels[0][1]);
	};

	brush._setScales = function() {
		if (this._fluidDimensions.indexOf('x') >= 0) {
			var x = this._chart.getTrainedScale('x');
			this._brush.x(x._d3Scale);
		}

		if (this._fluidDimensions.indexOf('y') >= 0) {
			var y = this._chart.getTrainedScale('y');
			this._brush.y(y._d3Scale);
		}
	};

	brush._render = function() {
		this._brushContainer = this._chart._parent.select('.interaction-group');

		if (this._brush.empty()) {
			this._brushContainer //= selection.append('g')
				.classed('brush', true)
				.call(this._brush);
		}

		var plotBounds = this._chart.plotBounds();
		if (!this._brush.y()) {
			var height = plotBounds.bottom - plotBounds.top;
			this._brushContainer.selectAll(".extent").attr("height", height).attr("y", 0);
			this._brushContainer.selectAll(".resize rect").attr("height", height).attr("y", 0);
		}
		if (!this._brush.x()) {
			var width = plotBounds.right - plotBounds.left;
			this._brushContainer.selectAll(".extent").attr("width", width).attr("x", 0);
			this._brushContainer.selectAll(".resize rect").attr("width", width).attr("x", 0);
		}
	};

	brush.empty = function() {
		return this._brush.empty();
	};

	brush.clear = function() {
		this._brushContainer.call(this._brush.clear());
	};

	brush.extent = function(extent) {
		if (!arguments.length) return (this._brush) ? this._brush.extent() : null;
		this._brushContainer.call(this._brush.extent(extent));
		return this;
	};

	// whether or not the extent should snap to the nearest data point.  Snap is always false if this._fluidDimensions equals ['x', 'y'].
	brush.snap = function(val) {
		if (!arguments.length) return this._snap;
		this._snap = (this._fluidDimensions.length > 1) ? false : val;
		return this;
	};

	brush.brushStart = function(val) {
		if (!arguments.length) return this._brushStart;
		this._brushStart = val;
		return this;
	};

	brush.brushMove = function(val) {
		if (!arguments.length) return this._brushMove;
		this._brushMove = val;
		return this;
	};

	brush.brushEnd = function(val) {
		if (!arguments.length) return this._brushEnd;
		this._brushEnd = val;
		return this;
	};

	brush.chart = function(val) {
		if (!arguments.length) return this._chart;
		this._chart = val;
		this.initializeBrush(this._chart);
		if (this._chart) this._setScales();
		return this;
	};

	return brush;
});

dv.brush = function(chart) {
	var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
		x = null, // x-scale, optional
		y = null, // y-scale, optional
		resizes = d3_svg_brushResizes[0],
		extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1], in pixels (integers)
		extentDomain; // the extent in data space, lazily created

	function brush(g) {
		g.each(function() {
			var g = d3.select(this),
				bg = g.selectAll(".background").data([0]),
				fg = g.selectAll(".extent").data([0]),
				tz = g.selectAll(".resize").data(resizes, String),
				e;

			chart.on("mousedown.brush", brushstart)
				.on("touchstart.brush", brushstart)
				._g.style("cursor", "crosshair");

			// Prepare the brush container for events.
			g.style("pointer-events", "all");

			// The visible brush extent; style this as you like!
			fg.enter().append("rect")
				.attr("class", "extent")
				.style("cursor", "move");

			// More invisible rects for resizing the extent.
			tz.enter().append("g")
				.attr("class", function(d) { return "resize " + d; })
				.style("cursor", function(d) { return d3_svg_brushCursor[d]; })
			.append("rect")
				.attr("x", function(d) { return (/[e]$/).test(d) ? -10 : (/[w]$/).test(d) ? 2 : null; })
				.attr("y", function(d) { return (/^[ns]/).test(d) ? -3 : null; })
				.attr("width", 10)
				.attr("height", 6)
				.style("visibility", "hidden");

			// Show or hide the resizers.
			tz.style("display", brush.empty() ? "none" : null);

			// Remove any superfluous resizers.
			tz.exit().remove();

			// Initialize the background to fill the defined range.
			// If the range isn't defined, you can post-process.
			if (x) {
				e = dv.util.scaleRangeNoReverse(x);
				bg.attr("x", e[0]).attr("width", e[1] - e[0]);
				redrawX(g);
			}
			if (y) {
				e = dv.util.scaleRangeNoReverse(y);
				bg.attr("y", e[0]).attr("height", e[1] - e[0]);
				redrawY(g);
			}
			redraw(g);
		});
	}

	function redraw(g) {
		g.selectAll(".resize").attr("transform", function(d) {
			return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
		});
	}

	function redrawX(g) {
		g.select(".extent").attr("x", extent[0][0]);
		g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
	}

	function redrawY(g) {
		g.select(".extent").attr("y", extent[0][1]);
		g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
	}

	function brushstart() {
		var target = this,
			eventTarget = d3.select(d3.event.target),
			event_ = event.of(target, arguments),
			g = d3.select(target),
			resizing = eventTarget.datum(),
			resizingX = !/^(n|s)$/.test(resizing) && x,
			resizingY = !/^(e|w)$/.test(resizing) && y,
			dragging = eventTarget.classed("extent"),
			center,
			origin = mouse(),
			offset;

		var w = d3.select(window)
			.on("mousemove.brush", brushmove)
			.on("mouseup.brush", brushend)
			.on("touchmove.brush", brushmove)
			.on("touchend.brush", brushend)
			.on("keydown.brush", keydown)
			.on("keyup.brush", keyup);

		// If the extent was clicked on, drag rather than brush;
		// store the point between the mouse and extent origin instead.
		if (dragging) {
			origin[0] = extent[0][0] - origin[0];
			origin[1] = extent[0][1] - origin[1];
		}

		// If a resizer was clicked on, record which side is to be resized.
		// Also, set the origin to the opposite side.
		else if (resizing && (resizing === "e" || resizing === "w" || resizing === "s" || resizing === "n"
				|| resizing === "nw" || resizing === "ne" || resizing === "sw" || resizing === "se")) {
			var ex = +/w$/.test(resizing),
				ey = +/^n/.test(resizing);
			offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]];
			origin[0] = extent[ex][0];
			origin[1] = extent[ey][1];
		}

		// If the ALT key is down when starting a brush, the center is at the mouse.
		else if (d3.event.altKey) center = origin.slice();

		// Propagate the active cursor to the body for the drag duration.
		g.style("pointer-events", "none").selectAll(".resize").style("display", null);
		d3.select("body").style("cursor", eventTarget.style("cursor"));

		// Notify listeners.
		event_({type: "brushstart"});
		brushmove();
		d3_eventCancel();

		function mouse() {
			var touches = d3.event.changedTouches;
			return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
		}

		function keydown() {
			if (d3.event.keyCode == 32) {
				if (!dragging) {
					center = null;
					origin[0] -= extent[1][0];
					origin[1] -= extent[1][1];
					dragging = 2;
				}
				d3_eventCancel();
			}
		}

		function keyup() {
			if (d3.event.keyCode == 32 && dragging == 2) {
			origin[0] += extent[1][0];
			origin[1] += extent[1][1];
			dragging = 0;
			d3_eventCancel();
			}
		}

		function brushmove() {
			var point = mouse(),
				moved = false;

			// Preserve the offset for thick resizers.
			if (offset) {
				point[0] += offset[0];
				point[1] += offset[1];
			}

			if (!dragging) {

				// If needed, determine the center from the current extent.
				if (d3.event.altKey) {
					if (!center) center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2];

					// Update the origin, for when the ALT key is released.
					origin[0] = extent[+(point[0] < center[0])][0];
					origin[1] = extent[+(point[1] < center[1])][1];
				}

				// When the ALT key is released, we clear the center.
				else center = null;
			}

			// Update the brush extent for each dimension.
			if (resizingX && move1(point, x, 0)) {
				redrawX(g);
				moved = true;
			}
			if (resizingY && move1(point, y, 1)) {
				redrawY(g);
				moved = true;
			}

			// Final redraw and notify listeners.
			if (moved) {
				redraw(g);
				event_({type: "brush", mode: dragging ? "move" : "resize"});
			}
		}

		function move1(point, scale, i) {
			var range = dv.util.scaleRangeNoReverse(scale),
				r0 = range[0],
				r1 = range[1],
				position = origin[i],
				size = extent[1][i] - extent[0][i],
				min,
				max;

			// When dragging, reduce the range by the extent size and position.
			if (dragging) {
				r0 -= position;
				r1 -= size + position;
			}

			// Clamp the point so that the extent fits within the range extent.
			min = Math.max(r0, Math.min(r1, point[i]));

			// Compute the new extent bounds.
			if (dragging) {
				max = (min += position) + size;
			} else {

				// If the ALT key is pressed, then preserve the center of the extent.
				if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));

				// Compute the min and max of the position and point.
				if (position < min) {
					max = min;
					min = position;
				} else {
					max = position;
				}
			}

			// Update the stored bounds.
			if (extent[0][i] !== min || extent[1][i] !== max) {
				extentDomain = null;
				extent[0][i] = min;
				extent[1][i] = max;
				return true;
			}
		}

		function brushend() {
			brushmove();

			// reset the cursor styles
			g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
			d3.select("body").style("cursor", null);

			w .on("mousemove.brush", null)
			.on("mouseup.brush", null)
			.on("touchmove.brush", null)
			.on("touchend.brush", null)
			.on("keydown.brush", null)
			.on("keyup.brush", null);

			event_({type: "brushend"});
			d3_eventCancel();
		}
	}

	brush.x = function(z) {
		if (!arguments.length) return x;
		x = z;
		resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!
		return brush;
	};

	brush.y = function(z) {
		if (!arguments.length) return y;
		y = z;
		resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!
		return brush;
	};

	brush.extent = function(z) {
		var x0, x1, y0, y1, t;

		// Invert the pixel extent to data-space.
		if (!arguments.length) {
			z = extentDomain || extent;
			if (x) {
				x0 = z[0][0], x1 = z[1][0];
				if (!extentDomain) {
					x0 = extent[0][0], x1 = extent[1][0];
					if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
					if (x1 < x0) t = x0, x0 = x1, x1 = t;
				}
			}
			if (y) {
				y0 = z[0][1], y1 = z[1][1];
				if (!extentDomain) {
					y0 = extent[0][1], y1 = extent[1][1];
					if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
					if (y1 < y0) t = y0, y0 = y1, y1 = t;
				}
			}
			return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
		}

		// Scale the data-space extent to pixels.
		extentDomain = [[0, 0], [0, 0]];
		if (x) {
			x0 = z[0], x1 = z[1];
			if (y) x0 = x0[0], x1 = x1[0];
			extentDomain[0][0] = x0, extentDomain[1][0] = x1;
			if (x.invert) x0 = x(x0), x1 = x(x1);
			if (x1 < x0) t = x0, x0 = x1, x1 = t;
			extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
		}
		if (y) {
			y0 = z[0], y1 = z[1];
			if (x) y0 = y0[1], y1 = y1[1];
			extentDomain[0][1] = y0, extentDomain[1][1] = y1;
			if (y.invert) y0 = y(y0), y1 = y(y1);
			if (y1 < y0) t = y0, y0 = y1, y1 = t;
			extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
		}

		return brush;
	};

	brush.clear = function() {
		extentDomain = null;
		extent[0][0] =
		extent[0][1] =
		extent[1][0] =
		extent[1][1] = 0;
		return brush;
	};

	brush.empty = function() {
		return (x && extent[0][0] === extent[1][0])
			|| (y && extent[0][1] === extent[1][1]);
	};

	return d3.rebind(brush, event, "on");
};

var d3_svg_brushCursor = {
	n: "ns-resize",
	e: "ew-resize",
	s: "ns-resize",
	w: "ew-resize",
	nw: "nwse-resize",
	ne: "nesw-resize",
	se: "nwse-resize",
	sw: "nesw-resize"
};

var d3_svg_brushResizes = [
	["n", "e", "s", "w", "nw", "ne", "se", "sw"],
	["e", "w"],
	["n", "s"],
	[]
];

function d3_dispatch() {}
function d3_dispatch_event(dispatch) {
	function event() {
		var z = listeners, i = -1, n = z.length, l;
		while (++i < n) if (l = z[i].on) l.apply(this, arguments);
		return dispatch;
	}
	var listeners = [], listenerByName = new d3.map();
	event.on = function(name, listener) {
		var l = listenerByName.get(name), i;
		if (arguments.length < 2) return l && l.on;
		if (l) {
			l.on = null;
			listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
			listenerByName.remove(name);
		}
		if (listener) listeners.push(listenerByName.set(name, {
			on: listener
		}));
		return dispatch;
	};
	return event;
}

d3_dispatch.prototype.on = function(type, listener) {
		var i = type.indexOf("."), name = "";
		if (i > 0) {
			name = type.substring(i + 1);
			type = type.substring(0, i);
		}
		return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	};

function d3_eventDispatch(target) {
	var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	dispatch.of = function(thiz, argumentz) {
		return function(e1) {
			var e0;
			try {
				e0 = e1.sourceEvent = d3.event;
				e1.target = target;
				d3.event = e1;
				dispatch[e1.type].apply(thiz, argumentz);
			} finally {
				d3.event = e0;
			}
		};
	};
	return dispatch;
}

function d3_eventCancel() {
	d3.event.stopPropagation();
	d3.event.preventDefault();
}

dv.behavior.zoom = dv.behavior.extend(function(){

	// Dimensions refer to which positional scales you can adjust.  You can pass in 'x', which will fix the 'y' to the height of the chart
	// (like you might use in a time series chart), or you can pass in 'y', which will fix the 'x' to the width of the chart.  If you
	// choose ['x', 'y'] which is the default, neither scale will be constrained. This is proper for a scatterplot for example.
	function zoom(dimensions) {
		if (arguments.length && !dv.util.isArray(dimensions)) this._dimensions = [this._dimensions];
		this._fluidDimensions = dimensions || ['x', 'y'];
		this._zoom = d3.behavior.zoom();

		this.scaleExtent([0, Infinity]); // scaleExtent default
		this._underGeoms = false;
	}

	zoom.initializeZoom = function(chart) {
		var self = this;
		this._cacheAxes();
		this._zoom
			.on("zoomstart.zoom", function() {
					if (self._zoomStart) self._zoomStart.call(this, "start", d3.event.scale, d3.event.translate, self);
				})
			.on("zoom.zoom", function() {
					if (self._zoomMove) self._zoomMove.call(this, "move", d3.event.scale, d3.event.translate, self);
					self._refresh(d3.event.scale, d3.event.translate);
				})
			.on("zoomend.zoom", function() {
					if (self._zoomEnd) self._zoomEnd.call(this, "end", d3.event.scale, d3.event.translate, self);
				});
	};

	/**
	 * If true, the inspector is drawn underneath the geom.  False otherwise.
	 */
	zoom.underGeoms = function(val) {
		if (!arguments.length) return this._underGeoms;
		this._underGeoms = val;
		return this;
	};

	zoom._cacheAxes = function() {
		this._axisCache = {};
		for (var axis in this._chart._axes._axes) {
			this._axisCache[axis] = this._chart._axes._axes[axis];
		}
	};

	zoom._removeEvents = function() {
		this._zoom.on("zoomstart.zoom", null)
			.on("zoom.zoom", null)
			.on("zoomend.zoom", null);
	};

	zoom._refresh = function(scale, translate) {
		var self = this,
			xBounds = [0, this._bounds.width - this._bounds.width * scale],
			yBounds = [0, this._bounds.height - this._bounds.height * scale];

		if (scale >= 1) {
			translate[0] = Math.min(xBounds[0], Math.max(translate[0], xBounds[1]));
			translate[1] = Math.min(yBounds[0], Math.max(translate[1], yBounds[1]));
		} else {
			translate[0] = (translate[0] < xBounds[0]) ? xBounds[0] : (translate[0] > xBounds[1]) ? xBounds[1] : translate[0];
			translate[1] = (translate[1] < yBounds[0]) ? yBounds[0] : (translate[1] > yBounds[1]) ? yBounds[1] : translate[1];
		}
		this._zoom.translate(translate);

		setTimeout(function() {
			self._chart._axes._axes = self._axisCache;
			self._chart.duration(0);
			self._chart._finalizePlotBounds();
			self._chart._facet._render();
		}, 0);
	};

	zoom._setScales = function() {
		if (this._fluidDimensions.indexOf('x') >= 0) {
			var x = this._chart.getTrainedScale('x');
			this._zoom.x(x._d3Scale);
		}

		if (this._fluidDimensions.indexOf('y') >= 0) {
			var y = this._chart.getTrainedScale('y');
			this._zoom.y(y._d3Scale);
		}
	};

	zoom._render = function(selection) {
		this._zoomContainer = selection.selectAll('.zoom-container').data([0]);
		this._zoomContainer.enter().append('g')
			.classed('zoom-container');

		var zoomPane = this._zoomContainer.selectAll('.zoom-pane').data([0]);
		zoomPane.enter().append('rect')
			.classed('zoom-pane', true);

		var panel = this._chart.facet().getPanel(0),
			panelBounds = panel.bounds();
		zoomPane
			.attr('x', panelBounds.left)
			.attr('y', panelBounds.top)
			.attr('width', panelBounds.width)
			.attr('height', panelBounds.height)
			.call(this._zoom);
		this._bounds = panelBounds;
	};

	zoom.scale = function(scaleFactor) {
		if (!arguments.length) return this._zoom.scale();
		this._zoom.scale(scaleFactor);
		this._refresh(scaleFactor, this._zoom.translate());
		return this;
	};

	zoom.scaleExtent = function(scaleExtent) {
		if (!arguments.length) return this._zoom.scaleExtent();
		this._zoom.scaleExtent(scaleExtent);
		return this;
	};

	zoom.translate = function(translateCoords) {
		if (!arguments.length) return this._zoom.translate();
		this._zoom.translate(translateCoords);
		this._refresh(this._zoom.scale(), translateCoords);
		return this;
	};

	zoom.zoomStart = function(val) {
		if (!arguments.length) return this._zoomStart;
		this._zoomStart = val;
		return this;
	};

	zoom.zoomMove = function(val) {
		if (!arguments.length) return this._zoomMove;
		this._zoomMove = val;
		return this;
	};

	zoom.zoomEnd = function(val) {
		if (!arguments.length) return this._zoomEnd;
		this._zoomEnd = val;
		return this;
	};

	zoom.chart = function(val) {
		if (!arguments.length) return this._chart;
		this._chart = val;
		this.initializeZoom(this._chart);
		if (this._chart) {
			this._setScales();
			this._chart.clipPlot(true);
		}
		return this;
	};

	return zoom;
});
dv.behavior.rollover = dv.behavior.extend(function() {
	function rollover() {
		this._selection = null;
		this._showTooltip = this._defaultShowTooltip;
		this._hideTooltip = this._defaultHideTooltip;
		this._orientation = "right";
		this._tooltipPadding = 10;
		this._content = this._defaultContent;
		this._lastSelectedTarget = null;
		this._timer = null;
		this._pressTimer = null; // The timer which determines if a longPress touch occurs to start inspection
		this._dragInspect = true;
	}

	// Called internally by DV when the behavior is ready for rendering.
	rollover._render = function(selection) {
		this._xGuides = this.__geom._chart._axes._get('x');
		this._yGuides = this.__geom._chart._axes._get('y');
		this._isPolar = (this.__geom.coord() instanceof dv.coord.polar);
		this._selection = selection;
		this._addEvents();
	};

	// Add events to the corresponding geom to handle hover events.
	rollover._addEvents = function() {
		var self = this;
		this.__geom
			.on("mouseover.rollover", function(d, i, j) { return self._onMouseOver.call(this, d, i, j, self); })
			.on("mouseout.rollover", function(d, i, j) { return self._onMouseOut.call(this, d, i, j, self); });
		this.__geom._chart
			// tap is a non-standard event type, it has been shimmed into D3 via src/d3-compat.js
			.on("tap.rollover", function() { return self._onTap.call(self, d3.event); })
			.on("touchstart.rollover", function() { return self._onTouchStart.call(self, d3.event); })
			.on("touchmove.rollover", function() { return self._onTouchMove.call(self, d3.event); })
			.on("touchend.rollover", function() { return self._onTouchEnd.call(self, d3.event); });
	};

	rollover._removeEvents = function() {
		this.__geom
			.on("mouseover.rollover", null)
			.on("mouseout.rollover", null);
		this.__geom._chart
			.on("tap.rollover", null)
			.on("touchstart.rollover", null)
			.on("touchmove.rollover", null)
			.on("touchend.rollover", null);
	};

	rollover._getElementMetadata = function(geom, d3El) {
		var metadata = { d: d3El.datum(), i: 0, j: 0 };
		geom._geomGroup.selectAll('.series .' + geom._dataPointStyleClass).each(function(d, i, j) {
			if (metadata.d === d) {
				metadata.i = i;
				metadata.j = j;
			}
		});
		return metadata;
	};

	// The default functionality for when a tooltip should be shown.  This can be overriden by supplying a function to `showTooltip`.
	rollover._defaultShowTooltip = function(d, i, j, event, self) {
		self._darkenGeom.call(this, d, self);
		self._showTip.call(this, d, i, j, self);
	};

	// The default functionality for when a tooltip should be removed.  This can be overriden by supplying a function to `hideTooltip`
	rollover._defaultHideTooltip = function(d, i, j, event, self) {
		self._brightenGeom.call(this, d, self);
		self._removeTip.call(this, d, i, j, self);
	};

	// Darken the color of the geom to show it's being hovered on.
	rollover._darkenGeom = function(d, self) {
		var singleGeom = d3.select(this),
			fill,
			stroke,
			darken = function(attr, d, geom) {
				if (d.hasOwnProperty(attr)) {
					var color = self.__geom.getScale(attr).mapValue(d[attr]);
					geom.style(attr, d3.rgb(color).darker(1).toString());
				}
			};

		darken("fill", d, singleGeom);
		darken("stroke", d, singleGeom);
	};

	// Restore the geom to its original brighter color.
	rollover._brightenGeom = function(d, self) {
		var singleGeom = d3.select(this),
			fill,
			stroke,
			darken = function(attr, d, geom) {
				if (d.hasOwnProperty(attr)) {
					var color = self.__geom.getScale(attr).mapValue(d[attr]);
					geom.style(attr, color);
				}
			};

		darken("fill", d, singleGeom);
		darken("stroke", d, singleGeom);
	};

	// Show the tooltip on mouseover
	rollover._showTip = function(d, i, j, self) {
		var parent = self.__geom.chart()._chartContainer,
			bounds = this.getBBox(),
			pos = dv.absoluteCoordinates(self.__geom.chart(), [bounds.x, bounds.y], d.panel),
			boundingRect = {
				height: bounds.height,
				width: bounds.width,
				x: pos[0],
				y: pos[1]
			};

		dv.showTooltip(
			boundingRect,
			parent.select(".plot").node().getBBox(),
			self.content().call(self, d, i, j),
			self._orientation,
			self._tooltipPadding,
			parent
		);
	};

	// Remove the tooltip on mouseout.
	rollover._removeTip = function(d, i, j, self) {
		dv.removeTooltip(self.__geom.chart()._chartContainer);
	};

	// The default content used for the tooltip if nothing is specified.
	rollover._defaultContent = function(d, i, j) {
		var seriesGroup = this.__geom.getExplicitScale("group"),
			obj = d[0] ? d[0] : d,
			x = obj.panel.xScale(obj),
			y = obj.panel.yScale(obj),
			xGuide = this._xGuides[x.scaleIndex()],
			yGuide = this._yGuides[y.scaleIndex()],
			xTickFormat = (xGuide.__scale && xGuide.tickFormat() ? xGuide.tickFormat() : String),
			yTickFormat = (yGuide.__scale && yGuide.tickFormat() ? yGuide.tickFormat() : String),
			content = '<span class="metric-value">' + yTickFormat(obj.data[y.mapping()]) + '</span><span class="metric-name">' + y.mapping() + '</span>'
				+ '<span class="metric-value">' + xTickFormat(obj.data[x.mapping()]) + '</span><span class="metric-name">' + x.mapping() + '</span>';

		if (seriesGroup && seriesGroup.mapping()) {
			content = '<span class="series-name">' + obj.data[seriesGroup.mapping()] + "</span>" + content;
		}

		return content;
	};

	// Event Listeners
	// ----------------

	rollover._onMouseOver = function(d, i, j, self) {
		self._showTooltip.call(this, d, i, j, d3.event, self);
		if (this._mouseOver) this._mouseOver.call(this, d, i, j, d3.event);
	};

	rollover._onMouseOut = function(d, i, j, self) {
		self._hideTooltip.call(this, d, i, j, d3.event, self);
		if (self._mouseOut) self._mouseOut.call(this, d, i, j, d3.event);
	};

	rollover._onTap = function(ev) {
		// Turn on drag inspect so we can see a tooltip.
		this._dragInspect = true;
		this._onTouchMove.call(this, ev);
		// Calling touch end will queue the tooltip for removal after a delay.
		this._onTouchEnd.call(this, ev);
	};

	rollover._onTouchStart = function(ev) {
		var self = this;

		if (this._lastSelectedTarget) {
			clearTimeout(self._timer);
			this._onTouchEnd.call(this, ev, 0);
		}

		this._dragInspect = false;
		clearTimeout(this._pressTimer);
		// Enter drag inspection mode after 500ms to avoid eating scroll events.
		this._pressTimer = setTimeout(function() {
			// Able to interact with the chart now...
			self._dragInspect = true;
			self._onTouchMove.call(self, ev);
		}, 500);
		return false;
	};

	rollover._onTouchMove = function(ev) {
		if (!this._dragInspect) {
			clearTimeout(this._pressTimer);
			return;
		}

		var rawEvent = ev.touches ? ev.touches[0] : ev,
			target = d3.select(this._elementFromPoint(rawEvent)),
			sameNodeAsLastTime = this._lastSelectedTarget && this._lastSelectedTarget.node() === target.node();

		if (!target.empty() && target.classed(this.__geom._dataPointStyleClass)) {
			if (this._lastSelectedTarget && !sameNodeAsLastTime) {
				var lastData = this._lastSelectedTarget.datum();
				this._brightenGeom.call(this._lastSelectedTarget.node(), lastData, this);
			}

			if (!sameNodeAsLastTime) {
				var metadata = this._getElementMetadata(this.__geom, target);
				this._showTooltip.call(target.node(), metadata.d, metadata.i, metadata.j, ev, this);
				if (this._mouseOver) {
					this._mouseOver.call(target.node(), metadata.d, metadata.i, metadata.j, ev);
				}
				this._lastSelectedTarget = target;
			}
		}
		dv.cancelEvent(ev);
	};

	rollover._onTouchEnd = function(ev, delay) {
		var self = this;

		clearTimeout(this._pressTimer);
		this._dragInspect = false;

		var rawEvent = ev.touches ? ev.touches[0] : ev;
		if (arguments.length < 2) {
			delay = 500;
		}
		if (this._lastSelectedTarget) {
			var hide = function() {
				if (!self._lastSelectedTarget) return;
				var metadata = self._getElementMetadata(self.__geom, self._lastSelectedTarget);
				self._hideTooltip.call(self._lastSelectedTarget.node(), metadata.d, metadata.i, metadata.j, ev, self);
				if (self._mouseOut) {
					self._mouseOut.call(self._lastSelectedTarget.node(), metadata.d, metadata.i, metadata.j, ev);
				}
				self._lastSelectedTarget = null;
			};
			if (delay) {
				// TODO: Can we do this without a timeout? Maybe tell _hideTooltip what it's delay should be?
				timer = setTimeout(hide, delay);
			} else {
				hide.call(this);
			}
		}
		dv.cancelEvent(ev);
	};

	rollover._elementFromPoint = function(ev) {
		var point = [ev.clientX, ev.clientY];
		if (this._testAndroidChromeBug141840()) {
			point = [ev.screenX, ev.screenY];
		}
		return document.elementFromPoint(point[0], point[1]);
	};

	// Set a content function or a static HTML string
	rollover.content = function(html) {
		if (!arguments.length) return this._content;
		this._content = d3.functor(html);
		return this;
	};

	// The amount of space between the point and the tooltip edge.
	rollover.tooltipPadding = function(val) {
		if (!arguments.length) return this._tooltipPadding;
		this._tooltipPadding = val;
		return this;
	};

	// Where the tooltip should be positioned relative to the point:  top, left, bottom, right
	rollover.orientation = function(val) {
		if (!arguments.length) return this._orientation;
		this._orientation = val;
		return this;
	};

	rollover.mouseOver = function(val) {
		if (!arguments.length) return this._mouseOver;
		this._mouseOver = val;
		return this;
	};

	rollover.mouseOut = function(val) {
		if (!arguments.length) return this._mouseOut;
		this._mouseOut = val;
		return this;
	};

	// An overridable function that will be called on hover.  If this is undefined, the default tooltip functionality will be used.
	rollover.showTooltip = function(val) {
		if (!arguments.length) return this._showTooltip;
		this._showTooltip = val;
		return this;
	};

	// An overridable function that will be called on mouseout.  If this is undefined, the default tooltip functionality will be used.
	rollover.hideTooltip = function(val) {
		if (!arguments.length) return this._hideTooltip;
		this._hideTooltip = val;
		return this;
	};

	// The parent geom that selection will be applied to.  This will be set automatically by DV.
	rollover._geom = function(val) {
		if (!arguments.length) return this.__geom;
		if (this.__geom && this.__geom !== val) this._removeEvents();
		this.__geom = val;
		return this;
	};

	return rollover;
});

// The voronoi rollover behavior has been filed for a US patent on 7/17/2013.
// AdobePatentID="3119US01"
dv.behavior.voronoiRollover = dv.behavior.rollover.extend(function() {
	function voronoi() {
		this._super();
		this._voronoiContainer = null;
		this._points = null;
		this._pointDetectionRadius = 20;
		this._numHitAreaVertices = 12;
		this._isPolar = false;
	}

	// Called internally by DV when the behavior is ready for rendering.
	voronoi._render = function(selection) {
		this._xGuides = this.__geom._chart._axes._get('x');
		this._yGuides = this.__geom._chart._axes._get('y');
		this._isPolar = (this.__geom.coord() instanceof dv.coord.polar);
		this._selection = selection;
		this._createTooltipContainer();
		this._renderPolygons(this._getPolygonData(), selection);
		this._addEvents();
	};

	// Add events to the corresponding geom to handle hover events.
	voronoi._addEvents = function() {
		var self = this;
		this.__geom._chart
			// tap is a non-standard event type, it has been shimmed into D3 via src/d3-compat.js
			.on("tap.rollover", function() { return self._onTap.call(self, d3.event); })
			.on("touchstart.rollover", function() { return self._onTouchStart.call(self, d3.event); })
			.on("touchmove.rollover", function() { return self._onTouchMove.call(self, d3.event); })
			.on("touchend.rollover", function() { return self._onTouchEnd.call(self, d3.event); });
	};

	voronoi._removeEvents = function() {
		this.__geom._chart
			.on("tap.rollover", null)
			.on("touchstart.rollover", null)
			.on("touchmove.rollover", null)
			.on("touchend.rollover", null);
	};

	// See if a containing SVG group already exists that we can reuse, otherwise create one.
	voronoi._createTooltipContainer = function() {
		this._voronoiContainer = this._selection.selectAll('.voronoiSelection-container').data([this]);
		this._voronoiContainer.enter()
			.append('g')
				.classed('voronoiSelection-container', true);
	};

	voronoi._getPolygonData = function() {
		var vertices = [],
			data = this.__geom._nestData,
			self = this;

		this._points = [];

		var pathRenderer = self.__geom.coord()._point()
			.x(function(d, i) { return d.x; })
			.y(function(d, i) { return d.y; })
			.defined(function(d, i) { return true; });

		// Create an array of [[x1, y1], [x2, y2], ...] vertices to feed into d3.geom.voronoi.
		// Or can we get away with x and y lookups on the object and throw errors on geoms that don't have both of them as not being supported?
		//
		// TODO: There is currently an open bug in D3 to make accessor functions for x and y in d3.geom.voronoi which could eliminate this double
		// loop. When this is fixed, remove the double loop.  https://github.com/mbostock/d3/issues/558
		dv.util.each(this.__geom._nestData, function(seriesArray, j) {
			dv.util.each(seriesArray.values, function(d, i) {
				var cd = {},
					obj = d[0] ? d[0] : d,
					x = obj.panel.xScale(obj),
					y = obj.panel.yScale(obj);
				cd.x = x.mapValueToPercent(x.mapToProp(obj, i) + x.rangeBand() / 2, i) || 0;
				cd.y = y.mapValueToPercent(y.mapValue(obj.hasOwnProperty('y0') ? (obj.y + obj.y0) : obj.y), i) || 0;
				cd.panel = obj.panel;
				var data = pathRenderer.getBounds(cd, i);

				// If we're in polar space, we've currently got angle and radius info that we need to transform into x and y points. If we're in cartesian,
				// this is already handled for us.
				if (self._isPolar) {
					var xyPoint = self.__geom.coord()._transformAngleRadiusToXY(data.bounds.x, data.bounds.y);
					range.bounds.x = xyPoint[0];
					range.bounds.y = xyPoint[1];
				}

				self._points.push({ data: data, rawData: obj, seriesIndex: j, index: i });
				vertices.push([data.bounds.x, data.bounds.y]);
			});
		});

		return d3.geom.voronoi(vertices);
	};

	voronoi._renderPolygons = function(polygonData, selection) {
		var self = this,
			numSeries = this.__geom._nestData.length,
			numItemsPerSeries = this.__geom._nestData[0].values.length,
			geomParent = d3.select(selection.node().parentNode),
			x = 0,
			y = 0,
			pointInfo;

		// Center the SVG group in the middle of the plot if we're in polar.
		if (this._isPolar) {
			var firstPanel = this.__geom._nestData[0].values[0].panel,
				xRange = dv.util.scaleRangeNoReverse(firstPanel.xOuterScale()),
				yRange = dv.util.scaleRangeNoReverse(firstPanel.yOuterScale());
			x = (xRange[0] + xRange[1]) / 2;
			y = (yRange[0] + yRange[1]) / 2;
		}

		this._voronoiContainer
			.attr("transform", 'translate(' + x + ',' + y + ')');

		// Draw clipped voronoi paths.
		var paths = this._voronoiContainer.selectAll("path")
			.data(polygonData);

		paths.exit().remove();

		paths.enter().append("path")
			.attr("id", function(d, i) { return "path-" + i; })
			.classed("voronoi-overlay", true);

		paths
			.attr("d", function(d, i) { return self._getPolygonPath(d, i, self); })
			.on("mouseover.rollover", function(d, i, j) { return self._onMouseOver.call(this, d.data, i, j, self); })
			.on("mouseout.rollover", function(d, i, j) { return self._onMouseOut.call(this, d.data, i, j, self); })
			.call(this._removeRegisteredEvents, this)
			.call(this._addRegisteredEvents, this);

		paths.exit()
			.on("mouseover.rollover", null)
			.on("mouseout.rollover", null)
			.remove();
	};

	voronoi._addRegisteredEvents = function(paths, self) {
		if (!self) self = this;
		if (!self.__geom) return;

		paths = paths || self._voronoiContainer.selectAll('.voronoi-overlay');
		dv.util.each(self.__geom.eventMap, function(e, type) {
			paths.on(type, function(d, i) {
				self.__geom.eventMap[type].callback.call(this, d, i, d3.event);
			}, e.capture);
		});
		dv.util.each(self.__geom._chart.eventMap, function(e, type) {
			paths.on(type + ".dvchart", function(d, i) {
				var e = d3.event,
					interactionGroup = self.__geom._chart._interactionGroup.node();

				if (self._shouldDispatchChartEvent(e, interactionGroup)) {
					self.__geom._chart.eventMap[type].callback.call(interactionGroup, e);
				}
			}, e.capture);
		});
	};

	voronoi._removeRegisteredEvents = function(paths, self) {
		if (!self) self = this;
		if (!self.__geom) return;

		paths = paths || self._voronoiContainer.selectAll('.voronoi-overlay');
		dv.util.each(self.unregisterEventMap, function(capture, type) {
			paths.on(type, null, capture);
		});
		dv.util.each(self.__geom._chart.unregisterEventMap, function(capture, type) {
			paths.on(type + ".dvchart", null, capture);
		});
	};

	voronoi._shouldDispatchChartEvent = function(e, interactionGroup) {
		var result = true;

		// Our chart shouldn't dispatch mouse out/over events when rolling over voronoi paths contained within the plot.
		if (e.type === "mouseout" || e.type === "mouseover") {
			var rTarg = e.relatedTarget;
			if (!rTarg)
				rTarg = (e.type === "mouseout") ? e.toElement : e.fromElement;

			var relTarget = d3.select(rTarg);
			if (relTarget && !relTarget.empty()) {
				var className = relTarget.attr('class');
				result = !((relTarget.node() === interactionGroup) || relTarget.classed("voronoi-overlay"));
			}
		}
		return result;
	};

	// Creates a clipping polygon and performs the clip on the voronoi polygon `d`
	voronoi._getPolygonPath = function(d, i, self) {
		// There is an outstanding issue in D3 where voronoi tessellations produce undefined values if they have colinear points.
		// The thought is that D3 will handle this by introducing jitter to colinear points to make them no longer colinear. We
		// used to introduce jitter ourselves manually by multiplying x and y points by 1e-12 + 1, but D3 has recently started
		// rounding to a precision of 6, so that no longer works.  If D3 manages that problem internally it would be ideal.  For
		// now we just won't allow repeated points to be inspectable.
		//
		// see:  https://github.com/mbostock/d3/issues/1503
		if (!d) return null;
		d.data = self._points[i];
		var temp = dv.util.clone(d),
			pointInfo = self._points[i],
			polygon = d3.geom.polygon(self._getPolygonPoints(pointInfo.data.bounds.x, pointInfo.data.bounds.y)),
			vertices = polygon.clip(d);
		return (vertices.length) ? ("M" + vertices.join("L") + "Z") : null;
	};

	// Get the polygon we'll use for clipping a corresponding voronoi polygon.
	voronoi._getPolygonPoints = function(centerX, centerY) {
		var points = [];

		for (var i = 360; i > 0; i -= 360 / this._numHitAreaVertices) {
			var radians = i * Math.PI / 180,
				x = Math.cos(radians) * this._pointDetectionRadius + centerX,
				y = Math.sin(radians) * this._pointDetectionRadius + centerY;
			points.push([x, y]);
		}

		return points;
	};

	// The default functionality for when a tooltip should be shown.  This can be overriden by supplying a function to `showTooltip`.
	voronoi._defaultShowTooltip = function(d, i, j, event, self) {
		self._showPoint.call(this, d, i, j, self);
		self._showTip.call(this, d, i, j, self);
	};

	// The default functionality for when a tooltip should be removed.  This can be overriden by supplying a function to `hideTooltip`
	voronoi._defaultHideTooltip = function(d, i, j, event, self) {
		self._removePoint.call(this, d, i, j, self);
		self._removeTip.call(this, d, i, j, self);
	};

	// Show a point on hover.
	voronoi._showPoint = function(d, i, j, self) {
		var radius = 10,
			pointData = d.rawData,
			elem = self.getGeomFromVoronoiIndex.call(self, pointData, i, j);

		if (!elem.empty()) {
			var bounds = elem.node().getBoundingClientRect(),
				boundingRect = {
					height: bounds.height,
					width: bounds.width,
					x: bounds.x,
					y: bounds.y
				};
			radius = Math.max(boundingRect.height, boundingRect.width) / 2 + 2.5;
		}

		self._voronoiContainer
			.append("circle")
				.classed("hover-point", true)
				.attr("id", "point-" + j + "-" + i)
				.attr("cx", d.data.bounds.x)
				.attr("cy", d.data.bounds.y)
				.attr("r", 0)
				.style("stroke", function() { return self.__geom.getHighlightColor(d.rawData, i); })
				.style("pointer-events", "none")
				.transition()
					.duration(350)
					.attr("r", radius);
	};

	// Remove the point we've added on mouseout.
	voronoi._removePoint = function(d, i, j, self) {
		self._voronoiContainer.selectAll("#point-" + j + "-" + i)
			.transition()
				.duration(350)
				.attr("r", 0)
				.remove();
	};

	// Show the tooltip on mouseover.
	voronoi._showTip = function(d, i, j, self) {
		var parent = self.__geom.chart()._chartContainer,
			boundingRect,
			voronoiData = d.data,
			pointData = d.rawData;

		var elem = self.getGeomFromVoronoiIndex.call(self, pointData, i, j);
		if (elem.empty()) {
			var position = dv.absoluteCoordinates(self.__geom.chart(), [voronoiData.bounds.x, voronoiData.bounds.y], pointData.panel),
				height = 10, width = 10;
			boundingRect = {
				height: height,
				width: width,
				y: position[1] - height / 2,
				x: position[0] - width / 2
			};
		} else {
			var bounds = elem.node().getBBox();

			boundingRect = {
				height: bounds.height,
				width: bounds.width,
				x: bounds.x,
				y: bounds.y
			};
		}

		dv.showTooltip(
			boundingRect,
			parent.select(".panels").node().getBBox(),
			self.content().call(self, pointData, i, j),
			self._orientation,
			self._tooltipPadding,
			parent
		);
	};

	voronoi.getGeomFromVoronoiIndex = function(d, i, j) {
		// Select all data points which match a given datum and series index. Then filter them down further by comparing references
		// on their data object to make sure they are identical refs. We need to filter because other geoms could have the exact same
		// datum and series indices and we need an extra method to distinguish them.
		return this.__geom.chart()._g.selectAll(".datum-" + i + ".series-" + j).filter(function(eData) { return d === eData; });
	};

	// Event Listeners
	// ----------------

	voronoi._onMouseOver = function(d, i, j, self) {
		self._showTooltip.call(this, d, d.index, d.seriesIndex, d3.event, self);
		if (self._mouseOver)
			self._mouseOver.call(this, d.rawData, d.index, d.seriesIndex, d3.event);
	};

	voronoi._onMouseOut = function(d, i, j, self) {
		self._hideTooltip.call(this, d, d.index, d.seriesIndex, d3.event, self);
		if (self._mouseOut)
			self._mouseOut.call(this, d.rawData, d.index, d.seriesIndex, d3.event);

	};

	voronoi._onTouchMove = function(ev) {
		if (!this._dragInspect) {
			clearTimeout(this._pressTimer);
			return;
		}

		var rawEvent = ev.touches ? ev.touches[0] : ev,
			target = d3.select(this._elementFromPoint(rawEvent)),
			sameNodeAsLastTime = this._lastSelectedTarget && this._lastSelectedTarget.node() === target.node();

		if (!target.empty() && target.classed("voronoi-overlay")) {
			if (this._lastSelectedTarget && !sameNodeAsLastTime) {
				var lastData = this._lastSelectedTarget.datum().data;
				this._removePoint.call(target.node(), lastData.rawData, lastData.index, lastData.seriesIndex, this);
			}

			if (!sameNodeAsLastTime) {
				var d = target.datum().data;
				this._showTooltip.call(target.node(), d, d.index, d.seriesIndex, ev, this);
				if (this._mouseOver) {
					this._mouseOver.call(target.node(), d.rawData, d.index, d.seriesIndex, ev);
				}
				this._lastSelectedTarget = target;
			}
		}
		dv.cancelEvent(ev);
	};

	voronoi._onTouchEnd = function(ev, delay) {
		var self = this;

		clearTimeout(this._pressTimer);
		if (this._dragInspect) {
			this._dragInspect = false;
		}

		if (arguments.length < 2) {
			delay = 500;
		}
		if (this._lastSelectedTarget) {
			var hide = function() {
				if (!self._lastSelectedTarget) return;
				var d = self._lastSelectedTarget.datum().data;
				self._hideTooltip.call(self._lastSelectedTarget.node(), d, d.index, d.seriesIndex, ev, self);
				if (self._mouseOut) {
					self._mouseOut.call(self._lastSelectedTarget.node(), d.rawData, d.index, d.seriesIndex, ev);
				}
				self._lastSelectedTarget = null;
			};
			if (delay) {
				// TODO: Can we do this without a timeout? Maybe tell _hideTooltip what it's delay should be?
				timer = setTimeout(hide, delay);
			} else {
				hide.call(this);
			}
		}
		dv.cancelEvent(ev);
	};

	// The radius of the voronoi clipping polygon.
	voronoi.pointDetectionRadius = function(val) {
		if (!arguments.length) return this._pointDetectionRadius;
		this._pointDetectionRadius = val;
		return this;
	};

	// The number of vertices on the voronoi clipping polygon.
	voronoi.numHitAreaVertices = function(val) {
		if (!arguments.length) return this._numHitAreaVertices;
		this._numHitAreaVertices = val;
		return this;
	};

	return voronoi;
});
dv.log = dv.log || {};
dv.log.NOCONSOLE = false;
dv.log.LVL_ERROR = 0; dv.log.ERROR = "error";
dv.log.LVL_WARN = 1; dv.log.WARN = "warn";
dv.log.LVL_DEBUG = 2; dv.log.DEBUG = "debug";
dv.log.LOGLEVEL = dv.log.LVL_DEBUG;

dv.log.error = function(error) { return dv.log._message(dv.log.ERROR, error); };
dv.log.warn = function(error) { return dv.log._message(dv.log.WARN, error); };
dv.log.debug = function(error) { return dv.log._message(dv.log.DEBUG, error); };

// we don't want to simply override the console object and potentially blow away custom console things the user has done
// but we also want to prevent "blowing up" in IE when the console object isn't available
dv.log.noConsole = function(val) {
	dv.log.NOCONSOLE = val || false;
	dv.log.console = window.console || dv.util.noop;
	if (!dv.log.console.log || dv.log.NOCONSOLE) dv.log.console.log = dv.util.noop;
	if (!dv.log.console.error || dv.log.NOCONSOLE) dv.log.console.error = dv.log.console.log;
	if (!dv.log.console.warn || dv.log.NOCONSOLE) dv.log.console.warn = dv.log.console.log;
	if (!dv.log.console.debug || dv.log.NOCONSOLE) dv.log.console.debug = dv.log.console.log;
};

dv.log._message = function(type, error) {
	if (dv.log._isValidType(type)) {
		if (dv.log.LOGLEVEL >= dv.log["LVL_" + type.toUpperCase()]) dv.log.console[type](error.msg, error.data);
		if (type === dv.log.ERROR) throw error.msg + " Context Data: " + JSON.stringify(error.data);
	} else {
		dv.log.console.log("Logging message with invalid type: " + type);
	}
};

dv.log._isValidType = function(type) {
	return type === dv.log.ERROR || type === dv.log.WARN || type === dv.log.DEBUG;
};

dv.log.noConsole(false);
dv.panel = dv.extend(function() {
	function panel() {
		this._margins = { left: 0, top: 0, right: 0, bottom: 0 };
		this._trainedScales = {};
	}

	// Returns a specific trained scale applied to this panel (particularly useful for position aesthetics)
	panel.getTrainedScale = function(prop) {
		if (prop === 'x')
			return this.xScale();

		if (prop === 'y')
			return this.yScale();

		return this._trainedScales[prop];
	};

	panel.getOuterScale = function(prop) {
		if (prop === 'x') return this._xScale;
		if (prop === 'y') return this._yScale;
		return null;
	};

	panel._updateRanges = function(bounds) {
		var xRange = [bounds.left, bounds.right],
			yRange = [bounds.bottom, bounds.top];

		if (this._facet._chart.coord().flip())	{
			this._xScale.range(yRange);
			this._yScale.range(xRange);
		} else {
			this._xScale.range(xRange);
			this._yScale.range(yRange);
		}
	};

	panel.bounds = function(val) {
		if (!arguments.length) return this._bounds;
		this._bounds = val;
		this._updateRanges(this._bounds);
		return this;
	};

	panel.margins = function(val) {
		if (!arguments.length) return this._margins;
		this._margins = val;
		return this;
	};

	/**
	 * An object which keeps track of which axis orientations should show labels.
	 * An example of this would be:
	 * { "top": false, "left": true, "right": false, "bottom": false }
	 * This indicates that axis labels should only be drawn on the left orientation.
	 */
	panel.visibleAxisLabelOrientations = function(val) {
		if (!arguments.length) return this._visibleAxisLabelOrientations;
		this._visibleAxisLabelOrientations = val;
		return this;
	};

	panel.columnIndex = function(val) {
		if (!arguments.length) return this._columnIndex;
		this._columnIndex = val;
		return this;
	};

	panel.rowIndex = function(val) {
		if (!arguments.length) return this._rowIndex;
		this._rowIndex = val;
		return this;
	};

	panel.facetIndex = function(val) {
		if (!arguments.length) return this._facetIndex;
		this._facetIndex = val;
		return this;
	};

	panel.facetKey = function(val) {
		if (!arguments.length) return this._facetKey;
		this._facetKey = val;
		return this;
	};

	panel.xFacetTitle = function(val) {
		if (!arguments.length) return this._xFacetTitle;
		this._xFacetTitle = val;
		return this;
	};

	panel.yFacetTitle = function(val) {
		if (!arguments.length) return this._yFacetTitle;
		this._yFacetTitle = val;
		return this;
	};

	panel.xOuterScale = function(val) {
		if (!arguments.length) return this._xScale;
		this._xScale = val;
		return this;
	};

	panel.yOuterScale = function(val) {
		if (!arguments.length) return this._yScale;
		this._yScale = val;
		return this;
	};

	panel.xScale = function(d) {
		var scaleIndex = 0;
		if (d && d.hasOwnProperty('x-index')) scaleIndex = d['x-index'];
		return this._xScale.innerScaleGroup()[scaleIndex];
	};

	panel.yScale = function(d) {
		var scaleIndex = 0;
		if (d && d.hasOwnProperty('y-index')) scaleIndex = d['y-index'];
		return this._yScale.innerScaleGroup()[scaleIndex];
	};

	panel.facet = function(val) {
		if (!arguments.length) return this._facet;
		this._facet = val;
		this._trainedScales = {};
		return this;
	};

	return panel;
});
dv.facet = dv.extend(function() {
	function facet() {
		this._numColumns = 0;
		this._numRows = 0;
		this._hGap = 10;
		this._vGap = 10;
	}

	facet._prerender = function() {
		var self = this;
		this._trainedScales = {};
		this._panels = [];
		this._rows = [];
		this._columns = [];
		this._panelsWithAxisLabels = [];

		dv.util.each(self._chart._layers, function(geom) {
			geom._prerender(self._chart);
			self._trainFacetGroups(geom);
		});
		this._configureFacets();
		dv.util.each(self._chart._layers, function(geom) {
			geom._nestData = self._nestFacet(geom);
			geom._handlePositions();
			geom._trainScales();
			geom._createDefaultScales();
		});
		this._trainScales();
	};

	facet._trainScales = function() {
		var self = this,
			trainedScale,
			scale,
			host,
			filter,
			facetFreeFilter = function(panel) { return function(facetKey) { return self._getFacetFromFacetKey(facetKey) !== panel.facetKey(); }; },
			fixedAccessor = function(geom) {
				return function(property, scaleIndex, value) {
					if (arguments.length < 2) scaleIndex = 0;
					if (arguments.length < 3) return (this._globalScales[property] === undefined) ? null : this._globalScales[property][scaleIndex];
					if (!this._globalScales[property]) this._globalScales[property] = {};
					this._globalScales[property][scaleIndex] = value;
					return value;
				};
			};

		this._globalScales = {};
		this._positionScales = {};

		dv.util.each(this._panels, function(panel, i) {
			dv.util.each(self._chart._layers, function(geom) {
				for (var property in geom._aes) {
					var aesGroup = geom._aes[property];
					for (var scaleIndex in aesGroup) {
						var geomScale = geom.getScale(property, scaleIndex);
						if (!(geomScale instanceof dv.scale.constant)) {
							if (self._isFree.call(self, property)) {
								trainedScale = self._trainFreeScale(geom, panel, property, scaleIndex, facetFreeFilter(panel));
							} else {
								trainedScale = self._trainScale(geom, fixedAccessor(geom), property, scaleIndex);
							}
							if (!panel._trainedScales[property]) panel._trainedScales[property] = {};
							panel._trainedScales[property][scaleIndex] = trainedScale;

							aesGroup[scaleIndex].domain(trainedScale.domain());
							aesGroup[scaleIndex].range(trainedScale.range());
						}
					}
				}
			});
		});

		// Once all the scales are trained, make sure the final domains are valid.
		dv.util.each(this._globalScales, function(scaleGroup, prop) {
			dv.util.each(scaleGroup, function(scale, scaleIndex) {
				scale.validateDomain();
				// reverse the global scales now that they have been trained and are valid
				if (scale.reverse()) {
					scale.domain(scale.domain().reverse());
				}
			});
		});
	};

	facet._isFree = function(property) {
		var xProp = property === 'x' || property === 'xMin' || property === 'xMax',
			yProp = property === 'y' || property === 'yMin' || property === 'yMax';
		return ((xProp && (this._scales === "free" || this._scales === "free_x")) || (yProp && (this._scales === "free" || this._scales === "free_y")));
	};

	facet._trainScale = function(geom, trainedScalesAccessor, property, scaleIndex, filter) {
		var trainedScale = trainedScalesAccessor.call(this, property, scaleIndex),
			options = {
				stack: geom.position() === "stack" && property === "y",
				fill: geom.position() === "fill" && property === "y",
				filter: filter
			},
			scale;

		if (trainedScale) {
			scale = geom._aes[property][scaleIndex];
			scale.domain(scale.calculateDomain(geom._nestData, options));
			trainedScale.unionDomain(scale, trainedScale.reverse());
			trainedScale.unionRange(scale.range());
		} else {
			geom._aes[property][scaleIndex].trainDomain(geom._nestData, options);
			trainedScale = geom._aes[property][scaleIndex].copy();
			trainedScalesAccessor.call(this, property, scaleIndex, trainedScale);
		}

		return trainedScale;
	};

	facet._render = function() {
		this._axes = this._chart._axes;
		var grid = this._ensureColumnsAndRows();
		this._adjustPlotBounds(grid[0], grid[1]);
		this._configurePanels(grid[0], grid[1]);
		this._axes._initializeAxisRenderers();
		this._axes._measureTitles(this._chart._plotBounds);
		var maxMargins = this._measureMargins(grid[0], grid[1]);
		this._layoutPanels(grid[0], grid[1], maxMargins);
		this._renderAxisTitles();
		this._renderPanels();
	};

	/**
	 * Returns all axis orientations for which labels should be shown for a given panel.
	 */
	facet._setVisibleAxisLabelOrientations = function(panel, lastRowIndex, lastColIndex, numPanels) {
		var rowIndex = panel.rowIndex(),
			colIndex = panel.columnIndex(),
			labelOrientations = {
				"left": colIndex === 0,
				"top": rowIndex === 0,
				"right": (colIndex === lastColIndex) || (panel.facetIndex() === (numPanels - 1)),
				"bottom": (rowIndex === lastRowIndex) || (colIndex > lastColIndex && rowIndex === lastRowIndex - 1)
			};
		panel.visibleAxisLabelOrientations(labelOrientations);
	};

	facet._changeScaleRangeToLocal = function(outerScale) {
		var outerScaleRange = outerScale.range(),
			innerScaleGroup = outerScale.innerScaleGroup();
		for (var scaleIndex in innerScaleGroup) {
			dv.util.scaleRange(innerScaleGroup[scaleIndex], [outerScaleRange[0], outerScaleRange[1]]).applyRangePadding();
		}
		return innerScaleGroup;
	};

	facet._measureMargins = function(cols, rows) {
		var numPanels = this._panels.length,
			lastRowIndex = ~~((numPanels - 1) / cols),
			lastColIndex = (numPanels - 1) % cols,
			axisOrientations = this._axes._getAllOrientations(),
			maxMargins = { rows: [], cols: [] },
			xIsFree = this._isFree('x'),
			yIsFree = this._isFree('y'),
			self = this,
			firstPanel = this._panels[0];

		if (firstPanel) {
			this._changeScaleRangeToLocal(firstPanel.getOuterScale('x'));
			this._changeScaleRangeToLocal(firstPanel.getOuterScale('y'));
		}

		var i = -1;
		while (++i < numPanels) {
			var panel = this._panels[i],
				colIndex = panel.columnIndex(),
				rowIndex = panel.rowIndex();

			this._setVisibleAxisLabelOrientations(panel, lastRowIndex, lastColIndex, numPanels);
			panel.margins({ left: 0, top: 0, right: 0, bottom: 0 });

			if (rowIndex >= maxMargins.rows.length)
				maxMargins.rows[rowIndex] = { left: 0, top: 0, right: 0, bottom: 0 };
			if (colIndex >= maxMargins.cols.length)
				maxMargins.cols[colIndex] = { left: 0, top: 0, right: 0, bottom: 0 };

			this._panelsWithAxisLabels.push(panel);
			this._axes._measure(panel);
			var panelMargins = panel.margins();

			// In these situations we won't take the margins into account when computing the size of each panel
			// because there is an empty cell adjacent to them which will allow axis labels to avoid collisions,
			// so we don't need to account for them in overall axis margin calculation.
			if (axisOrientations["right"] !== undefined && !yIsFree && (i === (numPanels - 1) && colIndex < cols - 1)) panelMargins.right = 0;
			if (axisOrientations["bottom"] !== undefined && !xIsFree && (colIndex >= lastColIndex && rowIndex === lastRowIndex - 1)) panelMargins.bottom = 0;

			// Iterate through cols and rows setting maximums on each.
			for (var dim in maxMargins) {
				var index = dim === "rows" ? rowIndex : colIndex;
				var margins = maxMargins[dim][index];
				margins.left = Math.max(panelMargins.left, margins.left);
				margins.top = Math.max(panelMargins.top, margins.top);
				margins.right = Math.max(panelMargins.right, margins.right);
				margins.bottom = Math.max(panelMargins.bottom, margins.bottom);
			}
		}

		return maxMargins;
	};

	facet._layoutPanels = function(cols, rows, maxMargins) {
		var plotBounds = this._chart._plotBounds,
			availableWidth = (plotBounds.right - plotBounds.left) - (cols - 1) * this._hGap,
			availableHeight = (plotBounds.bottom - plotBounds.top) - (rows - 1) * this._vGap,
			facetWidth,
			facetHeight,
			cursor = { x: 0, y: 0 },
			self = this,
			i,
			n;

		i = -1;
		n = maxMargins.cols.length;
		while (++i < n) {
			availableWidth -= maxMargins.cols[i].left + maxMargins.cols[i].right;
		}

		i = -1;
		n = maxMargins.rows.length;
		while (++i < n) {
			availableHeight -= maxMargins.rows[i].bottom + maxMargins.rows[i].top;
		}

		facetWidth = Math.max(availableWidth / cols, 0);
		facetHeight = Math.max(availableHeight / rows, 0);

		var axesLabelContainer = this._chart._chartContainer.select(".axes-labels");
		var axesPanels = axesLabelContainer.selectAll(".panel-labels")
			.data(this._panelsWithAxisLabels);

		axesPanels.enter()
			.append("div");

		axesPanels.exit()
			.remove();

		axesPanels
			.attr("class", function(d, i) {
				return "panel-labels panel-" + d.facetIndex();
			});

		var panels = this._chart._panelContainer.selectAll(".panel")
			.data(this._panels);

		panels.enter()
			.append("g")
				.classed("panel", true);

		panels.exit()
			.remove();

		panels
			.each(function(d, i) {
				self._drawPanel.call(this, self, d, i, plotBounds, maxMargins, facetWidth, facetHeight, cols, rows, cursor);
				self._axes._render.call(self._axes, d3.select(this), axesLabelContainer.select(".panel-labels.panel-" + d.facetIndex()), d);
			});
	};

	facet._renderAxisTitles = function() {
		var firstColBounds = this.getColumn(0)[0].bounds(),
			firstRowBounds = this.getRow(0)[0].bounds(),
			lastColBounds = this.getColumn(this._columns.length - 1)[0].bounds(),
			lastRowBounds = this.getRow(this._rows.length - 1)[0].bounds(),
			centerColumns = (lastRowBounds.bottom - firstRowBounds.top) / 2 + firstRowBounds.top,
			centerRows = (lastColBounds.right - firstColBounds.left) / 2 + firstColBounds.left,
			plotBounds = this._chart.plotBounds();

		this._axes._renderTitles(plotBounds, {
			"left": [plotBounds.left, centerColumns],
			"right": [plotBounds.right, centerColumns],
			"top": [centerRows, plotBounds.top],
			"bottom": [centerRows, plotBounds.bottom]
		});
	};

	facet._renderPanels = function() {
		var chart = this._chart,
			bounds = chart._plotBounds,
			plotG = chart._g.select('.plot'),
			plotBounds = chart._plotBounds;

		var draw = function(selection) {
			selection.attr('transform', 'translate(0,0)')
				.each(function(geom) {
					if (this.__previousData__ && (this.__previousData__._dataPointStyleClass != geom._dataPointStyleClass)) {
						this.__previousData__.exit(this); // Clear out all elements from the prior geom.
					}
					geom._render(this);

					this.__previousData__ = geom;
				});
		};

		var exit = function(selection) {
			selection.each(function(geom) {
				geom.exit(this, function() {
					selection.remove();
				});
			});
		};

		// TODO: On exit, we should call the geom's render function and then have it perform an exit transition for the paths inside.
		var sel = plotG.selectAll(".geom").data(chart._layers);
		sel.exit().call(exit);
		sel.enter().append("g").classed('geom', true);
		sel.call(draw);
	};

	facet._updatePanelTitle = function(self, label, orientation, left, top, width, height) {
		var titleBounds = { left: 0, top: 0, width: 0, height: 0 },
			el = d3.select(this);

		if (dv.util.isUndefined(label)) {
			self._removePanelTitle.call(this, orientation);
			return titleBounds;
		}

		var title = el.selectAll(".panel-title." + orientation).data([0]);

		var panelTitleEnter = title.enter()
			.append("g")
				.classed("panel-title " + orientation, true)
				.attr("transform", "translate(" + left + "," + top + ")");

		var titleBgEnter = panelTitleEnter
			.append("rect")
				.classed("panel-title-bg", true);

		var titleLabelEnter = panelTitleEnter
			.append("text")
				.classed("panel-title-label", true)
				.attr("text-anchor", "middle");

		if (dv.ANIMATION) {
			title.transition().duration(self._chart._duration).attr("transform", "translate(" + left + "," + top + ")");
		} else {
			title.attr("transform", "translate(" + left + "," + top + ")");
		}

		var titleLabel = title.selectAll(".panel-title-label")
			.text(label);

		var titleBg = title.selectAll(".panel-title-bg");

		var titleBBox = titleLabel.node().getBBox(),
			rotation = 0;

		if (dv.ANIMATION) {
			titleLabel = titleLabel.transition().duration(self._chart._duration);
			titleBg = titleBg.transition().duration(self._chart._duration);
		}

		switch(orientation) {
			case "top" :
				x = width / 2;
				y = titleBBox.height;
				titleBounds.left = 0;
				titleBounds.top = 0;
				titleBounds.width = width;
				titleBounds.height = titleBBox.height + 6;
				break;
			case "right" :
				x = height / 2;
				y = -width + titleBBox.height;
				titleBounds.left = width - (titleBBox.height + 6);
				titleBounds.top = 0;
				titleBounds.width = titleBBox.height + 6;
				titleBounds.height = height;
				rotation = 90;
				break;
			case "bottom" :
				x = width / 2;
				y = height - 6;
				titleBounds.left = 0;
				titleBounds.top = height - (titleBBox.height + 6);
				titleBounds.width = width;
				titleBounds.height = titleBBox.height + 6;
				break;
			case "left" :
				x = -height / 2;
				y = 0 + (titleBBox.height);
				titleBounds.left = 0;
				titleBounds.top = 0;
				titleBounds.width = titleBBox.height + 6;
				titleBounds.height = height;
				rotation = 270;
				break;
		}

		titleBgEnter
			.attr("x", titleBounds.left)
			.attr("y", titleBounds.top)
			.attr("width", titleBounds.width)
			.attr("height", titleBounds.height);

		titleLabelEnter.attr("transform", "rotate(" + rotation + " 0,0)")
			.attr("x", x)
			.attr("y", y);

		titleLabel.attr("transform", "rotate(" + rotation + " 0,0)")
			.attr("x", x)
			.attr("y", y);

		titleBg
			.attr("x", titleBounds.left)
			.attr("y", titleBounds.top)
			.attr("width", titleBounds.width)
			.attr("height", titleBounds.height);

		return titleBounds;
	};

	facet._removePanelTitle = function(orientation) {
		d3.select(this).selectAll(".panel-title." + orientation).remove();
	};

	facet._updatePanelBackground = function(facet, left, top, width, height) {
		var bg = d3.select(this).selectAll(".plot-bg").data([0]);

		bg.enter()
			.append("rect")
				.classed("plot-bg", true)
				.attr('x', left)
				.attr('y', top)
				.attr('width', width)
				.attr('height', height);

		if (dv.ANIMATION) {
			bg = bg.transition()
				.duration(facet._chart._duration);
		}

		bg.attr('x', left)
			.attr('width', width)
			.attr('height', height);
	};

	facet._addToCollection = function(arr, index, panel) {
		if (!arr[index]) {
			arr[index] = [];
		}
		arr[index].push(panel);
	};

	facet.getPanel = function(panelIndex) {
		return this._panels && panelIndex < this._panels.length ? this._panels[panelIndex] : null;
	};

	facet.getRow = function(rowIndex) {
		return this._rows[rowIndex];
	};

	facet.getColumn = function(colIndex) {
		return this._columns[colIndex];
	};

	facet.getTrainedScale = function(prop) {
		if (this._panels.length > 0) {
			return this.getPanel(0).getTrainedScale(prop);
		}
		return this._trainedScales[prop];
	};

	facet.scales = function(val) {
		if (!arguments.length) return this._scales;
		this._scales = val;
		return this;
	};

	facet.space = function(val) {
		if (!arguments.length) return this._space;
		this._space = val;
		return this;
	};

	facet.titleFormat = function(val) {
		if (!arguments.length) return this._titleFormat;
		this._titleFormat = d3.functor(val);
		return this;
	};

	facet.hGap = function(val) {
		if (!arguments.length) return this._hGap;
		this._hGap = val;
		return this;
	};

	facet.vGap = function(val) {
		if (!arguments.length) return this._vGap;
		this._vGap = val;
		return this;
	};

	facet.chart = function(val) {
		if (!arguments.length) return this._chart;
		this._chart = val;
		return this;
	};

	return facet;
});

dv.facet.scale = dv.extend(function() {
	function scale(){}

	scale.domain = function() {
		return this._innerScale.domain();
	};

	scale.range = function(val) {
		if (!arguments.length) return this._range;
		this._range = val;
		return this;
	};

	scale._applyPercentage = function(scaleFunc, args) {
		return this._range[0] + (this._range[1] - this._range[0]) * scaleFunc.apply(this._innerScale, args);
	};

	scale.mapPropToPercent = function(val, i) {
		return this._innerScale.mapPropToPercent(val);
	};

	scale.mapValueToPercent = function(val, i) {
		return this._innerScale.mapValueToPercent(val);
	};

	scale.mapToProp = function(val, i) {
		return this._applyPercentage(this._innerScale.mapPropToPercent, [val, i]);
	};

	scale.mapValue = function(val, i) {
		return this._applyPercentage(this._innerScale.mapValueToPercent, [val, i]);
	};

	scale.rangeBand = function() {
		return this._applyPercentage(this._innerScale.rangeBand);
	};

	scale.innerScaleGroup = function(val) {
		if (!arguments.length) return this._innerScaleGroup;
		this._innerScaleGroup = val;
		return this;
	};

	return scale;
});
dv.facet.wrap = dv.facet.extend(function() {
	function wrap() {
		this._super();

		this._facetScale = null;

		this._preferredAspectRatio = 1;
		this._titleOrientation = "top";
	}

	wrap._prerender = function() {
		this._facetScale = dv.scale.ordinal().mapping(this._group).domain([]);
		this._super();
	};

	wrap._trainFacetGroups = function(geom) {
		var geomFacetTuple = geom.data()[this._facetScale.mapping()];
		if (geomFacetTuple) {
			// domain uniques the values.
			this._facetScale.domain(this._facetScale.domain().concat(geomFacetTuple));
		}
	};

	wrap._trainFreeScale = function(geom, panel, property, scaleIndex, filterFunc) {
		var trainedScalesAccessor = function(property, scaleIndex, value) {
			if (arguments.length < 2) scaleIndex = 0;
			if (arguments.length < 3) {
				if (!panel._trainedScales[property]) return undefined;
				return panel._trainedScales[property][scaleIndex];
			}
			if (!panel._trainedScales[property]) panel._trainedScales[property] = {};
			panel._trainedScales[property][scaleIndex] = value;
			return value;
		};
		return this._trainScale(geom, trainedScalesAccessor, property, scaleIndex, filterFunc);
	};

	/**
	 * If a position scale is free, each facet panel should show labels.
	 */
	wrap._showAllPanelLabelsIfFree = function() {
		return true;
	};

	wrap._configureFacets = function() {
		this._facetKeys = this._facetScale.domain();
		this._facetMap = {};
	};

	wrap._nestFacet = function(geom) {
		// Convert parallel arrays into objects
		var self = this,
			normalizedData = geom.normalizedData(),
			zipData = dv.util.filterAndZip(normalizedData),
			group = geom.getScale('group'),
			facetMapping = this._group,
			facetKeys = this._facetScale.domain(),
			groupProperty,
			groupKeys;

		if (group) {
			groupProperty = group.property();
			groupKeys = groupProperty ? normalizedData[groupProperty] : null;
		}

		var i = -1,
			n = zipData.length;
		while (++i < n) {
			var facetIndex = 0,
				facetTitle,
				data = zipData[i];
			if (data.data.hasOwnProperty(facetMapping)) {
				facetIndex = facetKeys.indexOf(data.data[facetMapping]);
				if (facetIndex >= 0) {
					facetTitle = facetKeys[facetIndex] + "";
				}
			}
			var panel = this._facetMap[facetIndex];
			if (!panel) {
				panel = dv.panel()
					.facetIndex(facetIndex)
					.facetKey(facetTitle)
					.xFacetTitle(facetTitle)
					.facet(this);
				this._facetMap[facetIndex] = panel;
				this._panels.push(panel);
			}
			data.panel = panel;
		}

		// The nest structure should be nested by facet and then group.
		return d3.nest()
			.key(function(d) {
				// facet ~ group
				var id = "";
				id += (d.data.hasOwnProperty(facetMapping) ? d.data[facetMapping] : ".") + " ~ ";
				id += (d.hasOwnProperty(groupProperty) ? d[groupProperty] : ".");
				return id;
			})
			.sortKeys(function(a, b) { // Ensure sort order is maintained.
				var groupA = self._getGroupFromFacetKey(a),
					groupB = self._getGroupFromFacetKey(b),
					aIndex = -1,
					bIndex = -1;

				if (groupA !== ".") {
					aIndex = groupKeys.indexOf(groupA);
					if (aIndex < 0)
						aIndex = groupKeys.indexOf(Number(groupA));
				}

				if (groupB !== ".") {
					bIndex = groupKeys.indexOf(groupB);
					if (bIndex < 0)
						bIndex = groupKeys.indexOf(Number(groupB));
				}

				return bIndex < aIndex ? 1 : -1;
			})
			.entries(zipData);
	};

	wrap._getGroupFromFacetKey = function(facetKey) {
		return (/.* ~ (.*)/g).exec(facetKey)[1];
	};

	wrap._getFacetFromFacetKey = function(facetKey) {
		return (/(.*) ~ .*/g).exec(facetKey)[1];
	};

	wrap._ensureColumnsAndRows = function() {
		var facets = this._panels.length,
			cols = Math.min(this._numColumns, facets),
			rows = Math.min(this._numRows, facets);

		if (cols < 1 && rows < 1) {
			// Let's pick an acceptable default of rows and columns based on the preferred panel aspect ratio.
			// We won't force the aspect ratio, but we'll use it as best we can to inform the cols and rows.
			var plotBounds = this._chart._plotBounds,
				plotWidth = plotBounds.right - plotBounds.left,
				plotHeight = plotBounds.bottom - plotBounds.top,
				columns = Math.min(facets, Math.ceil(Math.sqrt((facets * 1 * plotWidth) / (plotHeight * this._preferredAspectRatio))));

			columns = isNaN(columns) ? 1 : columns;
			return [columns, Math.ceil(facets / columns)];
		}

		if (cols < 1 && rows >= 1) {
			// Figure out num columns
			cols = Math.ceil(facets / rows);
		}

		if (cols >= 1 && rows < 1) {
			// Figure out num rows
			rows = Math.ceil(facets / cols);
		}

		return [cols, rows];
	};

	wrap._adjustPlotBounds = function(cols, rows) {
		return;
	};

	wrap._configurePanels = function(cols, rows) {
		var plotBounds = this._chart._plotBounds,
			plotWidth = plotBounds.right - plotBounds.left,
			plotHeight = plotBounds.bottom - plotBounds.top,
			facetWidth = (plotWidth - ((cols - 1) * this._hGap)) / cols,
			facetHeight = (plotHeight - ((rows - 1) * this._vGap)) / rows;

		var i = -1,
			n = this._panels.length;
		while (++i < n) {
			var panel = this._panels[i],
				xFacetScale = dv.facet.scale().innerScaleGroup(panel._trainedScales.x),
				yFacetScale = dv.facet.scale().innerScaleGroup(panel._trainedScales.y),
				columnIndex = i % cols,
				rowIndex = ~~(i / cols),
				panelBounds = {
					left: 0,
					top: 0,
					right: facetWidth,
					bottom: facetHeight,
					width: facetWidth,
					height: facetHeight
				};

			this._panels[i]
				.xOuterScale(xFacetScale)
				.yOuterScale(yFacetScale)
				.columnIndex(columnIndex)
				.rowIndex(rowIndex)
				.bounds(panelBounds);

			this._addToCollection(this._rows, rowIndex, panel);
			this._addToCollection(this._columns, columnIndex, panel);
		}
	};

	wrap._drawPanel = function(self, d, i, plotBounds, maxMargins, facetWidth, facetHeight, cols, rows, cursor) {
		var colIndex = d.columnIndex(),
			rowIndex = d.rowIndex(),
			maxMarginRow = maxMargins.rows[rowIndex],
			maxMarginCol = maxMargins.cols[colIndex],
			orientation = self._titleOrientation;

		if (colIndex === 0) {
			cursor.x += plotBounds.left;

			if (rowIndex === 0) {
				cursor.y += plotBounds.top;
			}
		}

		var top = cursor.y + maxMarginRow.top,
			left = cursor.x + maxMarginCol.left,
			title = (self._titleFormat ? self._titleFormat.call(this, d.xFacetTitle(), i) : d.xFacetTitle());

		var titleBounds = self._updatePanelTitle.call(this, self, title, orientation, left, top, facetWidth, facetHeight);

		d.bounds({
			width: facetWidth,
			height: facetHeight,
			top: top + (orientation === "top" ? titleBounds.height : 0),
			left: left + (orientation === "left" ? titleBounds.width : 0),
			right: left + facetWidth + (orientation === "right" ? -titleBounds.width : 0),
			bottom: top + facetHeight + (orientation === "bottom" ? -titleBounds.height : 0)
		});

		self._updatePanelBackground.call(this, self, left, top, facetWidth, facetHeight);

		if (colIndex === cols - 1) {
			cursor.x = 0;
			cursor.y += maxMarginRow.top + facetHeight + maxMarginRow.bottom + self._vGap;
		}
		else {
			cursor.x += maxMarginCol.left + facetWidth + maxMarginCol.right + self._hGap;
		}
	};

	wrap.group = function(val) {
		if (!arguments.length) return this._group;
		this._group = val;
		return this;
	};

	wrap.numColumns = function(val) {
		if (!arguments.length) return this._numColumns;
		this._numColumns = val;
		return this;
	};

	wrap.numRows = function(val) {
		if (!arguments.length) return this._numRows;
		this._numRows = val;
		return this;
	};

	wrap.preferredAspectRatio = function(val) {
		if (!arguments.length) return this._preferredAspectRatio;
		this._preferredAspectRatio = val;
		return this;
	};

	return wrap;
});
dv.facet.grid = dv.facet.extend(function() {
	function grid() {
		this._super();

		this._xFacetScale = null;
		this._yFacetScale = null;
	}

	grid._prerender = function() {
		this._xFacetScale = dv.scale.ordinal().mapping(this._xGroup).domain([]);
		this._yFacetScale = dv.scale.ordinal().mapping(this._yGroup).domain([]);
		this._super();
	};

	grid._trainFacetGroups = function(geom) {
		var xGeomFacetTuple = geom.data()[this._xFacetScale.mapping()];
		if (xGeomFacetTuple) {
			// domain uniques the values.
			this._xFacetScale.domain(this._xFacetScale.domain().concat(xGeomFacetTuple));
		}

		var yGeomFacetTuple = geom.data()[this._yFacetScale.mapping()];
		if (yGeomFacetTuple) {
			// domain uniques the values.
			this._yFacetScale.domain(this._yFacetScale.domain().concat(yGeomFacetTuple));
		}
	};

	grid._trainFreeScale = function(geom, panel, property, scaleIndex, filterFunc) {
		var self = this;
		var trainedScalesAccessor = function(property, scaleIndex, value) {
			if (arguments.length < 2) scaleIndex = 0;
			if (!self._positionScales[property]) self._positionScales[property] = {};
			var scaleGroup = self._positionScales[property];
			if (!scaleGroup[scaleIndex]) scaleGroup[scaleIndex] = [];
			var positionScaleArr = scaleGroup[scaleIndex],
				index = (property.indexOf('x') >= 0) ? panel.columnIndex() : panel.rowIndex();

			if (arguments.length < 3) return positionScaleArr[index][scaleIndex];
			positionScaleArr[index][scaleIndex] = value;
			return value;
		};
		return this._trainScale(geom, trainedScalesAccessor, property, filterFunc);
	};

	grid._showAllPanelLabelsIfFree = function() {
		return false;
	};

	grid._configureFacets = function() {
		var xFacetTitle,
			yFacetTitle,
			xFacetKeys = this._xFacetScale.domain(),
			yFacetKeys = this._yFacetScale.domain(),
			facetKey;

		this._numColumns = Math.max(this._xFacetScale.domain().length, 1);
		this._numRows = Math.max(this._yFacetScale.domain().length, 1);

		var i = -1,
			r = this._numRows,
			facetIndex = 0;
		while (++i < r) {
			yFacetIndex = i;
			if (yFacetKeys && yFacetKeys.length > i) {
				yFacetTitle = yFacetKeys[i];
			}
			var j = -1,
				c = this._numColumns;
			while (++j < c) {
				xFacetIndex = j;
				if (xFacetKeys && xFacetKeys.length > j) {
					xFacetTitle = xFacetKeys[j];
				}
				facetKey = (yFacetKeys.length ? yFacetTitle : ".") + " ~ " + (xFacetKeys.length ? xFacetTitle : ".");

				var panel = dv.panel()
					.facetIndex(facetIndex++)
					.facetKey(facetKey)
					.columnIndex(xFacetIndex)
					.rowIndex(yFacetIndex)
					.xFacetTitle(xFacetTitle)
					.yFacetTitle(yFacetTitle)
					.facet(this);

				this._panels.push(panel);
				this._addToCollection(this._rows, yFacetIndex, panel);
				this._addToCollection(this._columns, xFacetIndex, panel);
			}
		}
	};

	grid._nestFacet = function(geom) {
		// Convert parallel arrays into objects
		var self = this,
			normalizedData = geom.normalizedData(),
			zipData = dv.util.filterAndZip(normalizedData),
			group = geom.getScale('group'),
			xFacetKeys = this._xFacetScale.domain(),
			yFacetKeys = this._yFacetScale.domain(),
			groupProperty,
			groupKeys;

		if (group) {
			groupProperty = group.property();
			groupKeys = groupProperty ? normalizedData[groupProperty] : null;
		}

		var i = -1,
			n = zipData.length;
		while (++i < n) {
			var data = zipData[i],
				yFacetIndex = 0,
				xFacetIndex = 0;

			if (data.data.hasOwnProperty(this._xGroup)) {
				xFacetIndex = xFacetKeys.indexOf(data.data[this._xGroup]);
				if (xFacetIndex < 0) xFacetIndex = 0;
			}

			if (data.data.hasOwnProperty(this._yGroup)) {
				yFacetIndex = yFacetKeys.indexOf(data.data[this._yGroup]);
				if (yFacetIndex < 0) yFacetIndex = 0;
			}

			panelIndex = (yFacetIndex * this._numColumns) + xFacetIndex;
			var panel = this._panels[panelIndex];
			data.panel = panel;
		}

		// The nest structure should be nested by facet and then group.
		return d3.nest()
			.key(function(d) {
				// facet ~ group
				var id = "";
				id += (d.data.hasOwnProperty(self._yGroup) ? d.data[self._yGroup] : ".") + " ~ ";
				id += (d.data.hasOwnProperty(self._xGroup) ? d.data[self._xGroup] : ".") + " ~ ";
				id += (d.hasOwnProperty(groupProperty) ? d[groupProperty] : ".");
				return id;
			})
			.sortKeys(function(a, b) { // Ensure sort order is maintained.
				var groupA = self._getGroupFromFacetKey(a),
					groupB = self._getGroupFromFacetKey(b),
					aIndex = -1,
					bIndex = -1;

				if (groupA !== ".") {
					aIndex = groupKeys.indexOf(groupA);
					if (aIndex < 0)
						aIndex = groupKeys.indexOf(Number(groupA));
				}

				if (groupB !== ".") {
					bIndex = groupKeys.indexOf(groupB);
					if (bIndex < 0)
						bIndex = groupKeys.indexOf(Number(groupB));
				}

				return bIndex < aIndex ? 1 : -1;
			})
			.entries(zipData);
	};

	grid._getGroupFromFacetKey = function(facetKey) {
		return (/.* ~ .* ~ (.*)/g).exec(facetKey)[1];
	};

	grid._getFacetFromFacetKey = function(facetKey) {
		return (/(.* ~ .*) ~ .*/g).exec(facetKey)[1];
	};

	grid._ensureColumnsAndRows = function() {
		return [this._numColumns, this._numRows];
	};

	grid._adjustPlotBounds = function(cols, rows) {
		var height = this._measureTitles(this._xFacetScale.domain(), "temp-column-titles", this._chart._g) + 3,
			width = this._measureTitles(this._yFacetScale.domain(), "temp-row-titles", this._chart._g) + 3,
			plotBounds = this._chart._plotBounds;

		this._xTitleHeight = height;
		this._yTitleWidth = width;

		this._chart._plotBounds.top += height;
		this._chart._plotBounds.right -= width;
	};

	grid._measureTitles = function(titleValues, containerSelector, parent) {
		var titles = this._createTitlesContainer(containerSelector, this._chart._g);
		var panelTitle = titles.selectAll(".panel-title").data(titleValues);
		panelTitle.enter()
			.append("text")
				.text(function(d, i) { return d; });

		var titlesBBox = titles.node().getBBox();

		// clean up
		titles.remove();
		return titlesBBox.height;
	};

	grid._createTitlesContainer = function(selector, d3Parent) {
		var titles = d3Parent.selectAll("." + selector).data([0]);
		titles.enter().append("g").classed(selector, true);
		titles.exit().remove();
		return titles;
	};

	grid._configurePanels = function(cols, rows) {
		var plotBounds = this._chart._plotBounds,
			plotWidth = plotBounds.right - plotBounds.left,
			plotHeight = plotBounds.bottom - plotBounds.top,
			facetWidth = (plotWidth - ((cols - 1) * this._hGap)) / cols,
			facetHeight = (plotHeight - ((rows - 1) * this._vGap)) / rows,
			xCursor = 0,
			yCursor = 0,
			colCursor = 0;

		var i = -1,
			n = this._panels.length;
		while (++i < n) {
			var panel = this._panels[i],
				xFacetScale = dv.facet.scale().innerScaleGroup(panel._trainedScales.x),
				yFacetScale = dv.facet.scale().innerScaleGroup(panel._trainedScales.y),
				panelBounds = {
					left: 0,
					top: 0,
					right: 0 + facetWidth,
					bottom: 0 + facetHeight,
					width: facetWidth,
					height: facetHeight
				};

			this._panels[i]
				.xOuterScale(xFacetScale)
				.yOuterScale(yFacetScale)
				.bounds(panelBounds);

			xCursor += facetWidth + this._hGap;
			colCursor++;

			if (colCursor >= cols) {
				xCursor = 0;
				yCursor += facetHeight + this._vGap;
				colCursor = 0;
			}
		}
	};

	grid._drawPanel = function(self, d, i, plotBounds, maxMargins, facetWidth, facetHeight, cols, rows, cursor) {
		var colIndex = d.columnIndex(),
			rowIndex = d.rowIndex(),
			maxMarginRow = maxMargins.rows[rowIndex],
			maxMarginCol = maxMargins.cols[colIndex];

		cursor.x += maxMarginCol.left;

		if (colIndex === 0) {
			cursor.x += plotBounds.left;
		}

		if (rowIndex === 0) {
			var xTitle = (self._titleFormat ? self._titleFormat.call(this, d.xFacetTitle(), i) : d.xFacetTitle());

			cursor.y = maxMarginRow.top + plotBounds.top;
			self._updatePanelTitle.call(this, self, xTitle, "top", cursor.x, cursor.y - self._xTitleHeight, facetWidth, facetHeight);
		}
		else {
			self._removePanelTitle.call(this, "top");
		}

		if (colIndex === self._numColumns - 1) {
			var yTitle = (self._titleFormat ? self._titleFormat.call(this, d.yFacetTitle(), i) : d.yFacetTitle());

			self._updatePanelTitle.call(this, self, yTitle, "right", cursor.x + self._yTitleWidth, cursor.y, facetWidth, facetHeight);
		}
		else {
			self._removePanelTitle.call(this, "right");
		}

		d.bounds({
			width: facetWidth,
			height: facetHeight,
			top: cursor.y,
			left: cursor.x,
			right: cursor.x + facetWidth,
			bottom: cursor.y + facetHeight
		});

		self._updatePanelBackground.call(this, self, cursor.x, cursor.y, facetWidth, facetHeight);

		cursor.x += facetWidth + maxMarginCol.right + self._hGap;
		if (colIndex === self._numColumns - 1) {
			cursor.x = 0;
			cursor.y += maxMarginRow.top + facetHeight + maxMarginRow.bottom + self._vGap;
		}
	};

	grid.xGroup = function(val) {
		if (!arguments.length) return this._xGroup;
		this._xGroup = val;
		return this;
	};

	grid.yGroup = function(val) {
		if (!arguments.length) return this._yGroup;
		this._yGroup = val;
		return this;
	};

	grid.aggregate = function(val) {
		if (!arguments.length) return this._aggregate;
		this._aggregate = val;
		return this;
	};

	return grid;
});
dv.chart = dv.container.extend(function() {
	function chart() {
		this._super();

		this._firstRender = false;

		this._data = {};
		this._coord = dv.coord.cartesian();
		this._facet = dv.facet.wrap().chart(this);
		this._layers = []; // Child layers which create different plots and layer them on top of each other.
		this._behaviors = []; // Interactions
		this._legends = dv.guide.legends();
		this._axes = dv.guide.axes()._chart(this);

		// Animation properties
		this._delay = d3.functor(0);
		this._duration = d3.functor(1000);
		this._ease = "cubic-in-out";

		// SVG containers
		this._parent = null;
		this._chartContainer = null;
		this._svgContainer = null;
		this._g = null;
		this._axisLabelContainer = null;
		this._panelContainer = null;
		this._interactionGroup = null;

		this._prerenderFunc = null;
		this._postrenderFunc = null;

		this._clipPlot = false;

		this._width = NaN;
		this._height = NaN;
		this._plotWidth = NaN;
		this._plotHeight = NaN;
		this._calcWidth = NaN;
		this._calcHeight = NaN;
		this._calcPlotWidth = NaN;
		this._calcPlotHeight = NaN;
		this._defaultPadding = this._padding = this._plotBounds = this._guidesBounds = {"top": 0, "left": 0, "right": 0, "bottom": 0};
		this._position = 'identity';
	}

	chart.render = function() {
		// Throws an error if no data is specified
		if (dv.util.isUndefined(this._data) || dv.util.isEmpty(this._data)) {
			for(var i = 0; i < this._layers.length; i++) {
				if (dv.util.isUndefined(this._layers[i]._data) || dv.util.isEmpty(this._layers[i]._data))
					dv.log.error({msg: "Cannot render a chart with no data provided.", data: { chartData: this._data, geom: this._layers[i] }});
			}
		}

		this._resolvePercentDimensions();
		this._createChartContainer();
		this._prerender();
		this._renderLegends();
		if (this._prerenderFunc) this._prerenderFunc.call(this);
		this._facet._render();
		if (this._postrenderFunc) this._postrenderFunc.call(this);
		this._renderBehaviors();
		this._clipGeoms();
		this._cleanupGuides();

		// Clean up our unregister event map. All chart events should have been elimintated by now.
		this.unregisterEventMap = null;
		return this;
	};

	chart._resolvePercentDimensions = function() {
		// We follow a progression for resolving dimension, 1) chart  2) plot  3) parent
		// Get the actual value from the percentages (if percents were given) for chart width/height
		this._calcWidth = dv.util.getPercentValue(this._width, this._parent.node().offsetWidth);
		this._calcHeight = dv.util.getPercentValue(this._height, this._parent.node().offsetHeight);

		// If width is still undefined we resolve plotWidth percents based on the parent, otherwise we resolve off of chart width
		if (!dv.util.isFinite(this._calcWidth)) {
			this._calcPlotWidth = dv.util.getPercentValue(this._plotWidth, this._parent.node().offsetWidth);
			// If plotWidth is still undefined then we set the chart width to be whatever the parent DOM el width is (last resort)
			if (!dv.util.isFinite(this._calcPlotWidth)) this._calcWidth = this._parent.node().offsetWidth;
		} else {
			this._calcPlotWidth = dv.util.getPercentValue(this._plotWidth, this._calcWidth);
		}

		// If height is still undefined we resolve plotHeight percents based on the parent, otherwise we resolve off of chart height
		if (!dv.util.isFinite(this._calcHeight)) {
			this._calcPlotHeight = dv.util.getPercentValue(this._plotHeight, this._parent.node().offsetHeight);
			// If plotHeight is still undefined then we set the chart height to be whatever the parent DOM el height is (last resort)
			if (!dv.util.isFinite(this._calcPlotHeight)) this._calcHeight = this._parent.node().offsetHeight;
		} else {
			this._calcPlotHeight = dv.util.getPercentValue(this._plotHeight, this._calcHeight);
		}
	};

	chart._finalizePlotBounds = function() {
		var legendAreaRemaining = this._legends._allowedDimensions(),
			lWidth = this._legends._getWidth(),
			lHeight = this._legends._getHeight(),
			b = {
				left: Math.max(legendAreaRemaining.left, this._padding.left),
				top: Math.max(legendAreaRemaining.top, this._padding.top)
			};

		// If chart width is undefined we set it based on the plotWidth + legend width + padding
		// If plot width is undefined we set it based on chartWidth - legend width - padding
		// Because of _resolvePercentDimensions we are certain that at least one of these widths is previously set
		if (!dv.util.isFinite(this._calcWidth)) {
			this._calcWidth = this._calcPlotWidth + lWidth + this._padding.left + this._padding.right;
		} else if (!dv.util.isFinite(this._calcPlotWidth)) {
			this._calcPlotWidth = this._calcWidth - this._padding.left - this._padding.right - lWidth;
		}
		// If chart height is undefined we set it based on the plotHeight + legend height + padding
		// If plot width is undefined we set it based on chartHeight - legend height - padding
		// Because of _resolvePercentDimensions we are certain that at least one of these heights is previously set
		if (!dv.util.isFinite(this._calcHeight)) {
			this._calcHeight = this._calcPlotHeight + lHeight + this._padding.top + this._padding.bottom;
		} else if (!dv.util.isFinite(this._calcPlotHeight)) {
			this._calcPlotHeight = this._calcHeight - this._padding.top - this._padding.bottom - lHeight;
		}

		// Sanity check to ensure that the plotWidth/Height is never greater than the chart width/height
		this._calcPlotWidth = Math.min(this._calcPlotWidth, this._calcWidth - this._padding.left - this._padding.right - lWidth);
		this._calcPlotHeight = Math.min(this._calcPlotHeight, this._calcHeight - this._padding.top - this._padding.bottom - lHeight);

		b.right = b.left + this._calcPlotWidth;
		b.bottom = b.top + this._calcPlotHeight;

		this.plotBounds(b);

		if (this._coord instanceof dv.coord.cartesian) {
			this._plotBounds.right -= this._coord.endX();
			this._plotBounds.left += this._coord.startX();
		}

		this._chartContainer
			.style("width", this._calcWidth + "px")
			.style("height", this._calcHeight + "px");
	};

	chart._prerender = function() {
		this._trainedScales = {}; // Unioned domains and plotting ranges for all properties (accessible by all geoms in the chart)
		this._calculateStats();

		this._facet._prerender();

		var _normalizedData = this._normalizeData(this.data());
		this.data(_normalizedData);

		// By default DV renders both axes
		if(!this._axes._get('x')) this._axes._add('x', dv.guide.axis());
		if(!this._axes._get('y')) this._axes._add('y', dv.guide.axis());
	};

	chart._createChartContainer = function() {
		this._chartContainer = this._parent.selectAll('.dv-chart-container').data([0]);
		this._chartContainer.enter()
			.append("div").classed("dv-chart-container", true);

		this._svgContainer = this._chartContainer.selectAll('svg').data([0]);

		this._svgContainer.enter()
			.append("svg")
			.style("height", "100%")
			.style("width", "100%");

		this._g = this._svgContainer.select('.group');

		// Only create our scaffolding if we don't have a <g class="group" /> element under the root SVG node.
		// Otherwise, we'll use what we already have.
		if (this._g.empty()) {
			this._firstRender = true;

			this._g = this._svgContainer
				.append('g')
					.classed('group', true);

			this._panelContainer = this._g.append('g').classed('panels', true);
			this._interactionGroup = this._g.append('g').classed("interaction-group", true);
			this._g.append('g').classed('behavior-under-geom', true);
			this._g.append('g').classed('plot', true);
			this._g.append('g').classed('behavior', true);
			this._g.append('g').classed('legends', true);

			this._interactionGroup.append('rect').classed('interaction-canvas', true).classed('background', true);
		}

		if (!this._panelContainer) {
			this._panelContainer = this._g.select('.panels');
		}

		if (!this._interactionGroup) {
			this._interactionGroup = this._g.select('.interaction-group');
		}

		this._axisLabelContainer = this._chartContainer.selectAll(".axes-labels").data([0]);
		this._axisLabelContainer.enter().append("div").classed("axes-labels", true);
	};

	chart._addRegisteredEvents = function() {
		var self = this;
		dv.util.each(self.eventMap, function(e, type) {
			self._interactionGroup.on(type, function() { // intercept the event and add our own parameters...
					var e = d3.event,
						interactionGroup = self._interactionGroup.node();
					if (self._shouldDispatchChartEvent(e, interactionGroup)) {
						self.eventMap[type].callback.call(self._interactionGroup.node(), d3.event);
					}
				}, e.capture);
		});

		// Forward this event on to the geoms
		dv.util.each(self._layers, function(geom) {
			geom._addRegisteredEvents();
		});
	};

	chart._removeRegisteredEvents = function() {
		var self = this;
		dv.util.each(self.unregisterEventMap, function(capture, type) {
			if (self._interactionGroup) {
				self._interactionGroup.on(type, null, capture);
			}
		});

		// Forward this event on to the geoms
		dv.util.each(self._layers, function(geom) {
			geom._removeRegisteredEvents();
		});
	};

	chart._shouldDispatchChartEvent = function(e, interactionGroup) {
		var result = true;

		// Our chart shouldn't dispatch mouse out events when rolling over geoms contained within the plot.
		if (e.type === "mouseout" || e.type === "mouseover") {
			var relTarget = d3.select(e.relatedTarget);
			if (relTarget && !relTarget.empty()) {
				var className = relTarget.attr('class');
				result = !(className && className.indexOf('-geom') >= 0);
			}
		}
		return result;
	};

	chart._calculateStats = function() {
	};

	chart._renderLegends = function() {
		// Calculate the max width and height allowed, we only account for the plot dimensions if they've been specified as real values by the user
		var width = (dv.util.isFinite(this._calcWidth) ? this._calcWidth  - this._padding.left - this._padding.right: this._calcPlotWidth),
			height = (dv.util.isFinite(this._calcHeight) ? this._calcHeight - this._padding.top - this._padding.bottom: this._calcPlotHeight),
			allowedDimensions = {
				left: this._padding.left,
				top: this._padding.top,
				width: width,
				height: height
			},
			chartOpts = {
				el: this._g,
				scales: this._facet._globalScales,
				firstRender: this._firstRender,
				duration: this._duration,
				delay: this._delay,
				ease: this._ease
			};

		this._legends._allowedDimensions(allowedDimensions)._render(chartOpts);
		this._finalizePlotBounds();
	};

	chart._cleanupGuides = function() {
		this._legends._empty();
		this._axes._empty();
	};

	chart._setRanges = function() {
		var bounds = this.plotBounds(),
			yScale = this.getTrainedScale('y'),
			xScale = this.getTrainedScale('x');

		// TODO: Just take a look and see if we can't avoid doing this multiple times
		var xRange = this.coord().flip() ? [bounds.bottom - bounds.top, 0] : [0, bounds.right - bounds.left],
			yRange = this.coord().flip() ? [0, bounds.right - bounds.left] : [bounds.bottom - bounds.top, 0];
		dv.util.scaleRange(xScale, xRange);
		dv.util.scaleRange(yScale, yRange);
	};

	chart.plotBounds = function(val) {
		if (!arguments.length) return this._plotBounds;
		this._plotBounds = val;
		return this;
	};

	chart._renderBehaviors = function() {
		var panel = this._facet.getPanel(0),
			bounds = panel._bounds,
			behaviorContainer = this._g.select('.behavior')
				.attr('transform', 'translate(0,0)'),
			behaviorUnderGeomContainer = this._g.select('.behavior-under-geom')
				.attr('transform', 'translate(0, 0)');

		this._interactionGroup.attr('transform', 'translate(0,0)')
			.select('.interaction-canvas')
				.attr('visibility', 'hidden')
				.attr('width', bounds.right - bounds.left)
				.attr('height', bounds.bottom - bounds.top)
				.attr('x', bounds.left)
				.attr('y', bounds.top);

		var self = this;
		dv.util.each(this._behaviors, function(behavior) {
			if (behavior.underGeoms && behavior.underGeoms()) {
				behavior.chart(self)._render(behaviorUnderGeomContainer);
			} else {
				behavior.chart(self)._render(behaviorContainer);
			}
		});
	};

	chart.guide = function(property, guide, scaleIndex) {
		// check to make sure we have a valid property argument
		if (!property || property === "") throw new Error("Property argument cannot be null or empty");
		if (property === "all") {
			if(guide !== "none") throw new Error("'all' can only be used to set all guides to 'none' (e.g. turn off all guides)");
			this._legends._hide(true);
			this._axes._add('x', "none", 0);
			this._axes._add('y', "none", 0);
		}

		// if property arg isn't already in an array we want to wrap it to make life easier
		property = dv.util.isArray(property) ? property : [property];
		scaleIndex = dv.util.isUndefined(scaleIndex) ? 0 : scaleIndex;

		var baseLegend = dv.guide.legend(),
			type = "";

		// for each property we store a reference to the guide for rendering later
		for(var i = 0; i < property.length; i++) {
			var g = guide,
				isPositional = this._isPositionProperty(property[i]);
			// we check the type of the first property to insure positional and non positional guides aren't mixed (except for custom legends)
			if (!type) type = isPositional ? "axis" : "legend";
			else if (isPositional && type != "axis") throw new Error("Cannot mix positional and non-positional guide types");
			// if no guide was given then we use the defaults
			if (!g) {
				g = isPositional ? dv.guide.axis() : baseLegend;
			} else if (!this._isValidGuideType(property[i], g) && dv.util.isObject(g)) {
				// wrap custom objects as dv.guide.custom
				g = this._buildCustomGuide(g);
			}
			if (this._isValidGuideType(property[i], g)) {
				if (g !== "none") {
					g.scaleIndex(scaleIndex);
				}
				if (isPositional) {
					this._axes._add(property[i], g, scaleIndex);
				}
				else {
					if (g !== "none") {
						this._legends._add({props: property, guide: g});
						// TODO: this breaks the case of trying to handle .guide(["stroke", "x"]), an error should be thrown in this case
						break;
					} else {
						this._legends._remove(property);
					}
				}
			}
		}
		return this;
	};

	chart._isPositionProperty = function(property) {
		return (property === 'x' || property === 'y');
	};

	chart._isValidGuideType = function(property, guide) {
		var isPosProp = this._isPositionProperty(property);
		return guide && (guide === "none" || guide instanceof dv.guide.custom) ||
			(isPosProp && guide instanceof dv.guide.axis) ||
			(!isPosProp && guide instanceof dv.guide.legend);
	};

	chart._buildCustomGuide = function(config) {
		var g = dv.guide.custom();
		for (var funcName in config) {
			g.setFunc(funcName, config[funcName]);
		}
		return g;
	};

	chart.getScale = function(property, scaleIndex) {
		if (arguments.length < 2) scaleIndex = 0;
		if (property === 'group') return this._getGroup();
		if (this._aes.hasOwnProperty(property)) return this._aes[property][scaleIndex];
	};

	chart._getGroup = function() {
		// If a group has been explicitly defined, we're done.
		if (this._aes.hasOwnProperty('group')) return this._aes.group[0];

		// Otherwise, let's look for a categorical aesthetic which can serve as a grouping element.
		var i = -1,
			len = dv.DEFAULT_CATEGORICAL_AES.length - 1;

		while (i++ < len) {
			var catAesGroup = this._aes[dv.DEFAULT_CATEGORICAL_AES[i]];
			// If the scale has a mapping (not a dv.scale.constant scale), we'll use it.
			if (catAesGroup &&
					catAesGroup[0] &&
					catAesGroup[0] instanceof dv.scale.ordinal &&
					!dv.util.isUndefined(catAesGroup[0].mapping())) {
				return catAesGroup[0];
			}
		}
		return null;
	};

	chart._clipGeoms = function() {
		var self = this;

		var clipDefs = this._parent.selectAll(".panel").selectAll("defs").data(function(d) {
			return self._clipPlot ? [d] : [];
		});
		clipDefs.enter().append("defs");
		clipDefs.exit().remove();

		var clippaths = clipDefs.selectAll("clipPath").data(function(d) { return [d]; });
		clippaths.enter().append("clipPath").classed("dv-clip", true);
		clippaths.exit().remove();
		clippaths.attr("id", function(d) { return "dv-clip" + d._facetIndex; });

		var clipRects = clippaths.selectAll("rect").data(function(d) { return [d]; });
		clipRects.enter().append("rect");
		clipRects.exit().remove();
		clipRects
			.attr("x", function(d) {
				return d._bounds.left;
			})
			.attr("y", function(d) { return d._bounds.top; })
			.attr("width", function(d) { return d._bounds.width; })
			.attr("height", function(d) { return d._bounds.height; });

		if (self._clipPlot) {
			var geomSeries = this._parent.selectAll(".series");
			geomSeries.attr("clip-path", function(d) {
				var val = d.values[0],
					panel = dv.util.isArray(val) ? val[0].panel : val.panel;
				return "url(#dv-clip" + panel._facetIndex + ")";
			});
		}
	};

	// GETTERS / SETTERS

	// Returns a specific trained scale based on the required prop ('x', 'y', 'alpha', 'fill', 'stroke', etc)
	chart.getTrainedScale = function(prop) {
		return this._facet.getTrainedScale(prop);
	};

	chart.getExplicitScale = function(property, scaleIndex) {
		if (scaleIndex === undefined) scaleIndex = 0;
		return this._aes[property][scaleIndex];
	};

	chart.parent = function(val) {
		if (!arguments.length) return this._parent ? this._parent.node() : null;
		this._parent = d3.select(val);
		if (this._parent.empty()) throw new Error("The DV parent element was not found.");
		return this;
	};

	chart.layers = function(val) {
		if (!arguments.length) return this._layers;
		this._layers = val;
		return this;
	};

	chart.behaviors = function(val) {
		if (!arguments.length) return this._behaviors;
		this._behaviors = val;
		return this;
	};

	chart.data = function(val) {
		if (!arguments.length) return this._data;
		this._data = val;
		return this;
	};

	chart.coord = function(val) {
		if (!arguments.length) return this._coord;
		this._coord = val;
		return this;
	};

	chart.facet = function(val) {
		if (!arguments.length) return this._facet;
		this._facet = val;
		this._facet.chart(this);
		return this;
	};

	chart.getPlotBounds = function(val) {
		return this._plotBounds;
	};

	chart.plotWidth = function(val) {
		if (!arguments.length) return this._plotWidth;
		this._plotWidth = val;
		return this;
	};

	chart.plotHeight = function(val) {
		if (!arguments.length) return this._plotHeight;
		this._plotHeight = val;
		return this;
	};

	chart.width = function(val) {
		if (!arguments.length) return this._width;
		this._width = val;
		return this;
	};

	chart.height = function(val) {
		if (!arguments.length) return this._height;
		this._height = val;
		return this;
	};

	chart.padding = function(val) {
		if (!arguments.length) return this._padding;
		this._padding = dv.util.merge(this._defaultPadding, val);
		return this;
	};

	chart.prerender = function(val) {
		if (!arguments.length) return this._prerenderFunc;
		this._prerenderFunc = val;
		return this;
	};

	chart.postrender = function(val) {
		if (!arguments.length) return this._postrenderFunc;
		this._postrenderFunc = val;
		return this;
	};

	chart.clipPlot = function(val) {
		if (!arguments.length) return this._clipPlot;
		this._clipPlot = val;
		return this;
	};

	return chart;
});
})();
/*
 * ************************************************************************
 *
 *  ADOBE CONFIDENTIAL
 *  ___________________
 *
 *   (c) Copyright 2012 Adobe Systems Incorporated
 *   All Rights Reserved.
 *
 *  NOTICE:  All information contained herein is, and remains
 *  the property of Adobe Systems Incorporated and its suppliers,
 *  if any.  The intellectual and technical concepts contained
 *  herein are proprietary to Adobe Systems Incorporated and its
 *  suppliers and may be covered by U.S. and Foreign Patents,
 *  patents in process, and are protected by trade secret or copyright law.
 *  Dissemination of this information or reproduction of this material
 *  is strictly forbidden unless prior written permission is obtained
 *  from Adobe Systems Incorporated.
 * ************************************************************************
 */

/*
 * rs2dv - v2.0.1 - 2014-02-26 (60e9405)
 * Copyright (c) 2014 Adobe Systems, Inc. All Rights Reserved.
 */

/**
 * Parses Reporting Services data into parallel arrays
 * that can be used as mappings/settings in DV.
 * Options can be specified to limit data that is returned.
 * The returned object (dvd) is made up of the following parallel arrays:
 * - value: count / size / value for that index
 * - date: date object for the value, these can all be the same or be over a range
 * - category: filter name
 * - label: metric name
 * - groups: array of facet names for the filter
 * - metric_series: unique identifier for data set ignoring filter ( metric_series_name + ':m' + metric ref id )
 * - metric_series_name: human readable identifier for data set (data store + metric name)
 * - series: unique identifier for the data set ( series_name + ':m' + metric ref id + 'f' + filter ref id )
 * - series_name: human readable identifier for the data set (filter name + metric name + data store)
 * It also includes arrays that aren't directly given to DV but can be used to munge data
 * - cell: reference to the actual data cell (3-dim data) in data
 * - filter: filter obj
 * - metric: metric obj
 * - facets: array of facet obj
 **/
(function(global) {
    'use strict';

    function rs2dv(rsdata, opts){

        // Handle calling new rs2dv
        if (this instanceof rs2dv) {
            return this;
        }

        var options = opts || {}, i = 0, filterMax = options.displayCount || -1,
            showNone = options.showNone, dvd = {}, dvalue = (dvd.value = []),
            dorigValue = (dvd.origValue = []), dlowerBound = (dvd.lowerBound = []), dupperBound = (dvd.upperBound = []),
            dseries = (dvd.series = []), dseriesname = (dvd.series_name = []),
            dmetricseries = (dvd.metric_series = []), dmetricseriesname = (dvd.metric_series_name = []),
            ddate = (dvd.date = []),
            dcategory = (dvd.category = []), dlabel = (dvd.label = []),
            dgroups = (dvd.groups = []), dfacets = (dvd.facets = []),
            dcell = (dvd.cell = []), dfilter = (dvd.filter = []),
            showMetrics = options.showMetrics || false, dmetric = (dvd.metric = []);

        var	filter_ref, date_ref, cell,
            metric, filter, f_name, m_name, date, s_name,
            m, mm, f, ff, d, dd, series_name,
            c, cc, facet, facets, facet_names,
            multipleMetrics = rsdata.metrics.length > 1,
            multipleFilters = false, multipleDataStores = false;
        // Set multiple filters/datastores flags
        if (rsdata.filters.length > 1) {
            rsdata.filters.some(function(filter, i, filters){
                if (i > 0 && !multipleDataStores) {
                    multipleDataStores = (filter.data_store !== filters[i-1].data_store);
                }
                if (i > 0 && !multipleFilters) {
                    multipleFilters = ((filter.info && filter.info.name || '') !==
                        (filters[i-1].info && filters[i-1].info.name || ''));
                }
                return multipleFilters && multipleDataStores; // discovered both flags
            });
        }
        // The rs data can be any combination of metrics, filters and dates with associated data
        // So we need to break it up into arrays for each combination
        // The base of each combination will be the metric
        for (m = 0, mm = rsdata.metrics.length; m < mm; ++m) {
            metric = rsdata.metrics[m];
            m_name = (metric.name || metric.id || '') + ''; // force string
            filter_ref = metric.filter_ref; // get the filter(s) associated with the metric
            date_ref = metric.date_ref; // get the date range(s) associated with the metric
            // limit the number of filters per metric
            ff = (filterMax >= 0) ? Math.min(filterMax, filter_ref.length) : filter_ref.length; // max # of filters
            for (f = 0; f < ff; ++f) {
                filter = rsdata.filters[filter_ref[f]];
                if (!filter.facet_ref) { filter.facet_ref = []; } // handle no facets

                // populate facet array
                facets = [];
                facet_names = [];
                for (c=0, cc=filter.facet_ref.length; c<cc; ++c) {
                    facet = rsdata.facets[filter.facet_ref[c]];
                    facets.push(facet);
                    facet_names.push(facet.info && facet.info.name || '');
                }

                // hide undefined filters if the showNone option is set
                if ((filter.info && filter.info.id === 0) && !showNone) {
                    if (ff < filter_ref.length) { ++ff; } // still manage max filters but don't go out of bounds
                    continue;
                }

                f_name = (filter.info && filter.info.name || '') + ''; // force string
                s_name = filter.data_store_name || (filter.data_store && filter.data_store.replace('dms/', '') || '');
                for (d = 0, dd = date_ref.length; d < dd; ++d) {
                    date = rsdata.dates[date_ref[d]];
                    cell = rsdata.data[filter_ref[f]][date_ref[d]][m]; // three dimensional hash filter:date:metric

                    // When a transform is specified on the request, val will be the transformed value and
                    // orig_val will be the original, untransformed value.  When a transform fails, the
                    // status will be 'transform_error'. At that point, val will be essentially useless but
                    // orig_val will continue to be a valid, untransformed value.
                    dvalue[i] = ('invalid' === cell.status || 'transform_error' === cell.status || 'calc_error' === cell.status) ? undefined : (+cell.val || 0);
                    dorigValue[i] = 'invalid' === cell.status ? undefined : (+cell.orig_val || 0);

                    // These will be provided as a result of the anomaly transform. If there were any status problems,
                    // we'll reset to undefined rather than messing around with a bunk value.
                    dlowerBound[i] = ('invalid' === cell.status || 'transform_error' === cell.status) ? undefined : (+cell.lower_bound || 0);
                    dupperBound[i] = ('invalid' === cell.status || 'transform_error' === cell.status) ? undefined : (+cell.upper_bound || 0);

                    // Store the date
                    ddate[i] = new Date(date.val);
                    // Store the category name (filter name)
                    dcategory[i] = f_name;
                    // Store the metric name
                    dlabel[i] = m_name;

                    // Create two different series, each with a unique id and a label
                    // First series is a combination of metric/datastore
                    // This will be used for any chart that used the filter as the y axis (bar)
                    // In this series label, the metric will always be displayed and the datastore if they are different
                    // ex: MetricName -- same data store
                    // ex: DataStore   MetricName -- different data stores
                    dmetricseriesname[i] = ((multipleDataStores) ? s_name + '   ' : '') + m_name;
                    dmetricseries[i] = dmetricseriesname[i] + ':m' + metric.ref_id;

                    // Second series is a combination of filter/metric/datastore
                    // This will be used for most charts like trends or points
                    // In this series label, the filter is always displayed and the datastore if they are different
                    // The metric is added if the user forces it using the 'showMetrics' option or
                    // if there are multiple metrics or we only have one filter (usually both of these are true if one is)
                    // ex: FilterName
                    // ex: DataStore   FilterName
                    // ex: FilterName (MetricName)
                    // ex: DataStore   FilterName (MetricName)
                    series_name = [];
                    if (multipleDataStores) { series_name.push(s_name); }
                    if (dcategory[i].length) { series_name.push(dcategory[i]); } // always display filter name if available
                    dseriesname[i] = series_name.join('   ');

                    // Append metric name if necessary
                    if (dseriesname[i].length === 0) { dseriesname[i] = m_name; }
                    else if ((showMetrics || multipleMetrics || !multipleFilters) && m_name.length) {
                        dseriesname[i] += ' (' + m_name + ')';
                    }
                    dseries[i] = dseriesname[i] +':m' + metric.ref_id + 'f' + filter.ref_id;

                    // Handle any faceting by assigning to groups
                    dgroups[i] = facet_names;
                    // meta
                    dfilter[i] = filter;
                    dmetric[i] = metric;
                    dcell[i] = cell;
                    dfacets[i] = facets;
                    ++i;
                }
            }
        }
        return dvd;
    }

    // Hold onto previous rs2dv variable so it can be restored when calling noConflict().
    var previousRS2DV = global.rs2dv;
    rs2dv.noConflict = function() {
        global.rs2dv = previousRS2DV;
        return this;
    };

    // Backwards compatible convert defintion
    rs2dv.prototype.convert = function() {
        return rs2dv.apply(null, arguments);
    };

    // Handle different requires/loaders
    global.rs2dv = rs2dv; // always set global (this addresses an issue in CloudViz-all when using module.exports)
    if ('function' === typeof define && define.amd) {
        define(function() { return rs2dv; }); // amd
    }
    else if ('undefined' === typeof exports) { global.rs2dv = rs2dv; } // browser, explicit global
    else if ('object' !== typeof module || !module.exports) { exports.rs2dv = rs2dv; } // commonjs
    else { module.exports = rs2dv; } // node
}(this));

/*
 * ************************************************************************
 *
 *  ADOBE CONFIDENTIAL
 *  ___________________
 *
 *   (c) Copyright 2016 Adobe Systems, Inc.
 *   All Rights Reserved.
 *
 *  NOTICE:  All information contained herein is, and remains
 *  the property of Adobe Systems Incorporated and its suppliers,
 *  if any.  The intellectual and technical concepts contained
 *  herein are proprietary to Adobe Systems Incorporated and its
 *  suppliers and may be covered by U.S. and Foreign Patents,
 *  patents in process, and are protected by trade secret or copyright law.
 *  Dissemination of this information or reproduction of this material
 *  is strictly forbidden unless prior written permission is obtained
 *  from Adobe Systems Incorporated.
 * ************************************************************************
 */

/*
 * CloudViz - v3.7.0 - 2016-01-28
 * Copyright (c) 2016 Adobe Systems, Inc. All Rights Reserved.
 */

/**
 * CloudViz Core
 * Base object that provides common functionality we can use for all chart types.
 **/
(function(global) {
	'use strict';

	var cloudViz = {}, dv = global.dv || {}, d3 = global.d3 || {};
	var core = {};

	/**
	 * Contains all options the user has specified plus defaults. The attribute names are the option names are the
	 * option names and the values are the option values.
	 * @type {object}
	 * @private
	 */
	core._options = null;

	/**
	 * A hash of all active event types and callbacks that have already been registered via the `on` method. When
	 * events are removed, they are simply deleted from this hash.
	 *
	 * @typedef EventMap
	 * @type {Object.<string, function>}
	 * @private
	 */
	core._eventMap = {};

	/**
	 * Contains all options that have changed since the last time render() was called. The attribute names are the
	 * option names and the values are the option values.
	 *
	 * @type {object}
	 * @private
	 */
	core._changedOptions = null;

	core.init = function(options) {
		this._initDefaultOptions();
		this.setOptions(options);
		return this;
	};

	/**
	 * Initializes this._options with appropriate default options.
	 *
	 * @param {object} defaultsToMerge Any defaults from extending objects that should be merged into and override
	 * defaults of this object.
	 * @returns {object} Final default options.
	 * @private
	 */
	core._initDefaultOptions = function(defaultsToMerge) {
		var defaults = {
			dataAdapter: 'standard',
			data: null,
			height : null, // set height of the chart within the parent
			parent : null, // parent element in the DOM for the chart
			width : null, // set width of the chart within the parent,
			autoResize : false,
			locale : 'en-US',
			l10n: {}
		};

		if (defaultsToMerge) {
			this._mergeOptions(defaults, defaultsToMerge);
		}

		this._options = defaults;

		this._changedOptions = {};

		// At this point, consider all default options as "changed" options.
		for (var key in defaults) {
			this._changedOptions[key] = defaults[key];
		}

		return this._options;
	};

	/**
	 * Copies a configuration option to destination object using specific option copy rules.
	 * @param {object} dest An object where the configuration option will be copied to.
	 * @param {string} key The name of option being copied.
	 * @param {*} value The value of the option being copied.
	 */
	core._mergeOption = function(dest, name, value) {
		switch(name) {
			case 'mappings': // copy the mappings properties over, don't completely overwrite
			case 'formats': // copy the formats property over in the same way
			case 'scales':
				dest[name] = dest[name] || {}; // create mappings object if necessary
				this._mergeOptions(dest[name], value);
				break;
			default:
				dest[name] = value;
				break;
		}
		return dest;
	};

	/**
	 * Copies configuration options to one object to another using specific option copy rules.
	 *
	 * @param {object} dest An object where configuration options will be copied to.
	 * @param {object} origin An object where configuration options will be copied from.
	 * @returns {object} The dest object after options have been copied to it.
	 */
	core._mergeOptions = function(dest, source) {
		for (var key in source) {
			this._mergeOption(dest, key, source[key]);
		}
		return dest;
	};

	/**
	 * Truncates long label strings and adds ellipses
	 **/
	core._truncateLabel = function(label, thresh) {
		var max = thresh || this.X_AXIS_LABEL_MAXLENGTH;
		return (label.length > max) ? label.substring(0, max) + '...' : label;
	};

	/**
	 * Formats number `v` according to format `formatType` (currency, percent, decimal [default]).
	 * If decimalPlaces is specified, number abbreviation still occurs, but decimal precision is guaranteed.
	 */
	core._formatNumber = function(formatType, value, decimalPlaces) {
		var symbol = '', format, small,
			l10n = this._dataAdapter.l10n.numberFormat,
			pattern, formatted,
			precision;

		if (formatType == 'currency' || formatType == 'percent') {
			symbol = l10n[formatType].symbol;

			if (value >= 0) {
				pattern = l10n[formatType].positivePattern;
			} else {
				pattern = l10n[formatType].negativePattern;
			}
		} else {
			if (value >= 0) {
				pattern = '{number}';
			} else {
				pattern = l10n.negativePattern;
			}
		}

		if (formatType == 'percent') {
			value *= 100;
		}

		value = Math.abs(value);

		if (value >= 100) { precision = 3; }
		else if (value >= 10) { precision = (value % 1) ? 3 : 2; }
		else if (value >= 1) { precision = (value % 1) ? 3 : 1; }
		else { precision = (value % 1) ? 2 : 1; }

		// If decimalPlaces is specified, we force a precision on an SI Prefix number.
		if (decimalPlaces != null) {
			if (value >= 0.01 && value < 1) {
				formatted = d3.format('.' + decimalPlaces + 'f')(value);
			} else {
				var prefix = d3.formatPrefix(value);
				formatted = prefix.scale(value).toFixed(decimalPlaces) + prefix.symbol;
			}
		}
		// allow 1000 range to display normally
		else if (value >= 1000 && value < 10000) { formatted = d3.format(',.0f')(value); }
		else {
			var d3FormatStr = '.' + precision;
			if (value >= 0.01 && value < 1) {
				d3FormatStr += 'r';
			} else {
				d3FormatStr += 's'; // Add SI prefix units to the end.
			}
			formatted = d3.format(d3FormatStr)(value);
		}

		// CV-537: handle really small numbers by rounding up and denoting with '<' char
		if (decimalPlaces && value < Math.pow(10, -decimalPlaces) && value > 0) {
			small = true;
			formatted = Math.pow(10, -decimalPlaces) + '';
		}
		else if (decimalPlaces == null && value < 0.01 && value > 0) {
			small = true;
			formatted = '0.01';
		}
		format = pattern.replace(/\{number\}/i, formatted)
					.replace(/\{symbol\}/i, symbol)
					.replace(/,/g, l10n.groupSeparator)
					.replace(/\./, l10n.decimalSeparator);
		if (small) { format = '<' + format; }
		return format;
	};

	/**
	 * Return value for a key in mapping
	 **/
	core._getPropMapping = function(prop) {
		return this._dataAdapter.mappings()[prop];
	};

	/**
	 * Set option value
	 **/
	core.setOption = function(name, value) {
		// To keep things sanitary, don't allow setting any option for which a default is not provided.
		if (!(name in this._options)) {
			return false;
		}

		// backwards compatibility for RS
		if ('dataAdapter' === name && 'rs2dv' === value) {
			value = 'rs';
		}

		// backwards compatibility for 'clickHandler'
		if ('clickHandler' === name) {
			this.on('click', value);
		}

		this._mergeOption(this._options, name, value);

		// Should be created in initDefaultOptions, but just in case...
		if (!this._changedOptions) {
			this._changedOptions = {};
		}

		this._changedOptions[name] = value;
		return true;
	};

	/**
	 * Get option value
	 **/
	core.getOption = function(key) {
		var options = this._options;
		if (key in options) {
			return options[key];
		}
		return null;
	};

	/**
	 * Update the options for customizing the chart
	 **/
	core.setOptions = function(options) {
		// Update chart options
		for (var k in options) {
			this.setOption(k, options[k]);
		}
	};

	/**
	 * Called before each rendering occurs. Intended as a useful method to extend.
	 * @private
	 */
	core._preRender = function(){
		this._clearErrorMessage();

		if ('autoResize' in this._changedOptions) {
			this._updateWindowResize();
		}

		if ('dataAdapter' in this._changedOptions) {
			var dataAdapterOption = this._changedOptions['dataAdapter'];

			// create a data adapter if none already exists or if its different
			if (!this._dataAdapter || (this._options.dataAdapter !== dataAdapterOption)) {
				// dataAdapterOption will be a string like 'rs'. A matching data layer should have registered itself
				// on the cloudViz.dataAdapter object.
				var adapters = cloudViz.dataAdapter[dataAdapterOption];

				if (!adapters) {
					throw new Error('No data adapters were found for data adapter type ' + dataAdapterOption);
				}

				// Find the adapter for the current visualization type. If that doesn't exist, fall back to the base
				// adapter for the given data adapter option (e.g., rs's base adapter). If that doesn't exist, fall back
				// to the base, standard data adapter. These fallbacks can be legitimate where nothing special needs to
				// happen in the data adapter layer for a given chart type so no adapter was created for the chart type.
				var adapterConstructor = adapters[this._type] || adapters['base'] || cloudViz.dataAdapter.standard.base;
				this._dataAdapter = adapterConstructor();
			}
		}

		this._dataAdapter.process(this._options, this._changedOptions);
	};

	/**
	 * Performs rendering of the visualization. Intended to be extended.
	 * @private
	 */
	core._render = function(  ) {};

	/**
	 * Called after each rendering occurs. Intended as a useful method to extend.
	 * @private
	 */
	core._postRender = function(){
		this._changedOptions = {};
	};

	/**
	 * Renders the chart. This method generally should not be overridden. Instead, override one of the methods
	 * it calls. This method is merely used as a public method that drives pre-render, render, and post-render.
	 */
	core.render = function() {
		this.reset();
		this._preRender();
		this._render();
		this._postRender();
		return this;
	};

	/**
	 * Resets the chart instance.  Called on both render and destroy.  Intended to be extended.
	 **/
	core.reset = function() { };

	/**
	 * If the autoResize option is set to true, this will attach an appropriate handler to debounced window
	 * resize events. If it's set to false, it will remove any handler previously attached.
	 * @private
	 */
	core._updateWindowResize = function() {
		if (this._options.autoResize) {
			// Although native bind is supported in all browsers that CloudViz targets, PhantomJS which runs
			// our tests does not yet: https://github.com/ariya/phantomjs/issues/10522
			this._autoResizeHandler = this._autoResizeHandler || dv.util.bind(this._onAutoResize, this);
			cloudViz.windowResize.addHandler(this._autoResizeHandler);
		} else {
			// No errors will throw if _autoResizeHandler is null or the
			// handler wasn't previously added.
			cloudViz.windowResize.removeHandler(this._autoResizeHandler);
		}
	};

	/**
	 * If the autoResize option is set to true, this function will be called when the window is resized.
	 * @private
	 */
	core._onAutoResize = function() { /* Override me */ };

	core.RESPONSIVE_WIDTH_THRESHOLD = 400; // point at which we draw a small graph vs a large one
	/**
	 * If the autoResize option is set to true, this function will be called when the window is resized.
	 * @private
	 */
	core._isSmallChart = function(width) {
		return width < core.RESPONSIVE_WIDTH_THRESHOLD;
	};

	/**
	* Displays error message
	*/
	core.handleError = function(error){
		var l10n = this._dataAdapter.l10n;
		var clientMsg = l10n.labels.core.erroronrender;
		if ('invaliddata' === error.code) {
			clientMsg = l10n.labels.core.nodata;
		}
		this._setErrorMessage(clientMsg);
		return this;
	};

	/**
	 * Displays an error message to the user instead of the visualization.
	 * @param message The error message to display to the user.
	 * @private
	 */
	core._setErrorMessage = function(message) {
		if (message && message.length) {
			d3.select(this._options.parent).html('<div class="cv-error">' + message + '</div>');
		} else {
			this._clearErrorMessage();
		}
	};

	/**
	 * Removes the error message displayed to the user if one exists.
	 * @private
	 */
	core._clearErrorMessage = function() {
		// Although we could call .html('') on the parent selection, removing the cv-error div will allow for the case
		// where the chart has been rendered before this function is called
		d3.select(this._options.parent).select('.cv-error').remove();
	};

	/**
	 * Destroys the chart
	 **/
	core.destroy = function() {
		/* Override me */
		this.reset();
		// No errors will throw if _autoResizeHandler is null or the
		// handler wasn't previously added.
		cloudViz.windowResize.removeHandler(this._autoResizeHandler);
	};

	/**
	 * Adds or removes an event callback which will be called when an event of that type is dispatched by a chart.
	 * If callback is a function, the function will be called when an eventType is dispatched. If callback is null,
	 * a previously registered callback will no longer be dispatched when the event type is called.  CloudViz event
	 * types are registered by each chart.  Events are only dispatched if the chart is `interactive`.  See the
	 * documentation on which events are dispatched by each chart type.
	 *
	 * @param eventType {String} The event key that is used to determine which event should be dispatched
	 * @param callback {?function} A function which is called by a CloudViz chart type when an event matching
	 * eventType is dispatched. If null, a previously registered callback will be deleted which stops events from
	 * being received.
	 */
	core.on = function(eventType, callback) {
		var adding = callback && dv.util.isFunction(callback);
		if (adding) {
			this._eventMap = this._eventMap || {};
			this._eventMap[eventType] = callback;
		}
		else {
			if (this._eventMap) {
				delete this._eventMap[eventType];
			}
		}
		return this;
	};

	// this will allow all other components to hook into cloudViz
	global.cloudViz = cloudViz;
	// for module loaders, hook these dependencies here (for now)
	cloudViz.d3 = d3;
	cloudViz.dv = dv;
	cloudViz.rs2dv = global.rs2dv || {}; // this should probably go in dvcore

	cloudViz.core = core;

	/**
	 * Stores or retrieves a locale definition for a given locale id. If a key is supplied, the settings
	 * for that locale and key are overwritten by the supplied definition data.
	 *
	 * @param {string} locale Locale id composed of a ISO-639 language code and a ISO-3166 country code separated by
	 * an underscore (e.g., "en-US").
	 * @param {object} [definition] The locale definition object (e.g., date formatting, number formatting, currency).
	 * @returns {object} When no definition argument is passed, the definition object for the locale id will be returned.
	 */
	cloudViz.localeDefinition = function(locale, definition, key) {
		var localeDefs, cultureCodes, localeKeys, localeDef;

		// Case insensitive locales storage and retrieval.
		locale = locale.toLowerCase();
		cloudViz._localeDefinitions = localeDefs = cloudViz._localeDefinitions || {};
		if (arguments.length > 1) {
			cultureCodes = locale.split('-');
			if (cultureCodes.length <= 1) { // Must have a valid language culture name (separated with a hyphen)
				throw new Error('A registered CloudViz locale must be a hyphenated language culture code (e.g. en-US).');
			}
			// If a definition is "en-US", an external CV user can request the definition using an underscore separated
			// locale name (e.g. "en_US") or just a language code (e.g. "en").  The caveat with just using a language
			// code is that any subsequent language code definitions will override the first (e.g. adding a "en-US"
			// definition followed by a "en-BR" definition, then requesting an "en" locale will return the "en-BR"
			// definition.
			localeKeys = [ locale, cultureCodes[0], cultureCodes.join('_') ];
			localeKeys.forEach(function(localeKey) {
				if (key == null) {
					localeDefs[localeKey] = definition;
				} else {
					localeDefs[localeKey] = localeDefs[locale] || {};
					localeDefs[localeKey][key] = definition;
				}
			});
		} else {
			localeDef = localeDefs[locale];
			if (!localeDef) {
				throw new Error('Locale definition for ' + locale + ' not found.');
			}
			return localeDef;
		}
	};

	// Handle different requires/loaders
	if ('function' === typeof define && define.amd) {
		define(function() { return cloudViz; }); // amd
	}
	else if ('undefined' === typeof exports) { global.cloudViz = cloudViz; } // browser, explicit global
	else if ('object' !== typeof module || !module.exports) { exports.cloudViz = cloudViz; } // commonjs
	else { module.exports = cloudViz; } // node
}(this));

/*global cloudviz,d3,dv*/
(function(global) {
	'use strict';

	/**
	 * Series State is a finite state machine which keeps track of the state of series in CloudViz.  It has the
	 * ability to attach event callbacks which are triggered when certain events take place on a series.
	 *
	 * Events Dispatched:
	 * 'create' : dispatched when a series state object is newly created.
	 * 'remove' : dispatched when a series state object is removed from the state list.
	 * 'enableChanged' : dispatched when a series state object is enabled or disabled.
	 */
	global.cloudViz.seriesState = function() {

		var seriesState = {}, // instance

			states = [], // List of all SeriesState objects

			stateListeners = {}; // A dictionary of callbacks registered from external consumers

		/**
		 * Checks the series states to see if a particular series should be enabled.  The combination of the id
		 * of the series is used with the seriesType given to the legend entry to determine a unique match.
		 *
		 * @param {string} seriesId The id of an individual series that is unique across states matching
		 * seriesType
		 * @param {[string]} seriesType The type of state we are looking for
		 * @return {boolean} true if the series state has been registered, matches the inputs, and is enabled.
		 * False otherwise.
		 */
		seriesState.isSeriesEnabled = function(seriesId, seriesType) {
			if (!states) { return true; } // If we don't have any states, all series are enabled.

			var i,
				length = states.length,
				state;
			for (i = 0; i < length; i++) {
				state = states[i];
				if (state.id === seriesId && state.type === seriesType) {
					return state.enabled;
				}
			}
			return false;
		};

		/**
		 * Checks the state objects to see if a series state has already been registered.
		 * @param  {string} seriesId The id of an individual series that is unique across states matching
		 * seriesType
		 * @param  {string} seriesType The type of state we are looking for
		 * @return {boolean} true if the series state has been registered and match, false otherwise.
		 */
		seriesState.doesSeriesStateExist = function(seriesId, seriesType) {
			if (!states) { return false; }

			var i,
				length = states.length,
				state;
			for (i = 0; i < length; i++) {
				state = states[i];
				if (state.id === seriesId && state.type === seriesType) {
					return true;
				}
			}
			return false;
		};

		/**
		 * Creates and returns a state object
		 *
		 * @param  {string} label The label that will be displayed to represent the series
		 * @param  {string} id A unique identifier which identifies the series object
		 * @param  {string} stateType used to identify a group of state objects that are similar
		 * @param  {boolean} enabled true if the series is enabled, false otherwise
		 * @return {{name, id, type, enabled}} a built state object
		 */
		seriesState._createStateObject = function(label, id, stateType, enabled) {
			var newObj;
			if (arguments.length < 3) {
				throw new Error('A state object requires a label and stateType.');
			}
			if (arguments.length < 4) {
				enabled = true;
			}
			newObj = { name: label, id: id, type: stateType, enabled: enabled };
			this.dispatch('create', newObj);
			return newObj;
		};

		/**
		 * Inserts a new state object at the beginning of the other states.  The order for which states are
		 * created is important for legend rendering.
		 *
		 * @param  {string} label The label that will be displayed to represent the series
		 * @param  {string} id A unique identifier which identifies the series object
		 * @param  {string} stateType used to identify a group of state objects that are similar
		 * @param  {boolean} enabled true if the series is enabled, false otherwise
		 * @return {{name, id, type, enabled}} a built state object
		 */
		seriesState.insertState = function(label, id, stateType, enabled) {
			states.unshift(this._createStateObject.apply(this, arguments));
		};

		/**
		 * Adds a new state object behind the other states.  The order for which states are created is
		 * important for legend rendering.
		 *
		 * @param  {string} label The label that will be displayed to represent the series
		 * @param  {string} id A unique identifier which identifies the series object
		 * @param  {string} stateType used to identify a group of state objects that are similar
		 * @param  {boolean} enabled true if the series is enabled, false otherwise
		 * @return {{name, id, type, enabled}} a built state object
		 */
		seriesState.appendState = function(label, id, stateType, enabled) {
			states.push(this._createStateObject.apply(this, arguments));
		};

		/**
		 * Sets whether the series state is enabled (true) or disabled (false). When the state changes, an
		 * event is dispatched to let all concerned internal components be aware.
		 * @param  {uint} stateIndex The unique index for a state in the states array
		 * @param  {boolean} enabled true if the series should be enabled, false otherwise
		 */
		seriesState.enableStateByIndex = function(stateIndex, enabled) {
			if (stateIndex < states.length) {
				var state = states[stateIndex];
				if (state.enabled !== enabled) {
					state.enabled = enabled;
					this.dispatch('enableChange', state); // Let others know when enabled changes
				}
			}
		};

		seriesState.enableStateByTypeAndId = function(stateType, stateId, enabled) {
			var i,
				length = states.length,
				state;
			for (i = 0; i < length; i++) {
				state = states[i];
				if (state.id === stateId && state.type === stateType) {
					this.enableStateByIndex(i, enabled);
				}
			}
		};

		/**
		 * Removes all states from the state array if their type matches stateType.
		 *
		 * @param  {string} stateType used to identify a group of state objects that should be removed
		 */
		seriesState.removeStatesByType = function(stateType) {
			var self = this;
			if (states && states.length) {
				states = states.filter(function(d) {
					if (d.type === stateType) {
						self.dispatch('remove', d); // Let others know when a state is removed
						return false;
					}
					return true;
				});
			}
		};

		/**
		 * Adds a event listener which can register for different types of events dispatched by a
		 * SeriesState. Multiple event handlers of the same type can be registered by using dot notation
		 * ('enableChanged.foo' and 'enableChanged.bar').
		 *
		 * Supported event types are documented at the top of this class.
		 *
		 * @param  {string} eventType The type of event that when fired will call the specified function.
		 * Dot notation can be used to add multiple handlers of the same type.  e.g. 'enableChanged.foo'
		 * and 'enabledChanged.bar' will each be called while 'enableChanged.foobar' and
		 * 'enabledChanged.foobar' would only call the latter enabledChanged.foobar function as it would
		 * overwrite the first function.
		 * @param  {function(string, SeriesState)} func A function called when an event is dispatched.  If
		 * the function is null, the event listener is removed.
		 */
		seriesState.on = function(eventType, func) {
			if (arguments.length < 1) {
				throw new Error('series state listeners require an eventType to be specified.');
			}

			var i = eventType.indexOf("."), name = "", listeners;
			if (i > 0) {
				name = eventType.substring(i + 1);
				eventType = eventType.substring(0, i);
			}

			listeners = stateListeners[eventType] || {};

			// A null function removes the listener
			if (!func) {
				delete listeners[name];
			} else {
				listeners[name] = func;
				stateListeners[eventType] = listeners;
			}
		};

		/**
		 * Dispatches an event to all callbacks registered to a particular eventType.
		 *
		 * @param  {string} eventType The type of event that will be fired
		 * @param  {SeriesState} obj The SeriesState object which changed somehow
		 */
		seriesState.dispatch = function(eventType, obj) {
			var listeners = stateListeners[eventType];
			if (listeners) {
				// Each listener in a listeners group represents the second half of the dot notation for
				// events.  See seriesState.on().
				for (var listener in listeners) {
					listeners[listener].call(this, eventType, obj);
				}
			}
		};

		/**
		 * Returns a list of all state object in the order they were added.
		 *
		 * @return {[SeriesState]} An array of SeriesState objects.
		 */
		seriesState.getStateObjects = function() {
			return states;
		};

		/**
		 * Returns true if there are some series which are disabled and false otherwise.
		 *
		 * @return {boolean}
		 */
		seriesState.areSomeSeriesDisabled = function() {
			if (!states) { return false; }
			return (Math.min.apply(null, states.map(function(s){ return +s.enabled; })) === 0);
		};

		/**
		 * Returns true if all series are disabled and false otherwise.
		 *
		 * @return {boolean}
		 */
		seriesState.areAllSeriesDisabled = function() {
			if (!states) { return false; }
			return (Math.max.apply(null, states.map(function(s){ return +s.enabled; })) === 0);
		};

		return seriesState;
	};
})(this);
/**
 * Util
 * Utility functions that are generically usable (not specific to CloudViz). They are not intended to hold state or be
 * instantiated ("newed").
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {};
	var util = cloudViz.util = cloudViz.util || {};

	/**
	 * Copies all the properties in the source objects over to the destination object and returns
	 * the destination object.  It's in-order, so the last source will override properties of the
	 * same name in previous arguments. If any property in the source object is an object itself, the object
	 * will not replace the property on the destination. Instead, its nested properties will be copied over to the
	 * same nested location on the destination object. This occurs recursively.
	 *
	 * deepExtend({ foo: { bar: 'cloud', hello: 'world' }}, { foo: { bar: 'viz' }});
	 * => { foo: { bar: 'viz', hello: 'world' }}
	 *
	 * Based on http://andrewdupont.net/2009/08/28/deep-extending-objects-in-javascript/
	 *
	 * @param {object} dest
	 * @param {...object}
	 * @returns {object}
	 */
	util.deepExtend = function(dest) {
		var sources = Array.prototype.slice.call(arguments, 1);
		var i = -1,
			n = sources.length;
		while (++i < n) {
			var source = sources[i];
			if (source) {
				for (var prop in source) {
					if (source[prop] && source[prop].constructor && source[prop].constructor === Object) {
						dest[prop] = dest[prop] || {};
						util.deepExtend(dest[prop], source[prop]);
					} else {
						dest[prop] = source[prop];
					}
				}
			}
		}
		return dest;
	};

	/**
	 * Creates a constructor function. When called, the constructor will call init() on the new instance (if defined)
	 * with any arguments that are passed to the constructor function. The instance is then returned.
	 * @param {object} proto The object which should be used as the blueprint for new instances.
	 * @returns {Function}
	 */
	util.createConstructor = function(proto) {
		function init() {
			var instance = Object.create(proto);

			if ('function' == typeof instance.init) {
				instance.init.apply(instance, arguments);
			}

			return instance;
		}

		init.prototype = proto;

		return init;
	};

	/**
	 * Determines whether the object chain exists for a given namespace string and, if not, creates it. For example, if
	 * the namespace com.adobe.foo is provided (and no base is provided), it will look for a com attribute on the
	 * global variable. If it doesn't exist, will it create an empty object and assign it as the com attribute.
	 * It will then look for adobe attribute on global.com. If the attribute is not found, it will create
	 * an empty object and assign it as the adobe attribute on the com attribute, and so on.
	 *
	 * @param {string} namespace A string representing a namespace (e.g., com.adobe.foo)
	 * @param {object} [head] By default the namespace will be searched for on the global scope. If head is provided,
	 * the namespace will be searched for on it instead.
	 * @returns {object} The object at the tail of the namespace. Given com.adobe.foo, this would be the foo object.
	 */
	util.namespace = function(namespace, head) {
		var segments = namespace.split('.');
		var tail = head || global;
		segments.forEach(function(segment) {
			var current = tail[segment];

			if (!current) {
				current = tail[segment] = {};
			}

			tail = current;
		});
		return tail;
	};
}(this));
/**
 * CloudViz Core
 * Base object that provides common functionality across multiple DV-specific chart types (bar, line etc)
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, core = cloudViz.core || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		dvcore = Object.create(core);

	dvcore.X_AXIS_LABEL_MAXLENGTH = 25; // maximum length for a label on the x axis

	// Possible legend orientations.
	//
	// Bottom is not currently supported. If the user were to ask for an interactive legend with a bottom orientation,
	// the X axis would need to be at the top in order to look decent. However, even if a bottom orientation is
	// requested, we still do a check to see whether the legend item widths are too small for such an orientation.
	// If so, we would force the legend to be on the left to accommodate which would mean the X axis should be back at
	// the bottom. This check to see whether legend item widths are too small must occur late in the process after
	// dv has trained its scales at which point it's too late to change the X axis orientation back to the bottom.
	// Possible solutions include:
	// (1) When a particular legend orientation is requested, force that orientation regardless of whether
	// legend item widths are too small. Under this scenario, the legend position and therefore the X axis position
	// would be known up-front.
	// (2) Come up with a decent style for a bottom-oriented legend while keeping the X axis at the bottom as well.
	dvcore.LEGEND_ORIENTATIONS = ['top', 'right', 'left'];

	dvcore._chart = null; // DV chart
	dvcore.clipIdCounter = { // intentionally nested object so instances will share
		count : 0
	};
	dvcore._legend = null;
	dvcore._seriesState = null;

	dvcore.init = function(options) {
		Object.getPrototypeOf(dvcore).init.apply(this, arguments);
		this._seriesState = cloudViz.seriesState();
		return this;
	};

	dvcore._initDefaultOptions = function(defaultsToMerge) {
		var defaults = {
			aspectRatio : null, // defined aspect ratio of chart
			colors : [ // colors to use when displaying charts
				'#8cc350', // green
				'#5a6eaa', // iris
				'#d755a5', // fuchsia
				'#1ebed7', // cyan
				'#f0a01e', // tangerine
				'#9b8ce6', // periwinkle
				'#3cb5a0', // sea foam
				'#3287d2', // blue
				'#f0557d', // magenta
				'#c3d250', // chartreuse
				'#eb782d', // orange
				'#78b4f5', // sky blue
				'#5faf69', // kelly green
				'#aa5fa5', // plum
				'#fa5a50', // red
				'#f5c841' // yellow
			],
			dateGranularity : undefined, // The date granularity if the x data is time-based. Possible values are year, quarter, month, week, day, hour, minute, second. If undefined, DV will attempt to calculate a sensible granularity.
			flip : false, // flip the axis of the chart
			interactive : false, // allow user to interact with legend, use custom legend if true
			legendOrientation: null, // Allow the user to force legend positioning (top, right, bottom, left)
			legendVerticalWidth: 110, // The width the legend will take up when in interactive vertical layout.
			legendVisible: true, // If false, legends are not drawn and space is not allocated for them. If true, legends are drawn.
			targetValues: null, // An array of y intercept values for which a horizontal line is drawn across the chart for each target.
			targetLabel: undefined, // The name of the legend entry which represents the target values.
			mappings : { // base mappings for data (ex: rs2dv outputs parallel arrays in this format)

				// The value to be used along the x-axis
				// For a line/point chart, this usually equates to a range of dates/values
				// For a bar/donut chart, this usually equates to a number of categories
				x: 'x',
				// The value to be used along the y-axis
				y: 'y',
				// Unique group identifier which divides the data into separate series
				series: 'series', // ex: a12ds3
				// Human readable series name, normally the same as used by series
				// However, if your series names are more computed, this allows for a nicer name / localized name
				seriesLabel: 'series' // ex: 'Users'

			},
			plotHeight : null, // set height of the plot (doesn't affect legend) within the chart
			plotWidth : null, // set width of the plot within the chart
			preRender : null, // function that gets called right before render, passes dv chart obj
			xAxisTitle : '', // Label to be displayed on the x-axis
			yAxisTitle : '', // Label(s) to be display on the y-axis (string or 2-index array of strings)
			precision: null // Determines how many decimal points should exist after a number. If the value is undefined, CloudViz will use a default precision. This should be a positive number, but could lead to unexpected results if the desired amount of decimal places is really large.
		};

		if (defaultsToMerge) {
			this._mergeOptions(defaults, defaultsToMerge);
		}

		return Object.getPrototypeOf(dvcore)._initDefaultOptions.call(this, defaults);
	};

	/**
	 * Get the DV Chart
	 **/
	dvcore.getChart = function() {
		return this._chart;
	};

	/**
	 * External API method when enables or disables a series by index. If the index is invalid, nothing happens.
	 * If the index is valid, the series will be disabled and the legend entry (if it exists) and paths for the
	 * series will be grayed out.  The visualization may also rescale to focus on the other enabled series.
	 *
	 * @param  {uint} index The index of a state in the order it was created.
	 * @param  {boolean} enabled true if the series should be enabled, false otherwise.
	 */
	dvcore.enableSeriesByIndex = function(index, enabled) {
		this._seriesState.enableStateByIndex(index, enabled);
	};

    /**
     * Use to highlight or remove the highlight of a selection
     *
     * @param selection The d3 selection to be highlighted
     * @param enabled true will highlight the selection, false will reset it
     * @private
     */
    dvcore._highlight = function(selection, enabled) {
        selection.classed('cv-highlight', enabled);
    };

	dvcore._getYTitleFromLabels = function(labels) {
		// If we only have 1 type of label, we should label the y axis.  This is particularly
		// important in the case of interactive legends which don't show the metrics within tabs
		// because there is only one metric.  In this case there would be no way to know what
		// metric is represented by the y axis.  The y axis title is the only way to get that
		// info.
		var uniqLabels = dv.util.uniq(labels);
		if (uniqLabels && uniqLabels.length === 1) {
			return uniqLabels[0];
		}
		return null;
	};

	dvcore._preRender = function() {
		Object.getPrototypeOf(dvcore)._preRender.call(this);
		try {
			// TODO: Have data adapters validate their data independently and kick
			// a valid flag back to core
			this._createSeriesStates();
		} catch(e) {
			var error = new Error('The chart data is invalid');
			error.code = 'invaliddata';
			this.handleError(error);
		}
	};

	dvcore._postRender = function() {
		Object.getPrototypeOf(dvcore)._postRender.call(this);

		var options = this._options,
			d3Parent = d3.select(options.parent);
		this._updateYAxisHitBox(d3Parent);
		this._colorDualYAxes(options, d3Parent);
	};

	dvcore._removeYAxisHitBox = function(d3Parent) {
		d3Parent.selectAll('.axis-y .cv-axis-hitbox').remove();
	};

	dvcore._colorDualYAxes = function(options, d3Parent) {
		if (options.dualYAxis && (!this._isNormalized || !this._isNormalized()) &&
			(this._options.position === 'identity' || this._options.position === 'dodge')) {
			// Color the axis labels to match the series if it's a dual axis and not normalized -- can't be stacked/filled either
			d3Parent.selectAll('.axis-y.axis-index-0 span').style('color', options.colors[0]);
			d3Parent.selectAll('.axis-y.axis-index-1 span').style('color', options.colors[1]);
			d3Parent.selectAll('.axis-title-y.axis-title-index-0').style('color', options.colors[0]);
			d3Parent.selectAll('.axis-title-y.axis-title-index-1').style('color', options.colors[1]);
		}
	};

	/**
	 * Creates the series states which will be used to populate the legend and will dispatch events when their
	 * internal state changes.
	 */
	dvcore._createSeriesStates = function() {
		var options = this._options;

		if ('data' in this._changedOptions && this._changedOptions.data) {
			// Remove old states
			this._seriesState.removeStatesByType('standard');
			var seriesIds = this._dataAdapter.data()[this._getPropMapping('series')],
				seriesNames = this._dataAdapter.data()[this._getPropMapping('seriesLabel')];

			// Reduce the ids down to unique values and grab the corresponding names.  Ids are unique, but names don't have to be.
			if (seriesIds) {
				var seriesTypes = seriesIds.reduce(function(memo, d, i) {
						if (memo.ids.indexOf(d) < 0) {
							memo.ids.push(d);
							memo.names.push(seriesNames ? seriesNames[i] : d);
						}
						return memo;
					}, {names: [], ids: []}),
					// Need to insert new states in reverse order since we are inserting them and want them to be first in the legend etc.
					i = seriesTypes.ids.length;
				while (i--) {
					var seriesName = seriesTypes.names[i],
						seriesId = seriesTypes.ids[i];
					this._seriesState.insertState(seriesName || seriesId, seriesId, 'standard');
				}
			}
		}

		if ('targetValues' in this._changedOptions) {
			if (options.targetValues) { // Add a target series state
				// Remove previously added target states
				this._seriesState.removeStatesByType('target');
				// If the targetLabel is undefined, set it to the localized target default label.
				this._seriesState.appendState(options.targetLabel || this._dataAdapter.l10n.labels.dvcore.target, 'target', 'target');
			}
		}
	};

	dvcore._createTargetHLines = function() {
		var options = this._options,
			chart = this._chart,
			self = this;

		// The chart should already have its layers set, lets add an extra layer for hlines
		if (options.targetValues && options.targetValues.length) {
			var layers = chart.layers(),
				hline = dv.geom.hline(),
				enabled = self._seriesState.isSeriesEnabled('target', 'target'),
				hlineData = { 'y': [], 'name': [] },
				i,
				length = options.targetValues.length,
				rangePadding = [0, this._isSmallChart() ? 24 : 6],
				scale = (options.scales && options.scales.y === 'log') ? dv.scale.log() : dv.scale.linear();

			for (i = 0; i < length; i++) {
				hlineData.y.push(options.targetValues[i]);
			}

			hline.data(hlineData)
				.position('identity')
				.map('y', 'y', scale.includeInDomain(function() {
					if (!self._valuesAreFilterable()) { return true; }
					return enabled;
				})
				.rangePadding(rangePadding))
				.each('start', function(d, i) {
					d3.select(this).attr('legend-type', 'target');
				});

			// The target hlines should appear below line charts and above the other chart types
			if (this._type === 'line') {
				layers.unshift(hline);
			} else {
				layers.push(hline);
			}
			chart.layers(layers);
		}
	};

	dvcore._domainNaturallyIncludesZero = function(scale) {
		if (!scale) { return false; }

		var options = this._options,
			prop = scale.property(),
			natDomain = scale.naturalDomain(),
			lowerBound = natDomain[0];
		// Account for log scales which can't include zero in their domain.
		if (options.scales && options.scales[prop] === 'log') {
			return lowerBound <= 1;
		}
		return lowerBound <= 0;
	};

	dvcore._updateYAxisHitBox = function(d3Parent) {
		var self = this,
			options = this._options,
			panel = this._chart.facet().getPanel(0);

		// Add a hit area on axes for toggling forceZero
		if (panel) {
			var isSmall = this._isSmallChart(),
				normalized = this._isNormalized && this._isNormalized(),
				yScale = this._chart.getTrainedScale('y'),
				naturallyIncludesZero = this._domainNaturallyIncludesZero(yScale),
				left = panel.bounds().left,
				top = yScale.range()[1],
				bottom = yScale.range()[0],
				yAxisParent = d3Parent.selectAll('.axes-labels .axis-y.axis-index-0'),
				hitbox = yAxisParent.selectAll('.cv-axis-hitbox').data([0]);

			if (options.interactive && !isSmall && !normalized && !naturallyIncludesZero && options.position === 'identity') {
				hitbox.enter().append('div').classed('cv-axis-hitbox', true);
				hitbox.on('click', function() {
							if (options.interactive && !isSmall) {
								self._dataAdapter._forceZero = !self._dataAdapter._forceZero;
								self._render(true);
								self._postRender();
							}
						});

				if (this._legend !== 'none' && this._legend.isVertical()) {
					// if legend if left oriented, take that position into account when positioning the y axis hitbox.
					left -= this._legend.orientation() === 'left' ? this._legend._getUsedWidth() : 0;
				}

				hitbox
					.style('width', left + 'px')
					.style('height', (bottom - top) + 'px')
					.style('top', top + 'px')
					.style('left', (-left) + 'px');

				hitbox.exit()
					.on('click', null);
			}
			else {
				this._removeYAxisHitBox(d3Parent);
			}
		}
		else {
			this._removeYAxisHitBox(d3Parent);
		}
	};

	/**
	 * Render the chart
	 **/
	dvcore._render = function(animate) {
		Object.getPrototypeOf(dvcore)._render.apply(this, arguments);
		var options = this._options, error;
		try {
			// Check for required options (data, parent)
			if (!this._dataAdapter.isDataValid()) {
				error = new Error('The chart data is invalid');
				error.code = 'invaliddata';
				throw error;
			}

			if (!options.parent) {
				throw new Error('The chart options did not contain a parent');
			}

			return this._draw(animate);
		} catch(e) {
			this.handleError(e);
		}
	};

	/**
	 * Resets the chart instance.  Called on both render and destroy.
	 **/
	dvcore.reset = function() {
		Object.getPrototypeOf(dvcore).reset.apply(this, arguments);
	};

	/**
	 * Destroy the chart
	 **/
	dvcore.destroy = function() {
		Object.getPrototypeOf(dvcore).destroy.apply(this, arguments);

		if (this._options && this._options.parent) {
			// dvcore charts always have a cv-wrapper around the chart
			d3.select(this._options.parent).select('.cv-wrapper').remove();
		}
		return this;
	};

	dvcore._isMappedAndExistsInData = function(prop) {
		var mapping = this._getPropMapping(prop);
		return mapping && this._options.data[mapping];
	};

	/**
	 * Set the chart's data, dimensions and parent element
	 **/
	dvcore._setChartCoreOptions = function() {
		var options = this._options, chart = this._chart, self = this,
			aspectRatio = options.aspectRatio, width = options.width,
			height = options.height, parent = d3.select(options.parent);

		chart.data(this._dataAdapter.data())
			.width((aspectRatio !== null && height !== null) ? height * aspectRatio : width)
			.height((aspectRatio !== null && width !== null) ? width / aspectRatio : height);

		// Create a wrapper container
		var container = parent.selectAll('.cv-wrapper').data([0]);
		container.enter().insert('div', ':first-child').classed('cv-wrapper', true);
		container.attr('data-chart-type', this._type);
		container.classed({
				'interactive': options.interactive,
				'right-overflow': (this._adjustClipWidth),
				'cv-small-chart': (this._isSmallChart())
			});
		chart.parent(container.node());

		this._legend = this._buildLegend();
		this._seriesState.on('enableChange.paths', function(eventType, state) {
			self._preRender();
			self._render(true);
			self._postRender();
			// Some geoms may change legend groups, so reset
			// TODO: Move into post render
			setTimeout(function() { // TODO: Avoid hack to set async, need post render from DV
				self._updatePathStates();
			}, 10);
		});

		if (!this._isSmallChart()) {
			var padding = { left: 10 };
			if (options.dualYAxis) {
				// make some room for the right axis labels
				padding.right = 10;
			}
			chart.padding(padding); // move left yaxis labels off left edge
		} else {
			chart.padding({}); // clear padding for legend/chart
		}
	};

	/**
	 * Borrowed from jQuery. Detects if an element is display: none (or its ancestors).
	 * @param  {[type]}  parent selector string, or DOM element
	 * @return {Boolean} returns true if the element is visible, or false otherwise.
	 */
	dvcore._isVisible = function(parent) {
		var elem = d3.select(parent).node();
		return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	};

	/**
	 * Draw the chart using customized options
	 **/
	dvcore._draw = function(a) {
		var chart = this._chart, options = this._options,
			animate = (a === undefined) ? false : a;

		// Don't draw the chart if the parent isn't visible. This can cause
		// an NS_ERROR_FAILURE in firefox. Can't call getBBox on display none
		// parent.
		if (!this._isVisible(options.parent)) {
			return this;
		}

		if (!chart) {
			throw new Error('DV Chart was not created');
		}
		this._setChartCoreOptions();
		this._setChartTypeOptions();
		this._createTargetHLines();

		if (this._isSmallChart()) {
			this._drawSmall();
		} else {
			this._drawLarge();
		}

		if (!animate) { chart.duration(0); }
		else { chart.duration(1000); }

		this._renderChart();

		return this;
	};

	// UX background, must be called after we render
	dvcore._drawBackground = function() {
		var options = this._options;
		if (options.interactive) {
			var container = d3.select(options.parent).select('.cv-wrapper'),
				bg = container.selectAll('.cv-bg').data([0]),
				orientation = this._legend === 'none' ? null : this._legend.orientation();

			bg.enter().insert('div', ':first-child').classed('cv-bg', true);

			var chart = this._chart,
				legend = d3.select(options.parent).select('.cv-legend'),
				borderAdjust = ((this._legend !== 'none' && this._legend.isVertical()) || legend.empty()) ? 0 : 1, // hide top border under legend
				shadowAdjust = 1, // move height down 1 to hide axis
				padding = chart.padding(),
				lastPanelBounds = chart.facet().getPanel(chart.facet()._panels.length - 1).bounds(), // minus axis
				plotBounds = chart.plotBounds(), // actual plot bounds
				legendWidth = this._chart._legends && this._chart._legends.hasOwnProperty('_w') ? this._chart._legends._w : 0,
				// Orientation may be null but could be oriented left or top automatically so check for that.
				x = this._legend !== 'none' && (orientation === 'left' || (!orientation && this._legend.isVertical())) ? legendWidth : 0, // Offset by the width of the legend if orientation left
				y = plotBounds.top - borderAdjust - padding.top,
				width = chart._calcWidth - x - (orientation === 'right' ? legendWidth : 0),
				height = (lastPanelBounds.top + lastPanelBounds.height) - plotBounds.top + borderAdjust + padding.top;

			bg.style('top', y + 'px')
				.style('left', x + 'px')
				.style('height', (height + shadowAdjust) + 'px')
				.style('width', width + 'px');

			// If legend is vertical, set a clipped height if it would be taller than the chart
			if (this._legend !== 'none' && this._legend.isVertical()) {
				var adjust = 1, // adjust for legend border
					d3Legend = d3.select(options.parent).selectAll('.cv-legend'),
					lHeight = !legend.empty() && d3Legend.node().offsetHeight || 0,
					clipped = (lHeight >= height - adjust);
				d3Legend.style('height', clipped ? (height - adjust) + 'px' : null).classed('clipped', clipped);
			}
		}
	};

	dvcore._drawClipping = function() {
		var chart = this._chart, options = this._options,
			svg = chart._svgContainer,
			defs = svg.selectAll('defs').data([0]);
		// verify we have a defs to contain the clip
		defs.enter().insert('defs', ':first-child');

		// Create clip svg
		// ID needs to be unique per graph so one graph doesn't use clip of another
		// Browser was lowercasing 'clipPath' so we had to add another attr (class) to key off of
		var clipId = 'cv-clip' + (this.clipIdCounter.count++),
			clip = defs.selectAll('.cv-clip').data([0]);
			clip.enter().append('clipPath').classed('cv-clip', true).append('rect');
			clip.attr('id', clipId);

		// Set up clipping
		var rect = clip.selectAll('rect'),
			padding = chart.padding(),
			lastPanelBounds = chart.facet().getPanel(chart.facet()._panels.length - 1).bounds(), // minus axis
			plotBounds = chart.plotBounds(), // actual plot bounds
			x = plotBounds.left - padding.left,
			y = plotBounds.top,
			width = plotBounds.right - x + padding.right,
			height = (lastPanelBounds.top + lastPanelBounds.height) - plotBounds.top + 1;

		// Background has some adjustments
		if (options.interactive) {
			width -= 1; // adjust for border on bg
			height -= 1; // adjust for bottom border on bg
		}
		if (this._adjustClipHeight) {
			height += this._adjustClipHeight;
		}
		if (this._adjustClipWidth) {
			width += this._adjustClipWidth;
		}
		rect.attr('x', x).attr('y', y).attr('width', Math.max(width, 0)).attr('height', Math.max(height, 0));
		svg.selectAll('.geom').attr('clip-path', null);
		svg.selectAll('.geom:not(.no-clip)').attr('clip-path', 'url(#'+clipId+')');
	};

	dvcore._renderChart = function() {
		var self = this,
			options = this._options;

		// Allow consumer final say on render
		if('function' == typeof options.preRender) {
			options.preRender(this.getChart());
		}
		this._chart.render();
		this._drawBackground();
		this._drawClipping();
		setTimeout(function() { // TODO: Avoid hack to set async, need post render from DV
			self._updatePathStates();
		}, 10);
	};

	dvcore._onAutoResize = function() {
		this._draw(false);
	};

	// Override
	dvcore._setChartTypeOptions = function(){};
	dvcore._drawSmall = function(a){};
	dvcore._drawLarge = function(a){};

	/**
	 * Return if a chart should be rendered as small
	 **/
	dvcore._isSmallChart = function() {
		return Object.getPrototypeOf(dvcore)._isSmallChart.apply(this, [this._getChartWidth()]);
	};

	/**
	 * Get the chart's width
	 **/
	dvcore._getChartWidth = function() {
		var options = this._options,
			d3Parent = d3.select(options.parent),
			cvWrapper = d3Parent.select('.cv-wrapper');

		if (cvWrapper.empty()) {
			// This should only happen if there is an error on the chart and an error message is displayed.
			cvWrapper = d3Parent;
		}

		if (options.plotWidth !== null && !dv.util.isPercentString(options.plotWidth)) {
			return options.plotWidth;
		}
		else if (options.width !== null && !dv.util.isPercentString(options.width)) {
			return options.width;
		}

		// We are either dealing with percentages or will just use the parent width
		var parentWidth = cvWrapper.node().offsetWidth;
		var parentHeight = cvWrapper.node().offsetHeight;
		if (options.plotWidth !== null) {
			return parseInt(options.plotWidth, 10) / 100 * parentWidth;
		}
		else if (options.width !== null) {
			return parseInt(options.width, 10) / 100 * parentWidth;
		}
		else {
			return (options.aspectRatio !== null && parentHeight !== null) ? parentHeight * options.aspectRatio : parentWidth;
		}
	};

	/**
	 * Get the chart's height
	 **/
	dvcore._getChartHeight = function() {
		var options = this._options;
		if (options.plotHeight !== null && !dv.util.isPercentString(options.plotHeight)) {
			return options.plotWidth;
		}
		else if (options.height !== null && !dv.util.isPercentString(options.height)) {
			return options.height;
		}

		// We are either dealing with percentages or will just use the parent width
		var parentWidth = d3.select(options.parent).node().offsetWidth;
		var parentHeight = d3.select(options.parent).node().offsetHeight;
		if (options.plotHeight !== null) {
			return parseInt(options.plotHeight, 10) / 100 * parentHeight;
		}
		else if (options.height !== null) {
			return parseInt(options.height, 10) / 100 * parentHeight;
		}
		else {
			return (options.aspectRatio !== null && parentWidth !== null) ? parentWidth / options.aspectRatio : parentHeight;
		}
	};

	// Legend
	// -------

	dvcore._constructScale = function(axis, dvscale) {
		var options = this._options,
			scale = dvscale;

		if (!scale) {
			var scaleType = options.scales && options.scales[axis];
			if (!scaleType || scaleType === 'default') {
				scaleType = 'linear';
			}
			scale = dv.scale[scaleType]();
		}

		if (options.interactive) { scale = this._adjustLimits(scale); }
		if (axis === 'y' && this._dataAdapter._forceZero) {
			this._applyForceZero(scale);
		}
		return scale;
	};

	dvcore._applyForceZero = function(scale) {
		var options = this._options,
			isLogY = options.scales && options.scales.y === 'log',
			// Math.log(0) throws error. A log scale domain cannot cross zero.  Use 1 or -1 depending on whether domain is entirely positive or negative.
			minYBaseline = isLogY ? 1 : 0,
			maxYBaseline = isLogY ? -1 : 0;
		scale.lowerLimit(function(min, max) { return min < minYBaseline ? min : minYBaseline; }); // If the min lower limit would already be < 0, use it's min, otherwise use zero (or use 1 if log scale)
		scale.upperLimit(function(min, max) { return max > maxYBaseline ? max : maxYBaseline; }); // If the max upper limit would be < 0, we need to force it to be zero (or use -1 if log scale)
		return scale;
	};

	dvcore._adjustLimits = function(scale) {
		// Set includeInDomain to adjust scales
		var self = this, options = this._options;
		// Map to groups and filter out disabled values
		scale.includeInDomain(function(d, i) {
			if (!self._valuesAreFilterable()) { return true; }
			return self._seriesState.isSeriesEnabled(d.data[self._legend.mapping()], 'standard');
		});
		return scale;
	};

	dvcore._valuesAreFilterable = function() {
		return (this._options.interactive &&
			this._seriesState.areSomeSeriesDisabled() &&
			!this._seriesState.areAllSeriesDisabled());
	};

	/**
	 * Gets the data and filters out non-enabled values based on legend groups
	 **/
	dvcore._getEnabledValues = function(key) {
		var self = this,
			options = this._options,
			values = this._dataAdapter.data()[this._getPropMapping(key)];
		// Handle initial all enabled state
		if (!this._valuesAreFilterable()) { return values; }
		// Map to groups and filter out disabled values
		var	mapping = this._dataAdapter.data()[this._legend.mapping()];
		values = values.filter(function(v, i) {
			return (mapping[i] && self._seriesState.isSeriesEnabled(mapping[i], 'standard'));
		});
		return values;
	};

	dvcore._updatePathStates = function() {
		var self = this,
			options = this._options,
			parent = d3.select(options.parent);
		// We target .plot in this selection to ensure we only deal with DV controlled SVG. In the case of funnel,
		// there is a series class, but it isn't DV controlled and has different data assumptions.
		// Should any of the paths be inactive if their state is disabled?
		parent.selectAll('.plot .series [legend-group]')
			.classed('path-inactive', function() {
				if (!options.interactive) { return false; }
				var el = d3.select(this),
					data = el.datum(),
					// Some datasets bound to SVG are arrays (line, area) so in this case, we'll check and if it
					// is an array, we'll use the first datapoint on that array.
					dataPoint = dv.util.isArray(data) ? data[0].data : data.data,
					seriesId = dataPoint[self._getPropMapping('series')];
				if (self._seriesState.doesSeriesStateExist(seriesId, 'standard')) {
					return !self._seriesState.isSeriesEnabled(seriesId, 'standard');
				}
				return el.classed('path-inactive'); // Return whatever it already was.
			});
		if (options.targetValues) {
			parent.selectAll('.plot .series [legend-type]')
				.classed('path-inactive', function() {
					if (!options.interactive) { return false; }
					var el = d3.select(this),
						seriesType = el.attr('legend-type');
					if (self._seriesState.doesSeriesStateExist('target', seriesType)) {
						return !self._seriesState.isSeriesEnabled('target', seriesType);
					}
					return el.classed('path-inactive'); // Return whatever it already was.
				});
		}
	};

	/**
	 * Builds a legend for the user
	 * Defaults to a standard DV legend or custom if interactive flag is set
	 *
	 * @param {string} seriesMapKey The key to use for the legend, defaults to series
	 * @param {string} seriesLabelMapKey The key to use for the legend labels, defaults to seriesLabel
	 * @returns {object} dv.guide.legend or custom object for a custom legend
	 */
	dvcore._buildLegend = function(seriesMapKey, seriesLabelMapKey) {
		// Determine if custom labels will be needed and pass them to the builders
		var labels = null, options = this._options,
			container = d3.select(options.parent).select('.cv-wrapper'),
			seriesMapping = this._getPropMapping(seriesMapKey || 'series'),
			seriesLabelMapping = this._getPropMapping(seriesLabelMapKey || 'seriesLabel');

		// Handle custom labels for the series
		if (seriesMapping && seriesLabelMapping && seriesMapping !== seriesLabelMapping) {
			var data = this._dataAdapter.data(),
				series = data[seriesMapping],
				seriesLabels = data[seriesLabelMapping] || series;
			// We assume that the entries that the standard legend will create will remain in the same order
			// We will then map the first instance of each value to its appropriate label
			labels = [];
			series.forEach(function(v, i, a) {
				if (a.indexOf(v) === i) { // first occurance
					labels.push(seriesLabels[i]);
				}
			});
		}

		if (!options.legendVisible) {
			container.selectAll('.cv-legend').remove();
			container.selectAll('.cv-bg').remove();
			return 'none';
		}

		// Interactive custom legend
		if (options.interactive) {
			return this._buildInteractiveLegend(labels);
		} else {
			return this._buildStandardLegend(labels);
		}
	};

	/**
	 * Builds a standard dv.guide.legend
	 *
	 * @param {string} type The type of chart (bar, line, donut etc)
	 * @param {labels} array Custom labels for the legend entries or null (use series strings)
	 * @returns {object} dv.guide.legend
	 */
	dvcore._buildStandardLegend = function(labels) {
		var options = this._options,
			container = d3.select(options.parent).select('.cv-wrapper');

		this._legend = null;

		// Handle transition from interactive to not, remove old interactive legend containers
		container.selectAll('.cv-legend').remove();
		container.selectAll('.cv-bg').remove();

		// Set padding based on orientation
		var padding, orientation = this.LEGEND_ORIENTATIONS.indexOf(options.legendOrientation) > -1 ?
				options.legendOrientation : 'top';

		switch (this._calculatedLegendOrientation) {
			case 'top':
			case 'bottom':
				padding = {top: 5, bottom: 5, left: 0, right: 0};
				break;
			case 'left':
			case 'right':
				padding = {top: 0, bottom: 0, left: 5, right: 5};
				break;
		}

		var legend = dv.guide.legend().orientation(orientation).padding(padding);
		if (labels) {
			legend.labels(labels);
		}

		// Add additional padding between entries on a small chart
		if (this._isSmallChart()) {
			legend.hGap(10).vGap(2);
		}
		return legend;
	};

	/**
	 * Builds a dv.guide.custom legend using HTML. Used specifically for allowing interactivity with the chart
	 *
	 * @param {labels} array Custom labels for the legend entries or null (use series strings)
	 * @returns {object} dv.guide.custom
	 */
	dvcore._buildInteractiveLegend = function(labels) {
		var options = this._options, self = this,
			container = d3.select(options.parent).select('.cv-wrapper');

		if (!this._legend) {
			this._legend = cloudViz.interactiveLegend();
		}

		// No legend if only 1 unique metric <--- this rule has temporarily been removed. We should display a generic title instead of a legend for a single unique metric.
		var groups = this._dataAdapter.data()[this._getPropMapping('series')],
			multipleGroups = groups.some(function(name, i, names){
				return name !== names[i-1];
			});

		if (!multipleGroups) {
			this._legend.remove();
			// Remove all inactive paths
			container.selectAll('.path-inactive').classed('path-inactive', false);
			return 'none';
		}

		this._legend
			.parent(container.node())
			.orientation(options.legendOrientation)
			.chartWidth(this._getChartWidth())
			.chartHeight(this._getChartHeight())
			.chartPadding(this._chart.padding())
			.validOrientations(this.LEGEND_ORIENTATIONS)
			.legendVerticalWidth(options.legendVerticalWidth)
			.type(this._type)
			.seriesState(this._seriesState);

		if (labels) {
			// set the totals for donut charts in the legend
			if (this._getCategoryTotal) {
				this._legend.totals(labels.map(function(d) {
					return this._getCategoryTotal(d);
				}));
			}
		}

		return this._legend;
	};

	/**
	 * Provides a custom number of ticks for linear x data on the x axis. The function returned by this method is
	 * called by DV's dv.guide.axis.  DV passes the range to this function and the function returns how many ticks
	 * should be able to fit in that amount of range space. This function can be overridden for specific use-cases
	 * downstream.
	 *
	 * @return {function(number):number} A function called by dv.guide.axis which passes in the amount of space and
	 * expects a number of ticks to be returned.
	 */
	dvcore._numXTicks = function() {
		return function(range) {
			return Math.max(range / 120, 2);
		};
	};

	/**
	 * Formats the title for the y axis
	 * @param {num} - the index of which scale we are applying the format to
	 * @param {array} - an optional parameter that allows constraining the range of values for determining tick extent
	 * @returns {string} - y axis title
	 */
	dvcore._yTitleFormat = function(scaleIndex, values) {
		// TODO: scaleIndex is ignored for title
		var adapter = this._dataAdapter,
			title = adapter.yAxisTitle(),
			l10n = adapter.l10n,
			format = this._getYFormatType(scaleIndex),
			time, pattern;

		if ('time' === format) {
			if (!values) {
				values = this._getEnabledValues('y'); // If we don't have values, let's just use the default enabled values
			}
			time = this._yTimeGranularity(values, dv.guide.axis().ticks()());
			time = l10n.time.plural[time.gran];
			pattern = (title) ? l10n.labels.dvcore.yAxisTimeWithTitle: l10n.labels.dvcore.yAxisTimeNoTitle;
			title = pattern.replace(/\{time\}/i, time)
						.replace(/\{title\}/i, title);
		}
		return title;
	};

	/**
	 * Takes a passed y value and formats it based on type
	 * @param {number} - value
	 * @param {string} - format type
	 * @param {object} - optional time object
	 * @param {number} - an optional precision which will enforce the number of decimal places that will be shown on a number.
	 * @returns {string} - format type for y scale
	 */
	dvcore._formatYValue = function(value, type, time, precision) {
		if (time && time.divisor > 0) { value = value / time.divisor; }
		return this._formatNumber(type, value, precision);
	};

	/**
	 * Get the y format type for the passed scaleIndex
	 * @param {num} - the index of which scale we are applying the format to
	 * @returns {string} - format type for y scale
	 */
	dvcore._getYFormatType = function(scaleIndex) {
		var yFormats = this._dataAdapter.formats().y;
		if (!yFormats) {
			return 'decimal'; // default
		}
		if (dv.util.isArray(yFormats)) { // We have different y formats for each series
			if (!yFormats[scaleIndex]) {
				return 'decimal';
			}
			return yFormats[scaleIndex];
		}
		return yFormats; // We have the same y format for all series
	};

	/**
	 * Handles sizing ticks appropriately based on how the chart is configured. Returning null means the tick
	 * should be drawn across the entire length of the chart. DualYAxis ticks and minor log ticks are small.
	 * @param  {String} property The axis we are looking at (e.g. "x" or "y")
	 * @return {Function} Returns a function which returns a number for the length in pixels of the tick or null for the entire length of the chart.
	 */
	dvcore._tickSize = function(property) {
		var options = this._options,
			dualAxis = options.dualYAxis && property === 'y',
			tickSize;

		// If this function returns null, it means DV will draw a tick across the entire plot.
		// If it returns a number, DV will draw a tick that many pixels long.
		return function(d) {
			// Make log minor ticks smaller than major ticks (but only for values which are powers of 10)
			if (options.scales && options.scales[property] === 'log') {
				if ((Math.round(Math.log(Math.abs(d)) / Math.LN10 * 1e6) / 1e6) % 1) { // equivalent to Math.log10(Math.abs(d))
					tickSize = 10;
				} else {
					tickSize = null;
				}
			}
			else {
				tickSize = null;
			}

			// This is a major tick. If we have a dual y axis, make those ticks shorter, otherwise they stretch
			// across the entire plot.
			if (!tickSize) {
				return dualAxis ? 15 : null;
			}
			return tickSize;
		};
	};

	/**
	 * Formats a y value for a label
	 * The main differnce is handling time values, which need to display differently
	 * based on the value rather than against a set scale like on an axis
	 * @param {num} - the index of which scale we are applying the format to
	 * @returns {function} - arguments (d, i) to format number on y axis
	 */
	dvcore._yLabelFormat = function(scaleIndex) {
		var type = this._getYFormatType(scaleIndex),
			adapter = this._dataAdapter,
			opts = this._options,
			self = this;
		return function(d, i) {
			var str, time, l10n = adapter.l10n.time;
			if ('time' === type) {
				time = adapter.getTimeGranularity(d, true); // convert to milliseconds
				l10n = (1 !== +d) ? l10n.plural : l10n.singular;
			}
			str = self._formatYValue(d, type, time, opts.precision);
			if (time && time.gran) { // add time postfix
				str += ' ' + l10n[time.gran];
			}
			return str;
		};
	};

	/**
	 * Formats the label for a tick on the y axis
	 * @param {num} - the index of which scale we are applying the format to
	 * @param {array} - an optional parameter that allows constraining the range of values for determining tick extent
	 * @param {boolean} - an optional parameter which makes it so labels are never hidden. Used for things other than axis labeling where the format should be consistent.
	 * @returns {function} - arguments (d, i) to format number on y axis
	 */
	dvcore._yTickFormat = function(scaleIndex, values, showAllLabels) {
		var self = this,
			type = this._getYFormatType(scaleIndex),
			options = this._options,
			isLogY = options.scales && options.scales.y === 'log',
			yMinBaseline = isLogY ? 1 : 0,
			useSecondAxisLabelForArrow = false,
			logAxisLabels,
			arrowDrawn,
			minDomain,
			time;

		if ('time' === type) {
			if (!values) {
				// If we don't have values, let's just use the default enabled values
				values = this._getEnabledValues('y');
			}
			time = self._yTimeGranularity(values, dv.guide.axis().ticks()());
		}

		return function(d, i, panel) {
			var el = d3.select(this),
				yScale = panel.yOuterScale().innerScaleGroup()[scaleIndex],
				distFromBottom,
				hideValue = false;

			if (i === 0) {
				arrowDrawn = false;
			}

			// If the series doesn't have its own scale, just use the trained scale.
			if (!yScale) {
				yScale = panel.getTrainedScale('y');
			}
			minDomain = yScale.domain()[0];
			distFromBottom = yScale.range()[0] - yScale.mapValue(d);

			// Log axis labels need to be handled differently :(
			// The number of ticks cannot be set with axis.ticks(5) due to the way D3 handles log ticks. You
			// cannot directly ask for a certain number of ticks.  You can however, use the D3 log scale's
			// tickFormat function and limit them this way -- it determines which ticks will show labels and
			// which will not. The non-visible labels are set to empty string.
			// Since we have to do things this way, we will compute the log axis labels once and use them for
			// all the other axis label passes.
			if (isLogY) {
				if (!logAxisLabels) {
					var logScale = d3.scale.log().domain(yScale.domain());

					logAxisLabels = logScale.ticks().map(logScale.tickFormat(5, function(val) {
						// Use the proper label format function.
						return self._formatYValue(val, type, time, options.precision);
					}));
				}
			}

			// Don't display labels that will collide with the bottom of the chart.
			if (distFromBottom < 10) {
				hideValue = true;
			}

			// If the scale is log and we already filtered out the label, make it known here.			
			if (isLogY && logAxisLabels[i] === '') {
				hideValue = true;
			}

			// Only draw an arrow under a number if it's the first label drawn. Only do this if the baseline 
			// doesn't hit the minimum baseline (zero, or one if logarithmic y scale).
			if (minDomain > yMinBaseline && !hideValue && !arrowDrawn && options.interactive) {
				el.classed('arrow-container', true);
				arrowDrawn = true;
			} else {
				el.classed('arrow-container', false);
			}

			// Show a hidden value (empty string) for all hidden labels unless we're supposed to show all labels.
			if (hideValue && !showAllLabels && options.interactive) {
				return '';
			}

			if (isLogY) {
				return logAxisLabels[i]; // Already preformatted above
			}

			return self._formatYValue(d, type, time, options.precision);
		};
	};

	/**
	 * Takes a range of values in seconds and defines the granularity for the y tick marks
	 * Also determines the divisor to apply to seconds to get the correct value
	 * @returns {obj} - { gran : 'day', divisor : '36000' }
	 */
	dvcore._yTimeGranularity = function(values, ticks) {
		// handle undefined/null in values
		values = values && values.filter(function(v) { return isFinite(v); }) || [];
		ticks = ticks || 1; // don't accept even 0
		if (!values.length) { return null; } // not valid
		var max = Math.max.apply(null, values), min = Math.min.apply(null, values),
			arr = d3.scale.linear().domain([min, max]).ticks(ticks),
			diff = arr.length ? (arr.length > 1) ? arr[1] - arr[0] : max - arr[0] : max,
			step = arr.length ? (diff / arr.length) : diff;
		return this._dataAdapter.getTimeGranularity(step);
	};

	// X Axis Time (Line, Bar)
	// -------

	dvcore._xTickAnchor = function(chart) {
		return function(d, i, n) {
			var xScale = chart.getTrainedScale('x'),
				xRange = dv.util.scaleRange(xScale), // Get xScale.range() if continuous and xScale.rangeExtent() if ordinal
				insetWidth = 20; // within this distance from edge we inset the label

			// Convert the tick value into range space.
			// xScale.rangeBand() will be zero if the scale is continuous.
			// Otherwise, it represents the full width of the "band" so we'll divide by 2 to get the center.
			var labelXPos = xScale.mapValue(d) + xScale.rangeBand() / 2;
			if (labelXPos - xRange[0] < insetWidth) {
				return 'start';
			}
			if (xRange[1] - labelXPos < insetWidth) {
				return 'end';
			}
			return 'middle';
		};
	};

	// Check to see if we're normalized, and if so adjust the axis so we don't show a secondary axis and change the axis title to
	// "normalized" (Line, Bar)
	// -------

	dvcore._checkNormalized = function() {
		var chart = this._chart, l10n = this._dataAdapter.l10n;
		// Normalized, remove all yaxis
		if (this._isNormalized && this._isNormalized()) {
			chart.guide('y', 'none', 1);
			chart.guide('y', dv.guide.axis().ticks(0)
				.tickFormat(function(d, i) { return ''; }) // hide y axis labels
				.title(l10n.labels.core.normalized)
			);
			chart.padding({});
		}
	};

	/**
	 * Formats a date according to a format template. This takes date localization settings into account.
	 *
	 * @param {date} date The date to format.
	 * @param {string} template A format template string following d3.js conventions:
	 * https://github.com/mbostock/d3/wiki/Time-Formatting
	 * @param {string} granularity of the time in the chart
	 * @returns {string} The formatted date string.
	 * @private
	 */
	dvcore._formatTime = function(date, template, gran) {
		// d3's API for localizing dates is quite limited at the moment. It requires you to pre-compile different
		// versions of d3--one for each locale you'd potentially like to use. We'd like it to make it so users can
		// define or override the locale formatting at runtime. In order to do so, we have to seek through the
		// formatting template looking for the tokens that require localization (like months and weekdays) and perform
		// the formatting for those tokens OUTSIDE of d3. The rest of the formatting template we run through d3.
		//
		// This follows a similar approach to the way d3 performs the operation with a few tweaks.
		// One of the tweaks is we're using string concatenation instead of filling an array and joining because
		// it's faster: http://jsperf.com/array-join-vs-string-connect

		var l10n = this._dataAdapter.l10n.calendar;

		var formatters = {
			a: function(d) { // Abbreviated weekday name
				return l10n.weekdayAbbreviations[d.getDay()];
			},
			A: function(d) { // Full weekday name
				return l10n.weekdays[d.getDay()];
			},
			b: function(d) { // Abbreviated month name
				return l10n.monthAbbreviations[d.getMonth()];
			},
			B: function(d) { // Full month name
				return l10n.months[d.getMonth()];
			},
			p: function(d) { // AM/PM
				return l10n.ampm[Math.floor(d.getHours() / 12)];
			}
		};

		var string = '', i = -1, j = 0, n = template.length;

		var addSkipped = function() {
			var skipped = template.substring(j, i);
			if (skipped.length) {
				string += d3.time.format(skipped)(date);
			}
		};

		while (++i < n) {
			if (template.charCodeAt(i) == 37) {
				var token = template.charAt(i + 1);
				var tokenFormatter = formatters[token];

				if (tokenFormatter) {
					addSkipped();
					string += tokenFormatter(date);
					i++;
					j = i + 1;
				}
			}
		}

		addSkipped();

		// Strip leading zeros from time formats for en-us
		var locale = this._options.locale.toLowerCase();
		if (('hour' === gran || 'minute' === gran || 'second' === gran) &&
				'en-us' === locale && 0 === string.indexOf('0')) {
			string = string.slice(1);
		}

		return string;
	};

	dvcore._timeGranTemplate = function(gran, format) {
		var t;
		switch(gran) {
			case 'second' : t = format.second; break;
			case 'minute' : t = format.minute; break;
			case 'hour' : t = format.hour; break;
			case 'day' : t = format.day; break;
			case 'week' : t = format.week; break;
			case 'month' : t = format.month; break;
			case 'quarter' : t = format.quarter; break;
			case 'year' : t = format.year; break;
			default : t = format.fallback; break;
		}
		return t;
	};

	dvcore._timeSmallXFormat = function() {
		var self = this, adapter = self._dataAdapter,
			format = adapter.l10n.dateFormat.fullFormat,
			gran = adapter ? adapter.dateGranularity() : '*',
			template = format.condensed;

		// Update template to include time if granularity is equal
		// or smaller than an hour
		if ('hour' === gran || 'minute' === gran || 'second' === gran) {
			template = format.timestamp;
		}

		return function(d, i) {
			return self._formatTime(d, template);
		};
	};

	dvcore._timeXTickFormat = function(validTickFunc) {
		var self = this, options = self._options,
			chart = this._chart, adapter = self._dataAdapter,
			prevTick = new Date(0),
			prevGranLabel = '',
			prevSwitchLabel = '',
			date = adapter.l10n.dateFormat, switchFormat = date.mediumFormat,
			gran = adapter ? adapter.dateGranularity() : '*',
			granTemplate = this._timeGranTemplate(gran, date.shortFormat);

		return function(d, i) {
			var template, granLabel, switchLabel, label;

			// cast d as date
			d = new Date(d);

			// Always show secondary line template if start is inset
			if (0 === i) {
				// always reset the prevTick so when render is called multiple times
				// it doesn't use the last tick date to compare against the first
				prevTick = new Date(0);
				prevGranLabel = null;
				prevSwitchLabel = null;
			}

			// If a validation function was passed in, run it against this particular label to see if it should
			// be rendered, otherwise just render an empty string (no label).
			if (validTickFunc && !validTickFunc.call(this, d, i)) {
				return '';
			}

			// Two line labels on change
			if ('second' === gran && prevTick.getMinutes() !== d.getMinutes()) { // minutes changed
				template = switchFormat.minute;
			}
			if ('hour' === gran && prevTick.getDate() !== d.getDate()) { // day changed
				template = switchFormat.day;
			}
			if (('day' === gran || 'week' === gran) && prevTick.getMonth() !== d.getMonth()) { // month changed
				template = switchFormat.month;
			}
			if (('month' === gran || 'quarter' === gran) && prevTick.getYear() !== d.getYear()) { // year changed
				template = switchFormat.year;
			}

			// Set label
			granLabel = self._formatTime(d, granTemplate, gran);

			// For minute, the two line labels look odd
			// for example for minute:
			//     5
			//   12 PM
			// so instead, lets just use a single label
			//  12:05 PM
			if ('minute' === gran && prevTick.getHours() !== d.getHours()) { // hour changed
				granLabel = self._formatTime(d, self._timeGranTemplate('minute', date.mediumFormat), gran);
			}

			prevTick = d;

			// Determine if we need a second line
			if (template) {
				switchLabel = '<br/>' + self._formatTime(d, template);
			} else {
				// CV-543: Require a second row so we don't crop the tooltip
				switchLabel = '<br/>&nbsp;';
			}

			// Don't show a redundant label
			if (granLabel === prevGranLabel &&
					(switchLabel === prevSwitchLabel ||
						!template)) { // If we don't have a template, we didn't have a second line of labels
				label = '';
			} else {
				label = (switchLabel) ? granLabel + switchLabel : granLabel;
			}

			prevGranLabel = granLabel;
			prevSwitchLabel = switchLabel;
			return label;
		};
	};

	global.cloudViz.dvcore = dvcore;
}(this));

/**
 * Centralized debouncing of window resize events.
 */
(function(global) {
	'use strict';

	var enabled,
		handlers = [];

	var debounce = function(fn, timeout) {
		var timeoutID = -1;
		return function() {
			if (timeoutID > -1) {
				window.clearTimeout(timeoutID);
			}
			timeoutID = window.setTimeout(fn, timeout);
		};
	};

	var debouncedHandler = debounce(function() {
		handlers.forEach(function(handler) {
			handler();
		});
	}, 30);

	/**
	 * Register a handler that will be called when the window resizes.
	 * @param handler
	 */
	var addHandler = function(handler) {
		if (handlers.indexOf(handler) == -1) {
			handlers.push(handler);
		}

		if (!enabled) {
			window.addEventListener('resize', debouncedHandler);
			enabled = true;
		}
	};

	/**
	 * Unregisters a handler from being called when the window resizes.
	 * @param handler
	 */
	var removeHandler = function(handler) {
		var index = handlers.indexOf(handler);
		if (index > -1) {
			handlers.splice(index, 1);
		}

		if (handlers.length === 0 && enabled) {
			window.removeEventListener('resize', debouncedHandler);
			enabled = false;
		}
	};

	global.cloudViz.windowResize = {
		addHandler: addHandler,
		removeHandler: removeHandler
	};
}(this));

/**
 * Line Chart
 * A chart that can show progression of data over any linear ordinal metric (time, revenue, etc)
 * Parameters
 * options: customization parameters for the line chart
 * options are defined in the core object, line specific are below in 'Line Options'
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, dvcore = cloudViz.dvcore || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		line = Object.create(dvcore),
		timeoutId = -1;

	line.init = function(options) {
		Object.getPrototypeOf(line).init.apply(this, arguments);

		this._type = 'line';
		this._chart = dv.chart();
		this._displayPoints = null;
		this._adjustClipHeight = 6;
		this._adjustClipWidth = 6;
		this._minTrendTickSpace = 135;
		this._showRibbons = false;
		this._uniqueGroups = null;
		return this;
	};

	line._initDefaultOptions = function() {
		var defaults = {
			// All series have their own y-scale if true
			normalized: false,
			// The area under the geom is colored
			filled: false,
			// The position of the geoms
			position: 'identity',
			// Make the bottom of the y axis always be zero
			forceZero: null,
			// Set the geoms in the chart to each have a y axis. max of 2
			dualYAxis: false,
			// Show anomalies in the line chart using a ribbon
			showAnomalies: false,
			mappings: {
				// upper edge of the ribbon
				upperRangeBand: 'upper',
				// lower edge of the ribbon
				lowerRangeBand: 'lower',
				// NOTE: Setting the ribbon anomaly mappings (upperRangeBand, lowerRangeBand)
				// will turn off filled if set
				// dotted line designating forecasted data inside a ribbon
				// forecast requires that there be bands set
				forecast: 'forecast'
			},
			formats: { // The format each series should be displayed with.  Options are decimal (default), percent, currency, time.
				x: 'decimal',
				y: 'decimal' // The y format can also be an array of formats for each individual series.
			},
			scales: {
				x: 'default',
				y: 'default'
			}
		};
		return Object.getPrototypeOf(line)._initDefaultOptions.call(this, defaults);
	};

	/**
	 * Resets the chart instance.  Called on both render and destroy.
	 **/
	line.reset = function() {
		Object.getPrototypeOf(line).reset.apply(this, arguments);

		// Remove the behaviors and mouse events we may have added with the inspector.
		var options = this._options;
		var d3Parent = d3.select(options.parent);
		d3Parent.selectAll('.behavior').text('');
		d3Parent.selectAll('.behavior-under-geom').text('');
		this._chart.on('mousemove.inspector', null);
		this._chart.on('mouseout.inspector', null);
		// remove second y-axis
		d3Parent.selectAll('.axis-y.axis-index-1').remove();
	};

	/**
	 * Common draw method for all lines
	 **/
	line._setChartTypeOptions = function() {
		var chart = this._chart, options = this._options, self = this,
			layers = [
				dv.geom.line()
					.each('start', function(d, i) {
						d3.select(this).attr('legend-group', d[0]['stroke']);
					})
					.map('stroke', this._getPropMapping('series'), dv.scale.color().values(options.colors))
			];

		this._uniqueGroups = dv.util.uniq(chart.data()[this._getPropMapping('series')]);

		// Ribbons should only be drawn if there is only one series (group) and mappings exist for upperRangeBand and lowerRangeBand.
		this._showRibbons = (this._uniqueGroups.length == 1 &&
			this._isMappedAndExistsInData('upperRangeBand') &&
			this._isMappedAndExistsInData('lowerRangeBand'));

		// Draw upper and lower bounds as a ribbon to denote margin of error in a forecast.
		if (this._showRibbons) {
			// shift to bottom layer
			layers.unshift(
				dv.geom.ribbon()
					.map('yMin', this._getPropMapping('lowerRangeBand'))
					.map('yMax', this._getPropMapping('upperRangeBand'))
					.set('alpha', 0.15)
					.interpolate('cardinal')
			);
			options.filled = false;
		}

		if (this._showRibbons && this._isMappedAndExistsInData('forecast')) {// check upper and lower bounds
			layers.push(
				dv.geom.line()
					.map('y', this._getPropMapping('forecast'))
					.set('alpha', 0.5)
					.set('linetype', 'dotted')
					.interpolate('cardinal')
			);
		}

		if (options.filled) {
			layers.push(
				// A baseline of undefined makes it so an area chart isn't forced to have a specific baseline (zero by default).
				// Undefined baseline causes the chart to use the min domain value as the baseline.
				dv.geom.area().baseline(undefined)
					.each('start', function(d, i) {
						d3.select(this).attr('legend-group', d[0]['fill']);
					})
					.map('fill', this._getPropMapping('series'), dv.scale.color().values(options.colors))
					.set('alpha', 0.2)
			);
		}

		var pointGeom =
			dv.geom.point()
				.map('stroke', this._getPropMapping('series'), dv.scale.color().values(options.colors))
				.set('fill', '#fff')
				.set('size', 7);

		// Needs to be on top of filled
		layers.push(pointGeom);

		var groupMapping = this._getPropMapping('group') || this._getPropMapping('series');
		chart.layers(layers)
			.guide('stroke', this._legend)
			.map('group', groupMapping)
			.set('linetype', function(d, i, j) {
				return (/::incomplete::$/).test(d.data[groupMapping]) ? '0,4,7,0' : 'solid';
			})
			.position(options.position);

		// Show a point for each data point on the line if the data density is not too high.
		pointGeom.each('start', function(d, i) {
			d3.select(this).classed('point-hidden', !self._shouldDisplayPoint.call(self, d))
				.attr('legend-group', d['stroke'])
				.classed('line-point', true); // line-points are styled a little differently than scatterplot or bubble points.
		});

		this._addBehaviors(chart, options);
		this._mapPositionScales(chart, options);
	};

	// Show points if enough space or on a ribbon if its outside the band
	line._shouldDisplayPoint = function(d) {
		return (this._showRibbons) ? this._isAnomalousDataPoint(d) : this._shouldDisplayPoints();
	};

	// We show points for each data point if >= 60px spaced
	line._shouldDisplayPoints = function() {
		// cache
		if (this._displayPoints !== null) { return this._displayPoints; }
		var options = this._options, chart = this._chart, array = chart.layers()[1]._nestData,
			max = Math.max.apply(null, array.map(function(d) { return d.values.length; } )),
			range = chart.getTrainedScale('x').range();

		// range 1 - 0 is the plot width (rather than the chart width).
		// If there is more than 60 pixels between points, we should display points.
		return this._displayPoints = (options.showAnomalies && this._showRibbons) || (((range[1] - range[0]) / max) >= 60);
	};

	/**
	 * Returns true if a point should be displayed in a ribbon chart
	 * This occurs when the point is outside the band range in the ribbon chart
	 */
	line._isAnomalousDataPoint = function(d) {
		return (d.data[this._getPropMapping('y')] > d.data[this._getPropMapping('upperRangeBand')] || d.data[this._getPropMapping('y')] < d.data[this._getPropMapping('lowerRangeBand')]);
	};

	/**
	 * Adds custom interactive behaviors to the chart.
	 */
	line._addBehaviors = function(chart, options) {
		var self = this,
			d3Parent = d3.select(options.parent),
			adapter = this._dataAdapter,
			xFormat = adapter.formats().x;

		// The chart must not be small and must be interactive in order to receive an inspector.
		if (options.interactive) {
			chart.behaviors([
				dv.behavior.inspector()
					.gutterPadding(0)
					.orientation('bottom')
					.thickness(2)
					.label(function(d) {
						// Format the label as a full date if it's a trend.  Otherwise, format it as a number.
						if (adapter.isOvertime()) {
							var gran = adapter.dateGranularity(),
								format = adapter.l10n.dateFormat.fullFormat;
							return self._formatTime(d, self._timeGranTemplate(gran, format), gran);
						}
						return self._formatNumber(xFormat, d, options.precision);
					})
					.inspectorMove(function(lbl, index, xPos, val) {
						var colorScale = chart.getTrainedScale('stroke')[0];
						self._highlightHoveredPoints.call(self, d3Parent, val, colorScale);

						// Hide the x axis labels and titles while the inspector is visible.
						d3Parent.selectAll('.axis-x .axis-label').style('opacity', 0);
						d3Parent.selectAll('.axis-x-title').style('opacity', 0);
						d3Parent.selectAll('.text-geom').style('opacity', 0);

						if (self._eventMap['mouseover']) {
							self._eventMap['mouseover'].call(this, lbl, index, xPos, val, d3.event);
						}
					})
					.inspectorOut(function() {
						var colorScale = chart.getTrainedScale('stroke')[0];
						self._highlightHoveredPoints.call(self, d3Parent, null, colorScale);

						// Show the x axis labels and titles while the inspector is hidden.
						d3Parent.selectAll('.axis-x .axis-label').style('opacity', 1);
						d3Parent.selectAll('.axis-x-title').style('opacity', 1);
						d3Parent.selectAll('.text-geom').style('opacity', 1);

						if (self._eventMap['mouseout']) {
							self._eventMap['mouseout'].call(this, d3.event);
						}
					})
					.underGeoms(true)
			]);
		}
	};

	/**
	 * Highlights points with the inspector over them.
	 * This function also updates the legend to show the highlighted values.
	 * If xPoint is null, no points are highlighted.
	 */
	line._highlightHoveredPoints = function(parent, xPoint, colorScale) {
		var legendValues = {},
			self = this,
			seriesNames = colorScale.domain(),
			opts = this._options;

		// Style the highlighted points and unstyle and non-highlighted points.
		parent.selectAll('.line-point')
			.each(function(d) {
				var d3Element = d3.select(this),
					color = colorScale.mapValue(d.stroke),
					isSelected = self._dataValuesEqual.call(self, d.x, xPoint),
					datum = d3Element.datum();

				// If the point geom is normally hidden, display it if its selected
				d3Element.classed('point-hidden', isSelected ? false : !self._shouldDisplayPoint.call(self, d));

				// Update the point geom to its default styles or to the selected styles
				// if selected, its being displayed on the inspector line
				d3Element
					.style('fill', isSelected ? color : '#FFF')
					.style('opacity', isSelected ? 1 : '');

				// Build up a map of legend values and formats we can use to set numbers in each legend entry.
				if (isSelected) {
					var seriesId = d3Element.datum().data[self._getPropMapping('series')];
					legendValues[seriesId] = { yVal: datum.y, scaleIndex: seriesNames.indexOf(d.stroke) };
				}
			});

		// Display highlighted values in the legend.
		parent.selectAll('.cv-legend-entry')
			.each(function(d) {
				var key = d.id,
					valueObj = legendValues[key],
					num = d3.select(this).select('.cv-legend-num');

				// If we don't have a value object for this legend entry, it's meant to be blank.
				if (!valueObj) { return num.text(''); }

				// Pull out the format which matches the scaleIndex of the axis.
				var format = self._getYFormatType(valueObj.scaleIndex),
					value = valueObj.yVal, text;

				// Modify time to show in an easier to read gran/format
				if ('time' === format) {
					var l10n = self._dataAdapter.l10n,
						timeGran = self._yTimeGranularity(
							self._dataAdapter.getUniqueStrokeExtentByStroke(key),
							dv.guide.axis().ticks()()),
						time = l10n.time.plural[timeGran.gran],
						pattern = l10n.labels.dvcore.legendTime;

					if (timeGran && timeGran.divisor > 0) { value = value / timeGran.divisor; }
					text = pattern.replace(/\{time\}/i, time)
								.replace(/\{value\}/i, self._formatNumber(format, value, opts.precision));
				} else {
					text = self._formatNumber(format, value, opts.precision);
				}

				num.text(text);
			});
	};

	/**
	 * Determine if data values are equivalent.  If it's a trend we compare milliseconds of the date.
	 */
	line._dataValuesEqual = function(a, b) {
		if (!a || !b) { return false; }
		if (this._dataAdapter.isOvertime() && a.getTime() === b.getTime()) { return true; }
		return a === b; // Equality check for numbers. Returns false here if a.getTime doesn't equal b.getTime as date object refs won't match.
	};

	line._mapPositionScales = function(chart, options) {
		var rangePadding = [0, this._isSmallChart() ? 24 : 6],
			scale = this._constructScale('y').rangePadding(rangePadding),
			strokeMapping = this._getPropMapping('series'),
			yMapping = this._getPropMapping('y'),
			xMapping = this._getPropMapping('x'),
			self = this;

		// Filled charts should scale to zero by default
		if (self._dataAdapter._forceZero === null && options.filled) {
			self._dataAdapter._forceZero = true;
			this._applyForceZero(scale);
		}

		// If we have a dual y axis, let's use the same scale for the left axis for the right axis but give them
		// different includeInDomain functions to train the scales differently.
		if (options.normalized || (options.dualYAxis && (options.position === 'identity' || options.position === 'dodge'))) {
			var uniqueGroups = self._dataAdapter.uniqueStrokeValues();
			// create a includeInDomain for each series
			uniqueGroups.forEach(function(g, index) {
				var strokeScale = (0 === index) ? scale : scale.copy();
				strokeScale.includeInDomain(function(d, i) {
					return d.data[strokeMapping] === self._dataAdapter.uniqueStrokeValues()[index];
				});
				if (index > 0) { chart.map('y', yMapping, strokeScale, index); }
			});
		} else {
			// TODO: We don't currently have a way of explicitly removing a scale in DV. So we reach in and see if there
			// is a yScales object and delete any residual scales left over from the 'dual axis' or 'normalized' options
			// which contain information for training the secondary axis or creating the normalized effect. This will
			// need to be fixed eventually in DV. DV should delete any scale not mapped to a particular axis.
			var yScales = chart.getExplicitScalesMap().y;
			var i = 1;
			while (!!yScales && !!yScales[i]) {
				delete yScales[i];
				i++;
			}
		}

		var xScale = this._dataAdapter.isOvertime() ? dv.scale.time() : options.scales.x === 'log' ? dv.scale.log() : dv.scale.linear();
		xScale.rangePadding([10, 10]);

		chart.map('y', yMapping, scale, 0);
		chart.map('x', xMapping, this._constructScale('x', xScale));
	};

	line._xTickFormat = function() {
		var self = this,
			adapter = this._dataAdapter,
			opts = this._options,
			format = adapter.formats().x;
		return function(d, i) {
			return self._formatNumber(format, d, opts.precision);
		};
	};

	line._drawSmall = function() {
		var options = this._options, chart = this._chart, self = this,
			yExtent = this._computeExtents(),
			dateExtent = d3.extent(this._getEnabledValues('x')),
			yFormat = this._getYFormatType(0),
			yLabelFormat = function(d, i) {
				return d ? self._formatNumber(yFormat, d, options.precision) : '0';
			},
			xAxis = dv.guide.axis()
				.tickSize(0)
				.title(this._dataAdapter.xAxisTitle())
				.tickDy(yExtent.y.length > 1 ? -26 : -14)
				.tickAnchor(function(d, i) { return i > 0 ? 'end' : 'start'; }),
			yAxis = dv.guide.axis().ticks(2).title(this._dataAdapter.yAxisTitle()),

			// If showFullAxis is true, we don't use the high/low point geom, we use a y axis instead.
			showFullAxis = options.dualYAxis || (options.position === 'stack' && this._uniqueGroups.length > 1),
			xScale, yScale;

		xScale = this._dataAdapter.isOvertime() ? dv.scale.time() : options.scales.x === 'log' ? dv.scale.log() : dv.scale.linear();
		yScale = options.scales.y === 'log' ? dv.scale.log() : dv.scale.linear();

		if (!showFullAxis) {
			var layers = [
				dv.geom.point()
					.data(yExtent)
					.set('stroke', 'none')
					.map('y', 'y', yScale)
					.map('x', 'x', xScale)
					.each('start', function(d, i) {
						var colorScale = d.panel.getTrainedScale('fill')[0],
							el = d3.select(this);
						el.style('fill', colorScale.mapValue(d.data.fill))
							.attr('legend-group', d.data.fill);
					})
					.map('group', 'fill')
					.set('size', 6),
				dv.geom.text()
					.data(yExtent)
					.set('stroke', 'none')
					.map('y', 'y', yScale)
					.map('x', 'x', xScale)
					.each('start', function(d, i) {
						var colorScale = d.panel.getTrainedScale('fill')[0],
							el = d3.select(this);
						el.style('fill', colorScale.mapValue(d.data.fill))
							.attr('legend-group', d.data.fill);

						if (this.parentNode) {
							d3.select(this.parentNode.parentNode).classed('no-clip', true).attr('clip-path', null);
						}
					})
					.map('group', 'fill')
					.set('size', '11px')
					.set('label', function(d, i) {
						var seriesDomain = d.panel.getTrainedScale('fill')[0].domain(),
							seriesIndex = seriesDomain.indexOf(d.data.fill),
							lbl = self._yTickFormat(seriesIndex, null, true)(d.y, i, d.panel);
						if ('time' === yFormat) {
							// add the time gran to the label
							var time = self._yTimeGranularity(self._getEnabledValues('y'), dv.guide.axis().ticks()());
							lbl += ' ' + self._dataAdapter.l10n.time.plural[time.gran]; // localize
						}
						return lbl;
					})
					.textAnchor(function(d, i) {
						return d.data && d.data.anchor || 'middle';
					})
					.dy(function(d, i) {
						return (yExtent.y.length === 1 || d.y === yExtent.y[1]) ? -8 : 15;
					})
					.dx(function(d, i) {
						return (d.data && d.data.anchor == 'end') ? 3 : 0;
					})
			];
			chart.layers(chart.layers().concat(layers));
		}

		chart.map('fill', this._getPropMapping('series'), dv.scale.color().values(options.colors));

		if (this._dataAdapter.isOvertime()) {
			xAxis.tickValues(dateExtent).tickFormat(self._timeSmallXFormat());

			if (showFullAxis) {
				yAxis.tickFormat(this._yTickFormat(0));
			} else {
				yAxis.tickFormat(function() { return ''; });
			}
		} else {
			if (options.dualYAxis) {
				// Add a secondary y axis oriented right.  Inset the labels on both axes, and place the labels above the ticks.
				var yAxis2 = dv.guide.axis().tickFormat(this._yTickFormat(1)).orientation('right').tickSize(this._tickSize('y')).tickDy(-8).tickAnchor('end').tickDx(4).ticks(3);
				yAxis.tickSize(this._tickSize('y')).tickDy(-8).tickAnchor('start').tickDx(4).ticks(3);
				chart.guide('y', yAxis2, 1);
			} else {
				var xExtent = d3.extent(this._dataAdapter.data()[this._getPropMapping('x')]);
				xAxis.tickValues(xExtent).tickFormat(this._xTickFormat());
				yAxis.tickFormat(this._yTickFormat(0));
				chart.guide('y', 'none', 1);
			}
		}

		chart.guide('x', xAxis).guide('y', yAxis);

		this._checkNormalized();
	};

	/**
	 * Overrides the default behavior in dvcore to provide a custom number of ticks for time series data on the x axis.
	 * The function returned by this method is called by DV's dv.guide.axis.  DV passes the range to this function and
	 * the function returns how many ticks should be able to fit in that amount of range space.
	 *
	 * @return {function(number):number} A function called by dv.guide.axis which passes in the amount of space and
	 * expects a number of ticks to be returned.
	 */
	line._numXTicks = function() {
		var self = this;
		// If we're overtime, calculate x ticks differently than the default
		if (this._dataAdapter.isOvertime()) {
			var points = this._chart._data[this._getPropMapping('x')].length;

			return function(range) {
				var ticks = 0;
				// Determine the number of ticks with a minimum size
				// Max number of ticks is the number of points
				// We need at least 2 ticks (one for each end)
				var size = Math.max(range / points, self._minTrendTickSpace);
				return Math.max(Math.min(Math.floor(range / size), points), 2);
			};
		}
		// Use the default if the x axis isn't overtime
		return Object.getPrototypeOf(line)._numXTicks.call(this);
	};

	line._drawLarge = function() {
		var options = this._options, chart = this._chart,
			d3Parent = d3.select(options.parent),
			useSecondAxisLabelForArrow = false,
			uniqueStrokeExtent0 = this._dataAdapter.getUniqueStrokeExtent(0),
			uniqueStrokeExtent1 = this._dataAdapter.getUniqueStrokeExtent(1),
			yTickFormatFunc,
			xAxis = dv.guide.axis()
				.ticks(this._numXTicks())
				.title(this._dataAdapter.xAxisTitle())
				.tickSize(this._tickSize('x'))
				.tickDy(-8)
				.tickAnchor(this._xTickAnchor(chart)),
			yAxis = dv.guide.axis().htmlLabels(true);

		if (this._dataAdapter.isOvertime()) {
			xAxis.tickFormat(this._timeXTickFormat()).htmlLabels(true);
		} else {
			xAxis.tickFormat(this._xTickFormat());
		}

		if (options.dualYAxis && (options.position === 'identity' || options.position === 'dodge')) {
			yTickFormatFunc = this._yTickFormat(0, uniqueStrokeExtent0);
			yAxis.title(this._yTitleFormat(0, uniqueStrokeExtent0));

			// Add a secondary y axis oriented right.  Make the ticks extend a few pixels in.
			var yAxis2 = dv.guide.axis().tickFormat(this._yTickFormat(1, uniqueStrokeExtent1)).title(this._yTitleFormat(1, uniqueStrokeExtent1)).orientation('right').tickSize(this._tickSize('y'));
			yAxis.tickSize(this._tickSize('y'));
			chart.guide('y', yAxis2, 1);
		}
		else {
			yTickFormatFunc = this._yTickFormat(0);
			yAxis.title(this._yTitleFormat(0));
			yAxis.tickSize(this._tickSize('y'));
			chart.guide('y', 'none', 1); // Clear out secondary axis
		}

		yAxis.tickFormat(yTickFormatFunc);
		chart.guide('x', xAxis).guide('y', yAxis);
		this._checkNormalized();
	};

	line._preRender = function() {
		Object.getPrototypeOf(line)._preRender.call(this);
		this._displayPoints = null; // reset flag
	};

	line._computeExtents = function() {
		var i = -1, options = this._options,
			yTuple = this._getEnabledValues('y'),
			xTuple = this._getEnabledValues('x'),
			strokeTuple = this._getEnabledValues('series'),
			n = yTuple.length,
			extent = {
				x: [undefined, undefined],
				y: [undefined, undefined],
				fill: [undefined, undefined],
				anchor: [undefined, undefined]
			}, xLowerLimit = null, xUpperLimit = null;
		xTuple.forEach(function(v, i) {
			xLowerLimit = (xLowerLimit === null || xLowerLimit > v) ? v : xLowerLimit;
			xUpperLimit = (xUpperLimit === null || xUpperLimit < v) ? v : xUpperLimit;
		});
		// todo: also we would need to determine if the lower/upper for the x were set hard rather than based on data
		while (++i < n) {
			var yVal = yTuple[i],
				xVal = xTuple[i],
				color = strokeTuple ? strokeTuple[i] : options.colors[0];
			if (extent.y[0] === undefined || yVal < extent.y[0]) {
				extent.y[0] = yVal;
				extent.x[0] = xVal;
				extent.fill[0] = color;
				extent.anchor[0] = ( +xVal == +xLowerLimit ) ? 'start' : ( +xVal == +xUpperLimit ) ? 'end' : 'middle' ;
			}
			if (extent.y[1] === undefined || yVal > extent.y[1]) {
				extent.y[1] = yVal;
				extent.x[1] = xVal;
				extent.fill[1] = color;
				extent.anchor[1] = ( +xVal == +xLowerLimit ) ? 'start' : ( +xVal == +xUpperLimit ) ? 'end' : 'middle' ;
			}
		}

		// if the lower limit is zero, don't display it.
		if (extent.y[0] === 0) {
			extent.y.splice(0, 1);
			extent.x.splice(0, 1);
			extent.fill.splice(0, 1);
			extent.anchor.splice(0, 1);
		}
		return extent;
	};

	line._isNormalized = function() {
		var options = this._options,
			tooManySeries = this._isSmallChart() ? 1 : 2;
		return options.normalized || (options.dualYAxis && this._dataAdapter.uniqueStrokeValues().length > tooManySeries && (options.position === 'identity' || options.position === 'dodge'));
	};

	global.cloudViz.line = cloudViz.util.createConstructor(line);
}(this));

/**
 * Scatter Plot Chart
 * A scatter plot shows points across multiple metrics/labels
 * Parameters
 * options: customization parameters for the point chart
 **/
(function (global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, dvcore = cloudViz.dvcore || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		point = Object.create(dvcore);


	point.init = function (options) {
		Object.getPrototypeOf(point).init.apply(this, arguments);

		this._type = 'point';
		this._chart = dv.chart();
		return this;
	};

	/**
	 * Returns the currently selected points
	 *
	 * @returns {Array}
	 */
	point.getSelected = function () {
		var selectedPoints = [],
			selected = d3.select(this._options.parent).selectAll('.point-geom.cv-highlight');
		selected.each(function (point) {
			selectedPoints.push(point);
		});
		return selectedPoints;
	};

	/**
	 * Selects and highlights the points that match the given selector function
	 *
	 * @param selectedIds
	 * @returns {point}
	 */
	point.setSelected = function (selectorFn) {
		var self = this,
			selectedPoints = [],
			selected = d3.select(this._options.parent).selectAll('.point-geom').filter(selectorFn);
		selected.each(function (point) {
			selectedPoints.push(point);
		});
		self._selectPoints(selectedPoints);
		return self;
	};

	/**
	 * Highlights the given selection
	 *
	 * @param selection
	 * @returns {point}
	 * @private
	 */
	point._selectPoints = function (selection, policy) {
		var self = this;
        if (!policy || !policy.accumulate )
        {
            if (!policy || selection.length !==0 )
            {
                d3.select(self._options.parent).selectAll('.point-geom').each(function (d) {
                    if (selection.indexOf(d) >= 0) {
                        self._highlight(d3.select(this), true);
                    } else {
                        self._highlight(d3.select(this), false);
                    }
                });
            }
            else if( policy.noneSelected === "selectAll")
            {
                self._highlight(d3.select(self._options.parent).selectAll('.point-geom'), true);
            }
        } else if (policy.action === "add")
        {
            d3.select(self._options.parent).selectAll('.point-geom').each(function (d) {
                if (selection.indexOf(d) >= 0) {
                    self._highlight(d3.select(this), true);
                }
            });
        }
        else if (policy.action === "remove")
        {
            d3.select(self._options.parent).selectAll('.point-geom').each(function (d) {
                if (selection.indexOf(d) >= 0) {
                    self._highlight(d3.select(this), false);
                }
            });
        }

		return self;
	};

	point._initDefaultOptions = function () {
		var defaults = {
			mappings: {
				// The value to be used as the size of the point if its a bubble
				size: 'size'
			},
			// Label to be used to designate what the size represents (bubble)
			// If left blank, size will not be used (scatterplot)
			sizeTitle: '',
			formats: { // The format each series should be displayed with.  Options are decimal (default), percent, currency, time.
				x: 'decimal',
				y: 'decimal', // The y format can also be an array of formats for each individual series.
				size: 'decimal'
			},
			scales: {
				x: 'default',
				y: 'default'
			},
			position: 'identity', // shouldn't be changed.
			selectionEnabled: false, // set the select brush on or off
			selectPolicyCB: function(){return {"start":null,"end":null,"move":null};}, // select Policy call back
			tooltipContent: null // a function which will be called when a tooltip is shown. Should return an HTML formatted string which will be displayed in the chart.
		};
		return Object.getPrototypeOf(point)._initDefaultOptions.call(this, defaults);
	};

	/**
	 * Common draw method for all point charts
	 **/
	point._setChartTypeOptions = function () {
		var chart = this._chart, options = this._options, layers = [],
			self = this;

		// Create each of the point geoms
		// Attach legend-group to tie them to a specific series for later interactivity
		layers[0] = dv.geom.point()
			.each('start', function (d, i) {
				// Data here is the translated DV object, so use fill which will equate to series
				d3.select(this).attr('legend-group', d['fill']);
			});

		// Construct the mappings for each aesthetic
		// Add a legend for the series
		chart.layers(layers)
			.map('x', this._getPropMapping('x'), this._constructScale('x')
				.rangePadding([this._isSmallChart() ? 10 : 20, this._isSmallChart() ? 10 : 20]))
			.map('y', this._getPropMapping('y'), this._constructScale('y')
				.rangePadding([this._isSmallChart() ? 10 : 20, this._isSmallChart() ? 10 : 20]))
			.map('fill', this._getPropMapping('series'), dv.scale.color().values(options.colors))
			.guide('fill', this._legend)
			.padding({ left: 10 });

		// Set the size relative to the value if its a bubble chart, otherwise its static
		if (this._dataAdapter.isBubble()) {
			layers[0].map('size', this._getPropMapping('size'), dv.scale.linear().to([9, 60]));
		} else { // otherwise a scatterplot, style them a little differently
			layers[0].set('size', 10).set('alpha', 0.6);
		}

		this._addBehaviors(chart, layers[0], options);
	};

	/**
	 * Adds custom interactive behaviors to the chart.
	 */
	point._addBehaviors = function (chart, geom, options) {
		var d3Parent = d3.select(options.parent), timer, self = this,
			yFormat = this._getYFormatType(),
			addMetricValue = function (d, scale, format, title) {
				if (!d.data.hasOwnProperty(scale.mapping())) {
					return '';
				}
				return '<span class="metric-value">' + format(d.data[scale.mapping()]) + '</span><span class="metric-name">' + title + '</span>';
			},
			selectionBrush = function (type, extent, brush) {
				var newSelectionPoints = [];
				d3.select(options.parent).selectAll(".point-geom").each(function (d, i) {
					if (extent[0][0] <= d.x && extent[1][0] >= d.x && extent[0][1] <= d.y && extent[1][1] >= d.y) {
						if (self._seriesState.isSeriesEnabled(d.data.group, 'standard') ||
							self._seriesState.isSeriesEnabled(d.data[self._getPropMapping('series')], 'standard')) { // If point is visible
							newSelectionPoints.push(d);
						}
					}
				});

				var selectPolicy = self._options.selectPolicyCB.call();

				self._selectPoints(newSelectionPoints, selectPolicy[type]);

				if (self._eventMap['selectionStart'] && type === 'start') {
					self._eventMap['selectionStart'].call(self, newSelectionPoints);
				}

				if (self._eventMap['selectionEnd'] && type === 'end') {
					self._eventMap['selectionEnd'].call(self, newSelectionPoints);
				}
			};

		if (options.selectionEnabled) {
			chart.behaviors([
				dv.behavior.brush().brushStart(selectionBrush).brushMove(selectionBrush).brushEnd(selectionBrush)
			]);
		} else {
			chart.behaviors([]);
		}

		// The chart must not be small and must be interactive in order to receive an inspector.
		if (!this._isSmallChart() && options.interactive) {
			geom.behaviors([
				dv.behavior.voronoiRollover()
					.pointDetectionRadius(25)
					.content(function (d, i, j) {
						if (options.tooltipContent) {
							return options.tooltipContent.call(this, d, i, j);
						}

						var seriesGroup = this.__geom.getExplicitScale('group'),
							x = d.panel.xScale(d),
							y = d.panel.yScale(d),
							xGuide = this._xGuides[x.scaleIndex()],
							yGuide = this._yGuides[y.scaleIndex()],
							l10n = self._dataAdapter.l10n,
							xTickFormat = (xGuide.__scale && xGuide.tickFormat() ? xGuide.tickFormat() : String),
							yTickFormat = function (d) {
								return self._formatNumber(yFormat, d, options.precision); // allow 0, as opposed to yGuide
							},
							content = addMetricValue(d, y, yTickFormat, self._dataAdapter.yAxisTitle() || l10n.labels.point.yScale) +
								addMetricValue(d, x, xTickFormat, self._dataAdapter.xAxisTitle() || l10n.labels.point.xScale);

						if (self._dataAdapter.isBubble()) {
							var size = d.panel.getTrainedScale('size')[0];
							content += addMetricValue(d, size, String, self._dataAdapter.sizeMetricName() || l10n.labels.point.sizeScale);
						}

						if (seriesGroup && seriesGroup.mapping()) {
							content = '<span class="series-name">' + d.data[seriesGroup.mapping()] + '</span>' + content;
						}

						return content;
					})
					.mouseOver(function (d, i, j, ev) {
						clearTimeout(timer);
						d3Parent.selectAll('.point-geom')
							.classed('cv-medium-duration', false)
							.classed('cv-unselected', function (pointD) {
								return d !== pointD;
							});
						d3Parent.selectAll('.cv-legend-marker')
							.classed('cv-unselected', function (legendD) {
								return legendD.id !== d.fill;
							})
							.classed('cv-medium-duration', false);

						if (self._eventMap['mouseover']) {
							self._eventMap['mouseover'].call(this, d, i, j, ev);
						}
					})
					.mouseOut(function (d, i, j, ev) {
						timer = setTimeout(function () { // Don't use d3 transitions here.  They can override transitions that occur when moving/sizing a point which makes them freeze in place.
							d3Parent.selectAll('.point-geom, .cv-legend-marker')
								.classed('cv-unselected', false)
								.classed('cv-medium-duration', true);

							if (self._eventMap['mouseout']) {
								self._eventMap['mouseout'].call(this, d, i, j, ev);
							}
						}, 400);
					})
			]);
		}
	};

	point._drawSmall = function () {
		var chart = this._chart,
			xExtent = d3.extent(this._getEnabledValues('x')),
			self = this,
			adapter = this._dataAdapter,
			opts = this._options,
			xFormat = adapter.formats().x,
			yFormat = this._getYFormatType();

		chart.guide('x', dv.guide.axis().tickSize(0).tickValues(xExtent).title(this._dataAdapter.xAxisTitle()).tickFormat(function (d) {
				return self._formatNumber(xFormat, d, opts.precision);
			}).tickAnchor(function (d, i) {
				return i > 0 ? 'end' : 'start';
			}))
			.guide('y', dv.guide.axis().ticks(2).title(this._dataAdapter.yAxisTitle()).tickFormat(this._yTickFormat(0)));
	};

	point._drawLarge = function () {
		var chart = this._chart,
			numYTicks = function (range) {
				return Math.max(2, Math.min(5, range / 70));
			},
			self = this,
			adapter = this._dataAdapter,
			opts = this._options,
			xFormat = adapter.formats().x,
			yFormat = this._getYFormatType();

		chart.guide('x', dv.guide.axis().ticks(this._numXTicks()).title(this._dataAdapter.xAxisTitle()).tickFormat(function (d) {
				return self._formatNumber(xFormat, d, opts.precision);
			}))
			.guide('y', dv.guide.axis().ticks(numYTicks).tickSize(this._tickSize('y')).title(this._dataAdapter.yAxisTitle()).tickFormat(this._yTickFormat(0)));
	};

	point._postRender = function () {
		Object.getPrototypeOf(point)._postRender.call(this);
		var options = this._options, chart = this._chart,
			rightPadding = 5,
			container = d3.select(options.parent).select('.cv-wrapper'),
			label = container.selectAll('.cv-bubble-size-metric').data([0]);
		if (this._dataAdapter.sizeMetricName()) {
			label.enter().append('div').classed('cv-bubble-size-metric', true).html('<span>' + this._dataAdapter.sizeMetricName() + '</span>  <i></i> &ndash; <i></i>');
			setTimeout(function () {
				// Will break on multiple facets (but this should be done in DV anyway)
				var padding = chart.padding(),
					lastPanelBounds = chart.facet().getPanel(chart.facet()._panels.length - 1).bounds(), // minus axis
					plotBounds = chart.plotBounds(), // actual plot bounds
					span = label.selectAll('span'),
					width = plotBounds.right + padding.right,
					height = lastPanelBounds.top + lastPanelBounds.height,
					node = label.node(),
					x, y;

				if (node) {
					x = width - node.offsetWidth - rightPadding,
					y = height - node.offsetHeight;
					label.style('top', y + 'px').style('left', x + 'px');
				}
			}, 300);


		} else {
			label.remove();
		}
	};

	global.cloudViz.point = cloudViz.util.createConstructor(point);
}(this));
/**
 * Bar Chart
 * A bar chart shows bar plots with multiple series across categories
 * Parameters
 * options: customization parameters for the bar chart
 * options are defined in the core object, bar specific are below in 'Bar Options'
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, dvcore = cloudViz.dvcore || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		bar = Object.create(dvcore);

	bar.init = function(options) {
		Object.getPrototypeOf(bar).init.apply(this, arguments);

		this._type = 'bar';
		this._chart = dv.chart();
		this._minTickSpace = 60;
		return this;
	};

	bar._initDefaultOptions = function() {
		var defaults = {
			// All series have their own y-scale if true
			normalized: false,
			position: 'dodge',
			dualYAxis: false,
			clickHandler: null, // Deprecated... please use .on('click', function) instead.
			formats: { // The format each series should be displayed with.  Options are decimal (default), percent, currency, time.
				x: 'decimal',
				y: 'decimal' // The y format can also be an array of formats for each individual series.
			},
			tooltipContent : null // a function which will be called when a tooltip is shown. Should return an HTML formatted string which will be displayed in the chart.
		};

		return Object.getPrototypeOf(bar)._initDefaultOptions.call(this, defaults);
	};

	bar.reset = function() {
		Object.getPrototypeOf(bar).reset.apply(this, arguments);

		var options = this._options,
			d3Parent = d3.select(options.parent);
		d3Parent.selectAll('.axis-y.axis-index-1').remove();
	};

	/**
	 * Common draw method for all bar charts
	 **/
	bar._setChartTypeOptions = function() {
		var chart = this._chart, options = this._options;

		chart.layers([
				dv.geom.bar()
					.each('start', function(d, i) {
						// Data here is the translated DV object, so use fill which will equate to series
						d3.select(this).attr('legend-group', d['fill']);
					})
			])
			.map('fill', this._getPropMapping('series'), dv.scale.color().values(options.colors))
			.guide('fill', this._legend)
			.position(options.position)
			.coord(dv.coord.cartesian().flip(options.flip));

		// handle clicks if a callback is passed in
		chart._layers[0].on('click', this._eventMap['click'] ? this._eventMap['click'] : null);

		this._addBehaviors(chart.layers()[0], options);
		this._mapPositionScales(chart, options);
	};

	bar._mapPositionScales = function(chart, options) {
		var isSmall = this._isSmallChart(),
			rangePadding = [0, isSmall ? 10 : 15],
			scale = this._applyForceZero(this._constructScale('y')).rangePadding(rangePadding),
			fillMapping = this._getPropMapping('series'),
			yMapping = this._getPropMapping('y'),
			xMapping = this._getPropMapping('x'),
			xInnerPadding = isSmall ? Math.max(0.3, Math.min(0.6, this._getChartWidth() / this._dataAdapter.uniqueXValues().length / 200)) : Math.min(0.6, Math.max(0.05, this._getChartWidth() / 4000)),
			xOuterPadding = isSmall ? 0.3 : 0.5,
			self = this;

		// If it's a histogram, there should be no padding between bars.
		if (this._dataAdapter.isOvertime()) {
			xInnerPadding = 0.05;
		}

		if (options.normalized || (options.dualYAxis && (this._options.position === 'identity' || this._options.position === 'dodge'))) {
			var uniqueGroups = self._dataAdapter.uniqueFillValues();
			// create a includeInDomain for each series
			uniqueGroups.forEach(function(g, index) {
				var fillScale = (0 === index) ? scale : scale.copy();
				fillScale.includeInDomain(function(d, i) {
					return d.data[fillMapping] === self._dataAdapter.uniqueFillValues()[index];
				});
				if (index > 0) { chart.map('y', yMapping, fillScale, index); }
			});
		} else {
			// TODO: We don't currently have a way of explicitly removing a scale in DV. So we reach in and see if there
			// is a yScales object and delete any residual scales left over from the 'dual axis' or 'normalized' options
			// which contain information for training the secondary axis or creating the normalized effect. This will
			// need to be fixed eventually in DV. DV should delete any scale not mapped to a particular axis.
			var yScales = chart.getExplicitScalesMap().y;
			var i = 1;
			while (!!yScales && !!yScales[i]) {
				delete yScales[i];
				i++;
			}
		}
		chart.map('y', yMapping, scale, 0);
		chart.map('x', this._getPropMapping('x'), dv.scale.ordinal().padding(xInnerPadding).outerPadding(xOuterPadding).reverse(options.flip));
	};

	/**
	 * Adds custom interactive behaviors to the chart.
	 */
	bar._addBehaviors = function(geom, options) {
		var d3Parent = d3.select(options.parent),
			timer, adapter = this._dataAdapter,
			self = this;

		// The chart must not be small and must be interactive in order to receive an inspector.
		if (!this._isSmallChart() && options.interactive) {
			geom.behaviors([
				dv.behavior.rollover()
					.orientation(options.flip ? 'top' : 'right')
					.content(function(d, i, j) {
						if (options.tooltipContent) {
							return options.tooltipContent.call(this, d, i, j);
						}
						var seriesGroup = this.__geom.getExplicitScale('group'),
							y = d.panel.yScale(d),
							valueFormat = self._yLabelFormat(y.scaleIndex()),
							content = '<span class="metric-value">' + valueFormat(d.y) +
								'</span><span class="metric-name">' + d.data[self._getPropMapping('seriesLabel')] + '</span>',
							gran = adapter.dateGranularity(),
							format = adapter.l10n.dateFormat.fullFormat,
							xLabel = adapter.isOvertime() ? self._formatTime(new Date(d.x), self._timeGranTemplate(gran, format), gran) : d.x;

						if (seriesGroup && seriesGroup.mapping()) {
							content = '<span class="series-name">' + xLabel + '</span>' + content;
						}

						return content;
					})
					.showTooltip(function(d, i, j, ev, behavior) {
						var el = d3.select(this);

						// Only active bars can show a tooltip.
						if (!el.classed('path-inactive')) {
							behavior._showTip.call(this, d, i, j, behavior);
							clearTimeout(timer);
							d3Parent.selectAll('.bar-geom')
								.classed('cv-medium-duration', false)
								.classed('cv-unselected', function(pointD) { return d !== pointD; });
							d3Parent.selectAll('.cv-legend-marker')
								.classed('cv-unselected', function(legendD) { return legendD.id !== d.fill; })
								.classed('cv-medium-duration', false);

							if (self._eventMap['mouseover']) {
								self._eventMap['mouseover'].call(this, d, i, j, ev);
							}
						}
					})
					.hideTooltip(function(d, i, j, ev, behavior) {
						var el = d3.select(this);

						// Only active bars can hide the tooltip.
						if (!el.classed('path-inactive')) {
							behavior._removeTip.call(this, d, i, j, behavior);
							timer = setTimeout(function() { // Don't use d3 transitions here.  They can override transitions that occur when moving/sizing a bar which makes them freeze in place.
								d3Parent.selectAll('.bar-geom, .cv-legend-marker')
									.classed('cv-unselected', false)
									.classed('cv-medium-duration', true);

								if (self._eventMap['mouseout']) {
									self._eventMap['mouseout'].call(this, d, i, j, ev);
								}
							}, 400);
						}
					})
			]);
		}
	};

	bar._drawSmall = function() {
		var chart = this._chart, options = this._options, xAxis,
			threshold = (options.flip) ? undefined : 10,
			self = this;
		if (options.flip) {
			xAxis = dv.guide.axis()
						.tickDx(function(d, i) { return d3.select(this).select('span').node().offsetWidth; })
						.tickDy(function(d, i) { return -d3.select(this).select('span').node().offsetHeight; })
						.tickSize(0);
		} else {
			xAxis = dv.guide.axis().tickSize(0).tickDy(function(d, i) { return (i % 2 === 0) ? -8 : -26; });
		}

		if (this._dataAdapter.isOvertime()) {
			xAxis.tickValues(d3.extent(this._dataAdapter.data()[this._getPropMapping('x')]))
				.tickFormat(self._timeSmallXFormat())
				.tickAnchor(function(d, i) { return i > 0 ? 'end' : 'start'; })
				// offset the start and end ticks so they are left aligned on the left edge of the first bar, and
				// right aligned on the right edge of the last bar respectively.
				.tickDx(function(d, i) {
					var rangeBand = chart.getTrainedScale('x').rangeBand() / 2;
					return i > 0 ? rangeBand : -rangeBand;
				})
				.tickDy(-8);
		} else {
			xAxis.tickFormat(function(d, i){ return self._truncateLabel(d, threshold); });
		}

		chart.guide('x', xAxis.title(this._dataAdapter.xAxisTitle()))
			.guide('y', dv.guide.axis().ticks(0).tickSize(0).tickFormat(function(d, i) { return ''; }).title(this._dataAdapter.yAxisTitle()));

		this._checkNormalized();
	};

	bar._drawLarge = function() {
		var chart = this._chart, options = this._options, self = this,
			numYTicks = function(range) { return Math.max(2, Math.min(5, range / 75)); },
			xAxis = dv.guide.axis().tickSize(0),
			yAxis = dv.guide.axis().ticks(numYTicks),
			yAxis2;

		if (options.dualYAxis && (this._options.position === 'identity' || this._options.position === 'dodge')) {
			var uniqueFillExtent0 = self._dataAdapter.getUniqueFillExtent(0),
				uniqueFillExtent1 = self._dataAdapter.getUniqueFillExtent(1);
			yAxis.tickSize(this._tickSize('y')).tickFormat(this._yTickFormat(0, uniqueFillExtent0)).title(this._yTitleFormat(0, uniqueFillExtent0));
			yAxis2 = dv.guide.axis().ticks(numYTicks).tickFormat(this._yTickFormat(1, uniqueFillExtent1)).title(this._yTitleFormat(1, uniqueFillExtent1)).orientation('right').tickSize(this._tickSize('y'));
			chart.guide('y', yAxis2, 1);
		} else {
			yAxis.tickFormat(this._yTickFormat(0)).title(this._yTitleFormat(0));
			chart.guide('y', 'none', 1);
		}

		if (options.flip) {
			xAxis.tickDx(-10);
		} else {
			xAxis.tickDy(function(d, i) { return (i % 2 === 0) ? -8 : -26; });
			yAxis.tickDx(-10);
			if (yAxis2) { yAxis2.tickDx(-10); }
		}

		if (this._dataAdapter.isOvertime()) {
			// Only used on histogram, so we assume x is a date object
			var dates = {}, points = 0;
			chart._data[this._getPropMapping('x')].forEach(function(d, i) {
				if ( !dates[+new Date(d)] ) {
					points++;
					dates[+new Date(d)] = 1;
				}
			});
			xAxis.tickDy(-8).tickFormat(this._timeXTickFormat(points)).htmlLabels(true);
		} else {
			xAxis.tickFormat(function(d, i){ return self._truncateLabel(d); });
		}

		chart.guide('x', xAxis.title(this._dataAdapter.xAxisTitle()))
			.guide('y', yAxis);

		this._checkNormalized();
	};

	// Indicates whether a label is valid and therefore should be shown or not. This is done by roughly
	// estimating whether labels would collide and if they would we drop some.
	bar._timeXTickValidator = function(points) {
		var self = this;
		return function(d, i) {
			var xScale = self._chart.getTrainedScale('x'),
				xRange = dv.util.scaleRange(xScale),
				width = xRange[1] - xRange[0],
				minTickWidth = Math.ceil(self._minTickSpace / (width / points));
			return i % minTickWidth === 0;
		};
	};

	bar._timeXTickFormat = function(points) {
		return Object.getPrototypeOf(bar)._timeXTickFormat.call(this, this._timeXTickValidator(points));
	};

	bar._isNormalized = function() {
		var options = this._options,
			tooManySeries = this._isSmallChart() ? 1 : 2;
		return options.normalized || (options.dualYAxis && this._dataAdapter.uniqueFillValues().length > tooManySeries && (options.position === 'identity' || options.position === 'dodge'));
	};

	global.cloudViz.bar = cloudViz.util.createConstructor(bar);
}(this));
/**
 * Donut Chart
 * A donut chart shows a bar chart in polar coordinates (pie chart) with an inner radius
 * The donut's slices are the categories/filters and each are displayed in a legend
 * Each donut represents a single metric
 * Parameters
 * options: customization parameters for the bar chart
 * options are defined in the core object, donut specific are below in 'Donut Options'
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, dvcore = cloudViz.dvcore || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		donut = Object.create(dvcore);

	donut.init = function(options) {
		Object.getPrototypeOf(donut).init.apply(this, arguments);

		this._type = 'donut';
		this._chart = dv.chart();
		return this;
	};

	donut._initDefaultOptions = function() {
		var defaults = {
			sort: 'descending', // sort order 'descending' - largest first or 'ascending' - smallest first or 'none'
			maxSlices: 6, // maximum number of slices shown, if more aggregate x+ into other category
			innerRadius: '45%', // radius to white out in the middle of the pie chart
			outerRadius: '35%', // radius to white out on the edge of the screen
			clickHandler: null, // Deprecated... please use .on('click', function) instead.
			formats: { // The format each series should be displayed with.  Options are decimal (default), percent, currency, time.
				x: 'decimal',
				y: 'decimal' // The y format can also be an array of formats for each individual series.
			},
			tooltipContent : null // a function which will be called when a tooltip is shown. Should return an HTML formatted string which will be displayed in the chart.
		};
		return Object.getPrototypeOf(donut)._initDefaultOptions.call(this, defaults);
	};

	donut._buildLegend = function() {
		var self = this,
			options = this._options,
			legend = Object.getPrototypeOf(donut)._buildLegend.call(this, 'x', 'x');

		// Set labels data, determine our current state
		this._dataAdapter.processLabelData(legend);

        if (legend !== 'none') {
            // legend
            if (this._dataAdapter.numberOfFacets() == 1) {
				var legendValues = this._dataAdapter.labelData().cvtextvallabel.map(function(d, i) {
					return self._yLabelFormat(0)(d);
				});
                legend.values(legendValues);
            } else {
				legend.values([]); // remove any previous legend values
			}
            // Add some extra padding to the bottom of the non-interactive legend so it doesn't interfere with facet labels
            if (!options.interactive && (!options.legendOrientation || options.legendOrientation === 'top')) {
                legend.padding({ 'bottom': 20 });
            }
        }

		return legend;
	};

	/**
	 * Sums the values of all the categories of the donut and formats it
	 * This value is normally displayed in the middle of the chart
	 * @param {string} series
	 * @returns {string} formatted sum value
	 * @private
	 */
	donut._getSeriesTotal = function(series) {
		var adapter = this._dataAdapter, data = adapter.data(),
			values = data[this._getPropMapping('y')],
			labels = data[this._getPropMapping('series')],
			i, ii = labels.length, total = 0;
		for (i=0; i<ii; ++i) {
			if (labels[i]+'' === series+'') {
				total += values[i];
			}
		}
		return total;
	};



	/**
	 * Creates the series states which will be used to populate the legend and will dispatch events when their
	 * internal state changes.
	 */
	donut._createSeriesStates = function() {
		// TODO: We shouldn't override dvcore._createSeriesStates(), but we have to. The reason this is done is because the 'series'
		// and 'seriesLabel' properties are actually referring to the facets and not the series labels represented in the legend. In
		// reality, we should have 'facet' and 'facetLabel' mappings.  Right now the 'x' property mapping is what I have to use, but
		// there is no corresponding 'id' so uniqueness can't be guaranteed.  There is probably a bug if I have two donut series
		// called "Page Views" for instance.  If we make sure that 'series' and 'seriesLabel' refer to the actual series, then donut
		// will match how all other chart types are working currently.  Then this override is redundant.
		//
		// When this happens we can also get rid of the call for legend.mapping() which grabs the scale we are using to determine
		// grouping (identifing series).  At that point, this._getPropMapping('seriesLabel') should give us the appropriate mapping
		// and we can remove legend.mapping().
		var options = this._options;

		if ('data' in this._changedOptions && this._changedOptions.data) {
			// Remove old states
			this._seriesState.removeStatesByType('standard');
			var seriesNames = dv.util.uniq(this._dataAdapter.data()[this._getPropMapping('x')]);
			// Need to insert new states in reverse order since we are inserting them and want them to be first in the legend etc.
			var i = seriesNames.length;
			while (i--) {
				var seriesName = seriesNames[i];
				this._seriesState.insertState(seriesName, seriesName, 'standard');
			}
		}

		if ('targetValues' in this._changedOptions) {
			if (options.targetValues) { // Add a target series state
				// Remove previously added target states
				this._seriesState.removeStatesByType('target');
				// If the targetLabel is undefined, set it to the localized target default label.
				this._seriesState.appendState(options.targetLabel || this._dataAdapter.l10n.labels.dvcore.target, 'target', 'target');
			}
		}
	};

	/**
	 * Sums the value of a category
	 * This value is normally displayed in the legend of a single metric chart
	 * This method is called from dvcore's legend code
	 *
	 * @param {string} category
	 * @returns {string} formatted sum value
	 * @private
	 */
	donut._getCategoryTotal = function(cat) {
		// We only show totals in the legend if there is only a single donut in the chart.
		if (this._dataAdapter.numberOfFacets() !== 1) { return ''; }

		var data = this._dataAdapter.data(),
			values = data[this._getPropMapping('y')],
			cats = data[this._getPropMapping('x')],
			i, ii = cats.length, total = 0;
		for (i=0; i<ii; ++i) {
			if (cats[i]+'' === cat+'') {
				total += values[i];
			}
		}
		return total;
	};

	/**
	 * Determine if the labels for the categories should be hidden
	 *
	 * @returns {boolean} true to hide
	 * @private
	 */
	donut._shouldHideLabels = function(d) {
		var panelBounds = d.panel.bounds();
		return d.y <= 0.05 || (Math.min(panelBounds.width, panelBounds.height) / 2 < 80);
	};

	/**
	 * Common draw method for all donuts
	 **/
	donut._setChartTypeOptions = function() {
		var chart = this._chart,
			adapter = this._dataAdapter,
			options = this._options,
			d3Parent = d3.select(options.parent),
			self = this, colors = adapter.colors().slice(0);

		if (options.interactive) {
			chart.padding({ 'top': 10 });
		}

		// add other
		if (adapter.showOtherCategory()) {
			colors.splice(options.maxSlices - 1, 0, '#ccc');
		}

		var layers = [
				dv.geom.bar()
					.position('fill')
					.set('stroke', '#fff')
					.each('start', function(d, i) {
						d3.select(this).attr('legend-group', d['fill']);
					})
				];

		// handle clicks if a callback is passed in
		layers[0].on('click', this._eventMap['click'] ? this._eventMap['click'] : null);

		var labelData = self._dataAdapter.labelData();
		layers.push(
			dv.geom.text().data(labelData)
				.map('label', 'cvtextperclabel')
				.set('stroke', 'none')
				.position('fill')
				.textAnchor(function(d, i) {
					var val = (d.y0 + d.y / 2) * 100;
					// hacking the starting position
					if ( val < 50 ) { return 'start'; }
					if ( val > 50 ) { return 'end'; }
					return 'middle';
				})
				.each('start', function(d, i) {
					d3.select(this)
						.classed('slice-label', true)
						.classed('hidden', self._shouldHideLabels.call(self, d))
						.attr('dy', '.35em') // Vertically center the label
						.attr('legend-group', d['fill']);
				})
				// TODO: Fix in DV. When applying the hidden class in .each('start'), there is a slight flicker due to the class being applied
				// on the subsequent frame.  DV might need to make .each('start') synchronous to get past this.
				//
				// Until then, I'm having to apply the alpha and then add !important tags in CSS to override the inline `opacity: 0` style.
				.set('alpha', function(d, i, j) {
					return self._shouldHideLabels.call(self, d) ? 0 : 1;
				})
				.dx(function(d, i) {
					var xrange = d.panel.xOuterScale().range(),
						xDist = xrange[1] - xrange[0],
						radius = xDist ? xDist / 2 : 0,
						outerRadius = dv.util.getPercentValue(options.outerRadius, radius),
						padding = 30, // manual adjusting to get labels further outside the donut
						val = (d.y0 + d.y / 2) * 100;

					// position is adding to a calculated percentage
					// radius gets us to 100% aka on the edge of the visible donut
					// outerRadius moves us into the middle of the outerRadius
					return radius + outerRadius - padding;
				})
				.dy(function(d, i) { // Tweak the rotation of the label so it doesn't get obscurred by a tooltip.
					var position = -d.panel._bounds.width / 2 * d.y,
						val = (d.y0 + d.y / 2) * 100;

					// Add some linear smoothing to the top and bottom centers. The closer we get to the center,
					// the greater the adjustment. It should probably be exponential, but this looks pretty good.
					// Another approach would be to measure the labels and offset them, but I think this might
					// incur more overhead than its worth.
					if (val < 10) {
						position -= (10 - val) / 2;
					}
					if (val > 90) {
						position += (10 - (100 - val)) / 2;
					}
					if (val <= 50 && val > 40) {
						position += (10 - (50 - val)) / 2;
					}
					if (val > 50 && val < 60) {
						position -= (10 - (val - 50)) / 2;
					}

					return position;
				})
		);

		chart.layers(layers)
			.map('group', 'cvdonutorder')
			.map('x', this._getPropMapping('series'), dv.scale.ordinal())
			.map('y', this._getPropMapping('y'), this._constructScale('y'))
			.map('fill', this._getPropMapping('x'), dv.scale.color().values(colors))
			.guide('fill', this._legend)
			.guide(['x', 'y'], 'none')
			.coord(dv.coord.polar().flip(true).innerRadius(options.innerRadius).outerRadius(options.outerRadius))
			.postrender(function() {
				var container = d3.select(options.parent).select('.cv-wrapper'),
					donutLabels = container.selectAll('.cv-donut-facet-labels').data([0]),
					adapter = self._dataAdapter;
				donutLabels.enter().append('div').classed('cv-donut-facet-labels', true);
				donutLabels.exit().remove();
				// Create each facet label
				var donutLabel = donutLabels.selectAll('.cv-donut-facet-label').data(this.facet()._panels),
					donutLabelEnter = donutLabel.enter().append('div').classed('cv-donut-facet-label', true);
				donutLabel.each(function(d, i) {
					// Donut labels are positioned above the donut if not large and in the center of the donut otherwise.
					var bounds = d.bounds(),
						label = d3.select(this),
						radius = Math.min(bounds.width, bounds.height) / 2, // smaller of width or height divided by 2.
						topSpace = bounds.height / 2 - radius, // The amount of space from the top of the panel to the top of the donut.
						innerRadius = dv.util.getPercentValue(options.innerRadius, radius),
						size = innerRadius < 25 ? 'small' : innerRadius > 50 ? 'large' : 'medium',
						width = size === 'large' ? innerRadius * 2 : bounds.width, // todo: this will probably need to be massaged because the circle gets small on the bottom
						left = size === 'large' ? bounds.left + (bounds.width / 2) - (width / 2) : bounds.left,
						top = (size === 'large') ? bounds.top + (bounds.height / 2) - 27 : bounds.top + topSpace - 10; // magic number of height of # and first line of title to vertically center on the baseline of the first line of text

					label.style('top', top + 'px')
						.style('width', width + 'px')
						.style('left', left + 'px')
						.classed('cv-donut-small-facet cv-donut-medium-facet cv-donut-large-facet', false)
						.classed('cv-donut-' + size + '-facet', true);
					var num = label.selectAll('.cv-donut-label-number').data([0]);
					num.enter().append('div').classed('cv-donut-label-number', true);
					var value = self._getSeriesTotal(d.xFacetTitle());
					num.text(self._yLabelFormat(d._facetIndex)(value));
					var title = label.selectAll('.cv-donut-label-title').data([0]);
					title.enter().append('div').classed('cv-donut-label-title', true);
					title.text(adapter.yAxisTitle(d._facetIndex));
					if (size === 'medium') {
						num.style('top', bounds.height / 2 - topSpace + 'px'); // Distance from top label to the center of the donut
					}
				});
				donutLabel.exit().remove();
			});

		this._addBehaviors(layers[0], options);
	};

	/**
	 * Adds custom interactive behaviors to the chart.
	 */
	donut._addBehaviors = function(geom, options) {
		var d3Parent = d3.select(options.parent),
			timer, adapter = this._dataAdapter,
			self = this,
			addMetricValue = function(d, scale, format) {
				if (!d.data.hasOwnProperty(scale.mapping())) { return ''; }
				return '<span class="metric-value">' + format(d.data[scale.mapping()]) + '</span><span class="metric-name">' + scale.mapping() + '</span>';
			};

		// The chart must not be small and must be interactive in order to receive an inspector.
		if (!this._isSmallChart() && options.interactive) {
			geom.behaviors([
				dv.behavior.rollover()
					.content(function(d, i, j) {
						if (options.tooltipContent) {
							return options.tooltipContent.call(this, d, i, j);
						}
						var seriesGroup = this.__geom.getExplicitScale('group'),
							y = d.panel.yScale(d),
							valueFormat = self._yLabelFormat(y.scaleIndex()),
							content = '<span class="metric-value">' + valueFormat(d.data[self._getPropMapping('y')]) +
							'</span><span class="metric-name">' + d.data[self._getPropMapping('seriesLabel')] + '</span>',
							gran = self._dataAdapter.dateGranularity(),
							format = adapter.l10n.dateFormat.fullFormat,
							xLabel = dv.util.isDate(d.fill) ? self._formatTime(d.fill, self._timeGranTemplate(gran, format), gran) : d.fill;
						if (seriesGroup && seriesGroup.mapping()) {
							content = '<span class="series-name">' + xLabel + '</span>' + content;
						}

						return content;
					})
					.showTooltip(function(d, i, j, ev, behavior) {
						var el = d3.select(this);

						// Only active bars can show a tooltip.
						if (!el.classed('path-inactive')) {
							behavior._showTip.call(this, d, i, j, behavior);
							clearTimeout(timer);
							// Dim the donuts and their labels.
							d3Parent.selectAll('.bar-geom')
								.classed('cv-medium-duration', false)
								.classed('cv-unselected', function(pointD) { return d !== pointD; });
							d3Parent.selectAll('.text-geom')
								.classed('cv-medium-duration', false)
								.classed('cv-unselected', function(pointD) { return d.group !== pointD.group; })
								.classed('cv-selected', function(pointD) { return d.group === pointD.group; });
							d3Parent.selectAll('.cv-legend-marker')
								.classed('cv-unselected', function(legendD) { return legendD.id !== d.fill; })
								.classed('cv-medium-duration', false);

							if (self._eventMap['mouseover']) {
								self._eventMap['mouseover'].call(this, d, i, j, ev);
							}
						}
					})
					.hideTooltip(function(d, i, j, ev, behavior) {
						var el = d3.select(this);

						// Only active bars can hide the tooltip.
						if (!el.classed('path-inactive')) {
							behavior._removeTip.call(this, d, i, j, behavior);
							timer = setTimeout(function() { // Don't use d3 transitions here.  They can override transitions that occur when moving/sizing a donut which makes them freeze in place.
								// Make all donuts and their labels opaque.
								d3Parent.selectAll('.bar-geom, .cv-legend-marker')
									.classed('cv-unselected', false)
									.classed('cv-medium-duration', true);
								d3Parent.selectAll('.text-geom')
									.classed('cv-unselected cv-selected', false)
									.classed('cv-medium-duration', true);

								if (self._eventMap['mouseout']) {
									self._eventMap['mouseout'].call(this, d, i, j, ev);
								}
							}, 400);
						}
					})
			]);
		}
	};

	donut._drawSmall = function() {
		var chart = this._chart, options = this._options;
		chart.facet(dv.facet.wrap().group(this._getPropMapping('series')).scales('free').numColumns(1).titleFormat(undefined));
	};

	donut._drawLarge = function() {
		var chart = this._chart;
		chart.facet(dv.facet.wrap().group(this._getPropMapping('series')).scales('free').numColumns(3).titleFormat(undefined));
	};

	global.cloudViz.donut = cloudViz.util.createConstructor(donut);
}(this));

/*global cloudviz,d3,dv*/
(function(global) {
	'use strict';

	/**
	 * The CloudViz interactive legend is passed to DV in place of DV's default legend.  DV kicks off the render cycle by calling _render. The interactive
	 * legend is responsible for creating button-esque legend entries which can be toggled on/off which can be used to update the plot to disable series.
	 *
	 * The interactive legend also provides the ability to manually create legend entries beyond the legend entries specified by the scale registered to
	 * the legend within DV (referred to as "standard" legend entries).
	 */
	global.cloudViz.interactiveLegend = function() {

		var VERT_LEGEND_MARGIN = 10, // margin between the legend and the chart


			// Private variables keeping state of the getter/setters. See comments on the getter/setter functions for details
			// on what these variables do.
			minLegendEntryWidth = 110,
			legendVerticalWidth = 110,
			parent,
			orientation,
			validOrientations = ['top', 'right', 'left'],
			chartWidth,
			chartHeight,
			chartPadding,
			isVertical,
			values,
			type,
			showTargetEntry,
			seriesState,
			interactive = true,

			legendEntryWidth, // The final width of a legend entry taking available size and orientation into consideration
			legendEntries, // A D3 selection of all the legend entry DOM elements
			legend, // The containing D3 selected DOM element which houses the legend

			// An object which tracks the states of all legend entries. It includes both standard and manual legend entries.
			// {'name':String, 'type':String, 'enabled:uint'}
			legendStates = null,
			// An object which tracks the state behind all manually create legend entries.
			// {'name':String, 'type':String, 'classList':String[]}
			manualStates = null,
			mapping, // The mapping of the scale which is bound to this legend

			interactiveLegend = {}; // The instance object for the interactive legend.


		/**
		 * The render routine will be called by DV internally when this legend is specified as the class for the guide.
		 * e.g. .guide('fill', cloudViz.interactiveLegend())
		 *
		 * @param parent {DOMElement} An SVG parent passed from DV. Since these legends are HTML, we disregard this parent and use the parent setter below.
		 * @param scales {dv.scale[]} Mapped scales that will be rendered by this legend supplied by DV.
		 * @param opts {} Options set by DV on the legend. We are disregarding these in favor of the options we set manually.
		 */
		interactiveLegend._render = function(parent, scales, opts) {
			this._initSVG(scales);
			this._sizeAndPositionLegendEntries();
			this._positionLegend();
		};

		/**
		 * Initialize the SVG needed for the legend.
		 */
		interactiveLegend._initSVG = function(scales) {
			legend = d3.select(parent).selectAll('.cv-legend').data([0]);
			legend.enter().append('div').classed('cv-legend', true); // create legend/bg if first time

			legendEntries = this._createLegendEntries(legend, scales);

			// Determine legend entry size
			legendEntryWidth = Math.floor(this._getLegendContainingWidth() / legendEntries.size());

			if (validOrientations.indexOf(orientation) > -1) {
				this._calculatedLegendOrientation = orientation;
			} else {
				this._calculatedLegendOrientation = 'top';
			}

			var isSmall = global.cloudViz.core._isSmallChart(chartWidth);
			if (legendEntryWidth < minLegendEntryWidth && !isSmall &&
					(this._calculatedLegendOrientation == 'top' || this._calculatedLegendOrientation == 'bottom')) {
				this._calculatedLegendOrientation = 'left';
			}

			switch (this._calculatedLegendOrientation) {
				case 'top':
				case 'bottom':
					legendEntryWidth = Math.max(legendEntryWidth, minLegendEntryWidth);
					legend.style('height', null);
					isVertical = false;
					break;
				case 'left':
				case 'right':
					legendEntryWidth = legendVerticalWidth;
					isVertical = true;
					break;
			}

			validOrientations.forEach(dv.util.bind(function(orientation) {
				legend.classed(orientation, this._calculatedLegendOrientation === orientation);
			}, this));
		};

		/**
		 * Called by DV to change the dimensions of the plot area.
		 *
		 * @param dim {{top:number, right:number, bottom:number, left:number}}
		 * @return {{top:number, right:number, bottom:number, left:number}}
		 */
		interactiveLegend._getAdjustedDimensions = function(dim) {
			var legendNode = legend.node();

			switch (this._calculatedLegendOrientation) {
				case 'top':
					dim.top += this._getUsedHeight();
					break;
				case 'right':
					dim.width -= this._getUsedWidth();
					break;
				case 'left':
					dim.left += this._getUsedWidth();
					break;
				case 'bottom':
					dim.height -= this._getUsedHeight();
					break;
			}
			return dim;
		};

		/**
		 * Create both the standard legend entries populated by DV and the manual legend entries that can be added by using
		 * the addManualEntry method.
		 */
		interactiveLegend._createLegendEntries = function(legend, scales) {
			// Create entries for each item in the series/grouping
			var self = this,
				states = seriesState.getStateObjects(), // The raw state objects
				entries,
				newEntries,
				k,
				scale;

			for (k in scales) {
				scale = scales[k][0]; // do we need to handle all or just grab first (or last)
				mapping = scale._mapping;
			}

			entries = legend.selectAll('.cv-legend-entry').data(states);
			newEntries = entries.enter().append('div').attr('class', function(d) { return 'cv-legend-entry cv-legend-' + d.type + '-entry'; });
			newEntries.append('div').classed('cv-legend-title', true);
			var secondLine = newEntries.append('div').classed('cv-legend-details', true);
			secondLine.append('div').classed('cv-legend-marker', true);
			secondLine.append('div').classed('cv-legend-num', true);
			entries.exit().on('click', null).remove();

			entries.each(function(d, i) {
				var entry = d3.select(this);
				entry.select('.cv-legend-title').text(d.name);
				// clear previous numbers, like on hover
				entry.select('.cv-legend-num').text((values && values.length > i) ? values[i] : '');

				entry.select('.cv-legend-marker')
					.attr('class', 'cv-legend-marker ' + type)
					.style('background-color', function(d) {
						var color = scale.mapValue(d.id);
						return color ? color : null;
					});
			});

			// Handle active/inactive
			entries.classed('inactive', function(d, i) { return interactive && !d.enabled; });

			entries.on('click', function(d, i) {
				if (interactive) {
					// The seriesState will notify the legend and all other interested components that this series is enabled/disabled
					seriesState.enableStateByIndex(i, !d.enabled);
				}
			});

			return entries;
		};

		/**
		 * Called when a particular series in enabled/disabled by user interaction or an outside API call
		 * @param  {string} eventType The type of event that was dispatched ('enableChanged' in this case)
		 * @param  {SeriesState} obj The state object representing the series.
		 */
		interactiveLegend._onSeriesEnableChange = function(eventType, obj) {
			if (interactive) {
				legendEntries.filter(function(d) {
					return d.id === obj.id && d.type === obj.type;
				}).classed('inactive', !obj.enabled);
			}
		};

		/**
		 * Position the legend off of the chart.
		 */
		interactiveLegend._positionLegend = function() {
			var legendPosition = {
				top: 0,
				left: 0
			};

			switch (this._calculatedLegendOrientation) {
				case 'bottom':
					legendPosition.top = chartHeight - legend.node().offsetHeight;
					break;
				case 'right':
					legendPosition.left = chartWidth - legendVerticalWidth;
					break;
			}

			legend.style('top', legendPosition.top + 'px').style('left', legendPosition.left + 'px');
		};

		/**
		 * Layout the legend entries based on the orientation.
		 */
		interactiveLegend._sizeAndPositionLegendEntries = function() {
			// Update legends
			if (isVertical) {
				legendEntries.each(function(d, i, s) {
					d3.select(this)
						.style('width', legendEntryWidth + 'px')
						// If the legend wasn't vertical on the prior render, it's possible a title height was set, clear that
						// out. Vertical legend entries can have varying heights unlike horizontal.
						.select('.cv-legend-title')
							.style('height', null);
				});
			} else {
				var entry, height, largestEntryTitleHeight = 0, entryTitleHeightsDifferent = false;
				var numLegendEntries = legendEntries[0].length;
				var legendWidth = numLegendEntries * legendEntryWidth;
				var containingWidth = this._getLegendContainingWidth();
				var legendWidthAdjustment = 0;

				// make an adjustment if the space between the last entry and the edge of the graph is less than
				// the number on the row aka we weren't able to divide them evenly across the space to line up on the right
				if (legendWidth < containingWidth && legendWidth + numLegendEntries > containingWidth) {
					legendWidthAdjustment = containingWidth - legendWidth;
				}

				// assign width if needed
				legend.style('width', (legendWidth > containingWidth && !isVertical) ? containingWidth + 'px' : '');

				legendEntries.each(function(d, i, s) {
					entry = d3.select(this);


					// Spread the legendWidthAdjustment across as many legendEntries as possible.
					var entryWidth = legendEntryWidth;
					if (legendWidthAdjustment > 0) {
						entryWidth += 1;
						legendWidthAdjustment -= 1;
					}

					entry.style('width', entryWidth + 'px');

					// Handle different title heights
					height = entry.select('.cv-legend-title').style('height', null).node().offsetHeight;

					if (height !== largestEntryTitleHeight) {
						entryTitleHeightsDifferent = true;
						largestEntryTitleHeight = Math.max(height, largestEntryTitleHeight);
					}
				});

				// Set entry height for horizontal legend
				if (entryTitleHeightsDifferent) {
					legendEntries.selectAll('.cv-legend-title').style('height', largestEntryTitleHeight + 'px');
				}
			}
		};

		/**
		 * Returns how much width the legend has for layout assuming the legend is oriented top. This function is used
		 * to determine if the legend should adjust from top horizontal to left vertical layout if there are too many
		 * legend entries for the available width.
		 */
		interactiveLegend._getLegendContainingWidth = function() {
			return chartWidth;
		};

		/**
		 * This function is called by DV to determine how much width the legend took up if it has a left or right
		 * orientation. This information is used by DV to adjust the left or right margin of the plot so it
		 * doesn't overlap the legend.
		 */
		interactiveLegend._getUsedWidth = function() {
			return isVertical ? legendVerticalWidth + VERT_LEGEND_MARGIN : 0;
		};

		/**
		 * This function is called by DV to determine how much height the legend took up if it has a top or bottom
		 * orientation.  This information is used by DV to adjust the top or bottom margin of the plot so it
		 * doesn't overlap the legend.
		 */
		interactiveLegend._getUsedHeight = function() {
			if (isVertical) {
				return 0;
			} else {
				return legend.node().offsetHeight || 0;
			}
		};

		/**
		 * Clears out data and removes the DOM elements for the legend.
		 */
		interactiveLegend.destroy = function() {
			// Remove old legend if one exists
			legend.remove();
		};

		/**
		 * The parent DOM element which will contain the HTML legend.  This is required even though
		 * DV attempts to supply the legend with a parent we disregard it because DV's legend parent
		 * is SVG where the interactive legend is meant to be HTML.
		 */
		interactiveLegend.parent = function(_) {
			if (!arguments.length) { return parent; }
			parent = _;
			return interactiveLegend;
		};

		/**
		 * The minimum width a legend entry can have.
		 */
		interactiveLegend.minLegendEntryWidth = function(_) {
			if (!arguments.length) { return minLegendEntryWidth; }
			minLegendEntryWidth = _;
			return interactiveLegend;
		};

		/**
		 * Sets the width of all legend entries when the legend is layed out vertically.
		 */
		interactiveLegend.legendVerticalWidth = function(_) {
			if (!arguments.length) { return legendVerticalWidth; }
			legendVerticalWidth = +_;
			return interactiveLegend;
		};

		/**
		 * An array of values which can be displayed in the legend entry which could represent a total or average
		 * of values.
		 */
		interactiveLegend.values = function(_) {
			if (!arguments.length) { return values; }
			values = _;
			return interactiveLegend;
		};

		/**
		 * Represents the type of legend that will be drawn.  This determines what marker will be drawn in the legend
		 * entries. This will be exposed via a CSS class which can be targeted to change the marker to look like a
		 * circle for a scatterplot or a square for a bar chart.
		 */
		interactiveLegend.type = function(_) {
			if (!arguments.length) { return type; }
			type = _;
			return interactiveLegend;
		};

		/**
		 * The allocated width for the entire chart.
		 */
		interactiveLegend.chartWidth = function(_) {
			if (!arguments.length) { return chartWidth; }
			chartWidth = _;
			return interactiveLegend;
		};

		/**
		 * The allocated height for the entire chart.
		 */
		interactiveLegend.chartHeight = function(_) {
			if (!arguments.length) { return chartHeight; }
			chartHeight = _;
			return interactiveLegend;
		};

		/**
		 * The amount of padding that the DV chart has been given.
		 *
		 * @param _ {{top: number, right: number, bottom: number, left: number}} A DV chart padding object.
		 */
		interactiveLegend.chartPadding = function(_) {
			if (!arguments.length) { return chartPadding; }
			chartPadding = _;
			return interactiveLegend;
		};

		interactiveLegend.seriesState = function(_) {
			if (!arguments.length) { return seriesState; }
			seriesState = _;
			seriesState.on('enableChange.legend', this._onSeriesEnableChange);
			return interactiveLegend;
		};

		/**
		 * An array of valid orientations the legend could have.
		 *
		 * @param _ {String[]} Valid options include: 'top', 'right', 'bottom', 'left'
		 */
		interactiveLegend.validOrientations = function(_) {
			if (!arguments.length) { return validOrientations; }
			validOrientations = _;
			return interactiveLegend;
		};

		/**
		 * The requested orientation for the legend.
		 *
		 * @param _ {String} Valid options include: 'top', 'right', 'bottom', 'left'
		 */
		interactiveLegend.orientation = function(_) {
			if (!arguments.length) { return orientation; }
			orientation = _;
			return interactiveLegend;
		};

		/**
		 * If true, the legend can be clicked and toggled on/off.  If false, it isn't clickable.
		 * @param _ {Boolean} [description]
		 */
		interactiveLegend.interactive = function(_) {
			if (!arguments.length) { return interactive; }
			interactive = _;
			return interactiveLegend;
		};

		/**
		 * A getter which returns the mapping of the scale associated with this legend.
		 */
		interactiveLegend.mapping = function() {
			return mapping;
		};

		/**
		 * A getter which returns whether the legend is vertical (true) or horizontal (false).  Vertical
		 * orientations include 'left' and 'right' legend orientations. Non-vertical orientations include
		 * 'top' and 'bottom' legend orientations.
		 */
		interactiveLegend.isVertical = function() {
			return isVertical;
		};

		return interactiveLegend;
	};

}(this));
/*global d3*/
(function(global) {
	"use strict";

	d3.anomaly = function() {
		var anomaly = {},
			data,
			mappings = { "x": "date", "y": "deviation" },
			padding,
			size = [50, 25],
			interactive = true,
			bins = 6,
			normalizePositive = false,
			p = null,
			anomalyWidth,
			anomalyHeight,
			xTicks = 7,
			xTickInterval,

			xUpperLimit,
			xLowerLimit,

			dispatch = d3.dispatch("select", "mouseover", "mouseout"),
			lastMouseOverNode,

			x = d3.time.scale(),
			y = d3.scale.linear(),
			gradient,
			height,
			width,
			binData,
			binSize,
			buckets,
			brush,
			xTickValues,

			// mapping shortcuts
			xMapping,
			yMapping,

			$p,
			$container,
			selectionCache;

		// constants
		var BAND_PADDING = 8,
			ANOMALY_PADDING = 1,
			DAY_IN_MILLIS = 86400000;

		d3.rebind(anomaly, dispatch, "on");

		/**
		 * An array of objects each representing data regarding an anomaly.  Use the mappings object to specify which
		 * property in each object represents x (the date) and which property represents y (deviation from the mean).
		 */
		anomaly.data = function(_) {
			if (!arguments.length) { return data; }
			data = _;
			selectionCache = null;
			return anomaly;
		};

		/**
		 * An object which specifies which properties in each object of the data array refers to x and y.
		 */
		anomaly.mappings = function(_) {
			if (!arguments.length) { return mappings; }
			mappings = extend(mappings, _);
			return anomaly;
		};

		anomaly.xUpperLimit = function(_) {
			if (!arguments.length) { return xUpperLimit; }
			xUpperLimit = _;
			return anomaly;
		};

		anomaly.xLowerLimit = function(_) {
			if (!arguments.length) { return xLowerLimit; }
			xLowerLimit = _;
			return anomaly;
		};

		/**
		 * Show all anomalies as positive even if they are negative.
		 */
		anomaly.normalizePositive = function(_) {
			if (!arguments.length) { return normalizePositive; }
			normalizePositive = _;
			return anomaly;
		};

		/**
		 * Determines how many x ticks should be drawn.  This ultimately determines how things are grouped.  There are two
		 * options that can be used here.
		 *
		 * Option 1: Supply a single integer argument to this function.  A single argument will render a preferred number of
		 * x ticks and the anomaly chart will determine the closest most optimal number of ticks to that preferred number.
		 * There may be times where 4 may be supplied and the anomaly chart is rendered with 3 or 5 ticks.  This is because
		 * ticks is simply a hint and in that particular case 4 ticks may have produced fractions or values which are not
		 * easily understood.
		 *
		 *     Usage:  .xTicks(5)
		 *
		 * Option 2: Supply two arguments. If the first argument is a function, this function will be invoked, being passed
		 * the start and end date of the scale's domain, in addition to the step argument. There are a few functions defined
		 * by D3 which can be used here to specify time interval (https://github.com/mbostock/d3/wiki/Time-Intervals#aliases)
		 *
		 *     Usage:  .xTicks(d3.time.weeks, 2)  // This will add a tick every 2 weeks.
		 *             .xTicks(d3.time.days, 1)  // This will add a tick for every day.
		 */
		anomaly.xTicks = function(arg1, arg2) {
			if (!arguments.length) {
				return arg2 !== undefined ? [xTicks, xTickInterval] : this.xTicks;
			}
			var isArg1Func = !!(arg1 && arg1.constructor && arg1.call && arg1.apply);
			xTicks = (isArg1Func) ? d3.functor(arg1) : arg1;
			xTickInterval = isArg1Func ? arg2 : undefined;
			return this;
		};

		/**
		 * The preferred number of bins that should be used.  This is only a suggestion that the anomaly chart can override.
		 *
		 * The anomaly chart will use a number of bins that lead to pretty intervals that are easier to process.  For
		 * example, if I ask for 3 bins for an interval of [0, 100], we would be showing bins of
		 * [0-33.3333, 33.3333-66.6667, 66.6667-100]. Users would rather have 4 bins of [0-25, 25-50, 50-75, 75-100]
		 * for reduced cognitive load, so this visualization will opt for 4 bins instead of 3.
		 */
		anomaly.bins = function(_) {
			if (!arguments.length) { return bins; }
			bins = _;
			return anomaly;
		};

		/**
		 * An array consisting of preferred width and height for the visualization, in the format [width, height].
		 */
		anomaly.size = function(_) {
			if (!arguments.length) { return size; }
			size = _;
			return anomaly;
		};

		/**
		 * True if the chart should be interactive and false otherwise.
		 */
		anomaly.interactive = function(_) {
			if (!arguments.length) { return interactive; }
			interactive = _;
			return anomaly;
		};

		/**
		 * The p node that the chart will be constructed in.
		 */
		anomaly.parent = function(_) {
			if (!arguments.length) { return p; }
			p = _;
			return anomaly;
		};

		/**
		 * READ-ONLY. The width of each anomaly box. Only available after layout.
		 */
		anomaly.anomalyWidth = function() {
			return anomalyWidth;
		};

		/**
		 * READ-ONLY. The height of each anomaly box.  Only available after layout.
		 */
		anomaly.anomalyHeight = function() {
			return anomalyHeight;
		};

		/**
		 * Draws the anomaly visualization.
		 */
		anomaly.layout = function() {
			if (!anomaly.data() || !anomaly.data().length) { throw new EmptyDataException(); }
			if (!anomaly.parent()) { throw new ParentNotSpecifiedException(); }

			xMapping = getMapping('x');
			yMapping = getMapping('y');

			createScales();
			createBrush();
			$container = createSVGContainer();
			binData = generateBinData();
			y.domain([buckets[0], buckets[buckets.length - 1]]);
			determineSize();
			$container.attr("transform", "translate(" + padding.left + "," + padding.top + ")");
			drawAxes($container, width, height);
			drawInteractionLayer();
			drawAnomalies();

			return anomaly;
		};

		/**
		 * Accepts a function which will be called for each anomaly node in the visualization.  The function will
		 * be passed two parameters.  The first is the data object bound to the anomaly.  The second is the index
		 * of the anomaly within the group of anomalies.  The `this` scope context of the function refers to the
		 * anomaly SVG node.
		 */
		anomaly.nodes = function(f) {
			if (!$p) { throw new Error("layout must be called before nodes may be requested."); }
			$p.selectAll(".anom-anomaly").each(f);
		};

		function extend(dest, source) {
			for (var prop in source) { dest[prop] = source[prop]; }
			return dest;
		}

		/**
		 * Determine the size of the chart and the adequate padding to prevent axis clipping.
		 */
		function determineSize() {
			var tempAxisContainer = $container.append("g").classed("temp-axis", true);
			drawAxes(tempAxisContainer, size[0], size[1]);

			padding = measureAxis(tempAxisContainer);
			width = size[0] - padding.left - padding.right;
			height = size[1] - padding.top - padding.bottom;

			tempAxisContainer.remove();
		}

		/**
		 * Measures the size of the axis and determines where it would be clipped. The areas that would be clipped
		 * are returned as an object with left, top, right, and bottom Numbers.  These numbers represent the padding
		 * in pixels that would need to be added to the chart in order to prevent clipping.
		 */
		function measureAxis(axisContainer) {
			var bbox = axisContainer.node().getBBox(),
				left = Math.abs(bbox.x),
				top = Math.abs(bbox.y);

			return {
				left: left,
				top: top,
				right: bbox.width - size[0] - left,
				bottom: bbox.height - size[1] - top
			};
		}

		/**
		 * Creates the scales and sets the appropriate domain. Range values are not set quite yet.
		 */
		function createScales() {
			var xExtent = calculateExtent(data, function(d) { return Date.parse(d[xMapping]); }, [xLowerLimit, xUpperLimit]);
			var yExtent = calculateExtent(data, function(d) { return d[yMapping]; });

			// Set the domain as it stands and then alter it to get identical column widths.
			x.domain(xExtent);

			// Get a full band for the last x interval (right now it could only be partial).  Each column MUST be the same width.
			var tickVals = x.ticks(xTicks, xTickInterval);

			var tickIntMillis = (+tickVals[1]) - (+tickVals[0]);
			xExtent[1] = tickIntMillis + (+tickVals[tickVals.length - 1]);
			xExtent[0] = (+tickVals[0] > xExtent[0]) ? (+tickVals[0] - tickIntMillis) : xExtent[0];
			x.domain(xExtent);
			xTickValues = x.ticks(xTicks, xTickInterval);

			// Which extent is greater?
			var extentMax = Math.max(Math.abs(yExtent[0]), Math.abs(yExtent[1]));

			if (normalizePositive) {
				y.domain([0, extentMax]);

				gradient = d3.scale.linear().domain([-extentMax, extentMax]);
			}
			else {
				y.domain([-extentMax, extentMax]);

				gradient = d3.scale.linear().domain(y.domain());
			}

			gradient.domain([0, 1/10, 1/5, 3/10, 2/5, 0.5, 3/5, 7/10, 4/5, 9/10, 1].map(gradient.invert));
			gradient.range(["#3C476F", "#485485", "#53659C", "#6C7CAF", "#99A2BC", "#C5C5C5", "#ACC997", "#90C867", "#7CBC4B", "#6FA744", "#64913E"]);
		}

		function calculateExtent(data, limitAccessor, manualLimits) {
			var limits = [];
			if (arguments.length < 3 || (manualLimits[0] === undefined && manualLimits[1] === undefined)) {
				limits = d3.extent(data, limitAccessor);
			}
			else {
				limits[0] = (manualLimits[0] === undefined) ? d3.min(data, limitAccessor) : manualLimits[0];
				limits[1] = (manualLimits[1] === undefined) ? d3.max(data, limitAccessor) : manualLimits[1];
			}
			return limits;
		}

		function createBrush() {
			brush = d3.svg.brush()
				.x(x)
				.y(y)
				.on("brushstart", brushstart)
				.on("brush", brushmove)
				.on("brushend", brushend);
		}

		function brushstart(p) {
			dispatchSelectedAnomalies();
		}

		function brushmove(p) {
			$container.selectAll(".extent").style("opacity", 1);
			dispatchSelectedAnomalies();
		}

		function brushend(p) {
			$container.selectAll(".extent").style("opacity", 0);
			dispatchSelectedAnomalies();
		}

		function dispatchSelectedAnomalies() {
			var extent = brush.extent(),
				extentRange = {
					left: Math.min(x(extent[0][0]), x(extent[1][0])),
					right: Math.max(x(extent[0][0]), x(extent[1][0])),
					top: Math.min(y(extent[0][1]), y(extent[1][1])),
					bottom: Math.max(y(extent[0][1]), y(extent[1][1]))
				};

			var selectedAnomalies = $container.selectAll(".anom-anomaly").filter(function(d, i) {
				return intersect({
					left: d.bounds.x,
					right: d.bounds.x + d.bounds.width,
					top: d.bounds.y,
					bottom: d.bounds.y + d.bounds.height
				}, extentRange);
			});

			if (selectionCache && arraysEqual(selectedAnomalies[0], selectionCache[0])) {
				return;
			}

			selectionCache = selectedAnomalies;
			dispatch.select(selectedAnomalies);
		}

		function arraysEqual(array1, array2) {
			if (array1.length != array2.length) {
				return false;
			}
			for (var i = 0, ii = array1.length; i < ii; i++) {
				if (array2.indexOf(array1[i]) === -1) {
					return false;
				}
			}
			return true;
		}

		function intersect(bounds1, bounds2) {
			return !(bounds2.left > bounds1.right ||
					bounds2.right < bounds1.left ||
					bounds2.top > bounds1.bottom ||
					bounds2.bottom < bounds1.top);
		}

		function createSVGContainer() {
			$p = d3.select(p);

			var svg = $p.selectAll("svg").data([data]);
			svg.enter().append("svg");
			svg.exit().remove();
			svg.attr("width", size[0]).attr("height", size[1]);

			var container = svg.selectAll(".anom-container").data([0]);
			container.enter().append("g").classed("anom-container", true);
			return container;
		}

		function generateBinData() {
			buckets = y.ticks(bins);
			var bucketSize = buckets[1] - buckets[0];
			buckets.push(bucketSize + buckets[buckets.length - 1]);

			if (!normalizePositive) {
				buckets.unshift(buckets[0] - bucketSize);
			}

			data = filterData(data);
			sortData(data);
			var nestData = nestDataByX(data);
			binNestedData(buckets, nestData);

			return nestData;
		}

		/**
		 * Ignore data outside the x upper and lower limits.
		 */
		function filterData(data, xExtent) {
			var xDomain = x.domain();
			return data.filter(function(d) {
				var date = new Date(d[xMapping]);
				return date >= xDomain[0] && date < xDomain[1];
			});
		}

		function sortData(data) {
			data.sort(function(a, b) {
				a = new Date(a[xMapping]);
				b = new Date(b[xMapping]);
				return a < b ? -1 : a > b ? 1 : 0;
			});
		}

		function nestDataByX(data) {
			return d3.nest()
				.key(function(d) {
					var date = Date.parse(d[xMapping]),
						tickIndex = 0;
					// Get the previous xTick
					var i = -1,
						n = xTickValues.length;
					while (++i < n) {
						if (+xTickValues[i] > +date) {
							break;
						}
						tickIndex = i;
					}
					return +xTickValues[tickIndex];
				})
				.entries(data);
		}

		function binNestedData(buckets, nestData) {
			nestData.forEach(function(d) {
				d.values = d3.layout.histogram()
					.bins(buckets)
					.value(function(d) { return normalizePositive ? Math.abs(d[yMapping]) : d[yMapping]; })
					(d.values);
				binSize = d.values[0].dx;
			});
		}

		function xTickLabelFormat(w) {
			var prevTick = new Date(0),
				numTicks = xTickValues.length,
				maxTickDensity = Math.max(Math.ceil((xTickValues.length - 1) / (w / 70)), 1),
				fullFormat = d3.time.format("%b %e, %Y"),
				monthFormat = d3.time.format("%b %e"),
				dayFormat = d3.time.format("%a %e"),
				hourFormat = d3.time.format("%I:%M %p");

			return function(d, i) {
				var value = "";

				if (i === numTicks - 1 || (i % maxTickDensity !== 0)) {
					return ""; // Don't set previous tick here
				} else if (i === 0 || prevTick.getYear() !== d.getYear()) {
					value = fullFormat(d);
				} else if (prevTick.getMonth() !== d.getMonth()) {
					value = monthFormat(d);
				} else if (prevTick.getDate() !== d.getDate()) {
					value = dayFormat(d);
				} else if (prevTick.getHours() !== d.getHours()) {
					value = hourFormat(d);
				}

				prevTick = d;
				return value;
			};
		}

		function drawAxes(container, w, h) {
			var numXTicks = xTickValues.length,
				showWeekendMarkers = (xTickValues.length > 1 && (+xTickValues[1] - +xTickValues[0] <= DAY_IN_MILLIS)),
				lastXLabelDate;

			// Set the ranges on the scale now that we have a width and height.
			x.rangeRound([0, w]);
			y.rangeRound([h, 0]);

			var axes = container.selectAll(".anom-axes").data([0]);
			axes.enter().append("g").classed("anom-axes", true);

			var axis = axes.selectAll(".anom-axis").data(['x', 'y']);
			axis.enter().append("g").attr("class", function(d) { return "anom-" + d + " anom-axis"; });

			// Draw x axis
			var xAxis = axes.selectAll(".anom-x")
				.attr("transform", "translate(0," + h + ")")
				.call(d3.svg.axis()
						.scale(x)
						.ticks(xTicks, xTickInterval)
						.orient("bottom")
						.tickSize(-h)
						.tickPadding(20)
						.tickFormat(xTickLabelFormat(w)));

			// Align x axis labels left
			xAxis.selectAll("text").style("text-anchor", "start");

			xAxis.selectAll("line")
				.style("opacity", function(d, i) {
					// Hide the last tick.
					if (i === numXTicks - 1) { return 0; }
					// Make the weekends stick out a little more
					if (showWeekendMarkers && (d.getDay() === 6 || d.getDay() === 1) && d.getHours() === 0 && i < numXTicks - 1) { return 0.3; }
					return null;
				});

			// Draw y axis
			var yAxis = axes.selectAll(".anom-y")
				.call(d3.svg.axis()
						.scale(y)
						.tickValues(buckets)
						.orient("left")
						.tickSize(-w)
						.tickPadding(10)
						// Draw every other label with %
						.tickFormat(function(d, i) {
							if (i === 0 || i === Math.floor(buckets.length / 2) || i === (buckets.length - 1)) {
								// Fix floating point math errors that would result in labels like 1.39999999999999%
								return (Math.round(d * 100000) / 100000) + "%";
							}
							return "";
						}));

			if (!normalizePositive) {
				yAxis.selectAll("line").filter(function(d, i) { return d === 0; })
					.style("stroke-dasharray", "4 4")
					.style("opacity", 0.7);
			}
		}

		function drawAnomalies() {
			var anomalyHeight = Math.round((buckets.length > 1) ? y(buckets[0]) - y(buckets[1]) : height) - 1,
				anomalyWidth = Math.round(computeAnomalyWidth(anomalyHeight)) - 1;

			var plot = $container.selectAll(".anom-plot").data([binData]);
			plot.enter().append("g").classed("anom-plot", true);
			plot.exit().remove();

			var columns = plot.selectAll(".anom-column").data(function(d) { return d; });
			columns.enter().append("g").classed("anom-column", true);
			columns.exit().remove();
			columns.attr("transform", function(d) { return "translate(" + x(+d.key) + ",0)"; });

			var rows = columns.selectAll(".anom-row").data(function(d) { return d.values; });
			rows.enter().append("g").classed("anom-row", true);
			rows.exit().remove();
			rows.attr("transform", function(d, i) {
				return "translate(0," + (y(buckets[i]) - anomalyHeight) + ")";
			});

			// Draw anomaly container
			var anomalies = rows.selectAll(".anom-anomaly").data(function(d) { return d; });
			var anomaliesEnter = anomalies.enter().append("g").classed("anom-anomaly", true);
			anomalies.attr("transform", function(d, i) {
					var bucket = getBucket(normalizePositive ? Math.abs(d[yMapping]) : d[yMapping]);
					if (d[yMapping] >= 0) {
						bucket += binSize;
					}
					d.bounds = {
						'x': x(Date.parse(d[xMapping])) + (i * (anomalyWidth + ANOMALY_PADDING) + ANOMALY_PADDING),
						'y': y(bucket),
						'width': anomalyWidth,
						'height': anomalyHeight
					};
					return "translate(" + (i * (anomalyWidth + ANOMALY_PADDING) + ANOMALY_PADDING) + ",0)";
				});
			anomalies.exit().remove();

			// Draw anomaly cell
			anomaliesEnter.append("rect")
				.classed("anom-cell", true)
				.attr("x", anomalyWidth / 2)
				.attr("y", anomalyHeight / 2)
				.attr("width", 0)
				.attr("height", 0);

			anomalies.selectAll(".anom-cell")
				.attr("fill", function(d) {
					// If normalizePositive, we'll pretend the y value is positive, request it's bucket, and then make the bucket
					// negative before asking the gradient scale for color.
					var bucket = getBucket(normalizePositive ? Math.abs(d[yMapping]) : d[yMapping]);
					if (normalizePositive && d[yMapping] < 0) {
						bucket *= -1;
					}
					return gradient(bucket);
				})
				.transition()
				.duration(500)
					.attr("x", 0)
					.attr("y", 0)
					.attr("width", anomalyWidth)
					.attr("height", anomalyHeight);

			//Draw anomaly selection
			var anomalySelectEnter = anomaliesEnter.append("g")
				.classed("anom-select", true);

			anomalySelectEnter.append("path").classed("outer-border", true);
			anomalySelectEnter.append("path").classed("inner-border", true);

			var anomalySelect = anomalies.selectAll(".anom-select");

			anomalySelect.select(".outer-border")
				.attr("d", rectPath(0, 0, anomalyWidth + 0.5, anomalyHeight + 0.5, 1));

			// Special case the selection border so it doesn't draw the inner border if it's too thin to do it appropriately.
			if (anomalyWidth > 3) {
				anomalySelect.select(".inner-border")
					.attr("d", rectPath(0, 0, anomalyWidth + 1, anomalyHeight + 1, 2));
			}

			var hitArea = anomaliesEnter.append("rect")
				.classed("anom-hit-area", true);
			hitArea
				.on("mouseover", function(d, i) { dispatch.mouseover(this, d, i); })
				.on("mouseout", function(d, i) { dispatch.mouseout(this, d, i); })
				.on("mousedown", function(d, i) {
					brush.clear();
					var xy = d3.mouse($container.node()),
						xInv = x.invert(xy[0]),
						yInv = y.invert(xy[1]);
					brush.extent([[xInv, yInv], [xInv, yInv]]);
				})
				.on("click", function(d, i) { dispatch.select(d3.select(this)); })
				.style("cursor", "crosshair")
				.style("opacity", 0)
				.attr("x", 0)
				.attr("y", 0)
				.attr("width", anomalyWidth)
				.attr("height", anomalyHeight);
		}

		function drawInteractionLayer() {
			var interactionCanvas = $container.selectAll(".anom-plot").data([0]);
			interactionCanvas.enter().append("g").classed("anom-plot", true);
			interactionCanvas.exit().remove();
			interactionCanvas.call(brush);
		}

		function rectPath(x, y, width, height, inset) {
			return "M" + inset + "," + inset +
				"L" + (width - inset * 2) + "," + inset +
				"L" + (width - inset * 2) + "," + (height - inset * 2) +
				"L" + inset + "," + (height - inset * 2) +
				"z";
		}

		function getBucket(y) {
			var i = -1,
				n = buckets.length;
			while (++i < n) {
				if (y >= 0 && buckets[i] + binSize > y) { return buckets[i]; }
				if (y < 0 && buckets[i] + binSize > y) { return buckets[i] + binSize; }
			}
			return buckets[0];
		}

		function computeAnomalyWidth(anomalyHeight) {
			var bandWidth = ((xTickValues.length > 1) ? x(xTickValues[1]) - x(xTickValues[0]) : width) - BAND_PADDING,
				maxAnomaliesPerBand = getMaxAnomaliesPerBand();
				anomalyWidth = bandWidth / maxAnomaliesPerBand;
			return (anomalyWidth > anomalyHeight) ? anomalyHeight : anomalyWidth;
		}

		function getMaxAnomaliesPerBand() {
			var maxAnomalies = 0;
			binData.forEach(function(band) {
				band.values.forEach(function(bandRow) {
					maxAnomalies = Math.max(bandRow.length, maxAnomalies);
				});
			});
			return maxAnomalies;
		}

		function getMapping(prop) {
			if (mappings[prop] === undefined) { throw new MappingNotDefinedException(prop); }
			return mappings[prop];
		}

		function MappingNotDefinedException(prop) {
			this.type = "MappingNotDefinedException";
			this.message = "The mapping for property " + prop + " was not defined.";
			this.toString = function() { return this.type + " - " + this.message; };
		}

		function EmptyDataException() {
			this.type = "EmptyDataException";
			this.message = "The data is empty or null";
			this.toString = function() { return this.type + " - " + this.message; };
		}

		function ParentNotSpecifiedException() {
			this.type = "ParentNotSpecifiedException";
			this.message = "A p was not specified for this visualization";
			this.toString = function() { return this.type + " - " + this.message; };
		}

		return anomaly;
	};
}(this));
/**
 * Pathing Diagram
 * Based on the Sankey Diagram, the Pathing Diagram allows for a user to see how traffic flows from one node to another
 * Parameters
 * options are defined in the code below.
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, core = cloudViz.core || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		pathing = Object.create(core),
		animationDuration = 400;

	pathing.init = function(options) {
		this._type = 'pathing';
		this._initDefaultOptions();
		this.setOptions(options);
		this._pathLocked = null;
		this._pathedObj = null;
		this._activePaths = [];
		this._lineLocked = null;
		this._lastSide = 0; // TEMP: Rework resize with pivot node
		return this;
	};

	pathing._initDefaultOptions = function() {
		var metricName = 'Visits',
			defaults = {
				// TODO: support custom mappings of data
				// right now we require specific keys
				mappings : {}, // required for validation in core but not used
				// color of the paths on interaction
				colors : [
					'#3287d2',
					'#9b8ce6',
					'#d755a5',
					'#fa5a50',
					'#f0a01e',
					'#c3d250',
					'#5faf69',
					'#1ebed7',
					'#5a6eaa',
					'#78b4f5',
					'#aa5fa5',
					'#f0557d',
					'#e8782d',
					'#f5c841',
					'#8cc350',
					'#3cb5a0', // 16
					'#286eaf',
					'#826ee1',
					'#b93282',
					'#f04641',
					'#e18c00',
					'#a0b400',
					'#50965a',
					'#00a0be',
					'#465a87',
					'#4196e6',
					'#964196',
					'#dc3c69',
					'#dc5f00',
					'#e6b43c',
					'#7daf4b',
					'#32a08c' // 32
				],
				// The width of a node in each column
				nodeWidth: 100,

				// The minimum height each node can be.
				// THIS PROPERTY IS DANGEROUS IF INCREASED TOO MUCH!
				// It distorts the data and makes smaller nodes appear larger than they actually are proportionally.
				// Also pushes the top node off the screen if larger
				minNodeHeight: 1,

				// Used in determining the minimum height of the chart to display every node in a column
				avgNodeHeight: 30,

				// The internal padding of the graph
				// This is the space between the border and where the edges of the nodes are drawn
				padding : {
					top : 80,
					left : 30,
					right : 30,
					bottom : 20
				},

				// Displayed in a tooltip when a link or node is hovered or tapped
				metricName : metricName,

				// The minimum horizontal padding between nodes
				minNodeHorzPadding : 80,

				// The vertical padding between nodes
				// This space includes the name of the node
				nodeVertPadding : 34,

				// The number of iterations the pathing library will run over the data to map it spacially
				iterations: 32,

				// Callback methods for allowing the integrator to know when a specific action was taken on the node
				pivotNode : null,
				collapseNode : null,
				expandNode : null,
				pathSelected : null
			};
		return Object.getPrototypeOf(pathing)._initDefaultOptions.call(this, defaults);
	};

	pathing._onAutoResize = function() {
		this.render();
	};

	/**
	 * Resets the chart instance.  Called on both render and destroy.
	 **/
	pathing.reset = function() {
		Object.getPrototypeOf(pathing).reset.apply(this, arguments);
		// Since we use render() on resize (which calls reset in core)
		// we cannot use reset to actually remove behaviors and other additional layers
		// Instead we detect it in preRender and reset there
	};

	pathing._preRender = function() {
		Object.getPrototypeOf(pathing)._preRender.apply(this);

		var options = this._options,
			parent = d3.select(options.parent),
			padding = options.padding;

		// Wrap the pathing chart in a new wrapper to allow for scrolling
		var infoWrapper = parent.selectAll('.pathing-cv-info-wrapper').data([0]);
		infoWrapper.enter().insert('div', ':first-child').classed('pathing-cv-info-wrapper', true);
		var wrapper = infoWrapper.selectAll('.pathing-cv-wrapper').data([0]);
		wrapper.enter().insert('div', ':first-child').classed('pathing-cv-wrapper', true);
		var container = wrapper.selectAll('.pathing-cv-container').data([0]);
		container.enter().insert('div', ':first-child').classed('pathing-cv-container', true);
		var svg = container.selectAll('.pathing-svg').data([0]);
		svg.enter().append('svg').classed('pathing-svg', true);
		var paths = svg.selectAll('.pathing-svg-container').data([0]);
		paths.enter().append('g').classed('pathing-svg-container', true);
		paths.attr('transform', 'translate(' + padding.left + ',' + padding.top + ')');

		// Side information pane
		var pane = infoWrapper.selectAll('.pathing-cv-info-pane').data([0]);
		pane.enter().append('div').classed('pathing-cv-info-pane', true);
		pane.exit().remove();
		var paneContent = pane.selectAll('.info-pane-content').data([0]);
		paneContent.enter().append('div').classed('info-pane-content', true);
		paneContent.exit().remove();
		var paneTitle = paneContent.selectAll('.pathing-cv-info-title').data([0]);
		paneTitle.enter().append('div').classed('pathing-cv-info-title', true);
		paneTitle.exit().remove();
		var paneValue = paneContent.selectAll('.pathing-cv-info-value').data([0]);
		paneValue.enter().append('div').classed('pathing-cv-info-value', true);
		paneValue.exit().remove();
		var panePaths = paneContent.selectAll('.pathing-cv-info-paths').data([0]);
		panePaths.enter().append('div').classed('pathing-cv-info-paths', true);
		panePaths.exit().remove();

		// Size wrapping divs
		this._sizeChart();

		// Create gradients
		this._createGradients(svg);

		// Unlock node/link if this is new data
		var pathed = this._pathedObj;
		if (this._changedOptions && this._changedOptions.data && pathed) {
			if (this._isDataObjNode(pathed.data)) {
				this._unlockNode(pathed.data, pathed.elem)();
			} else {
				this._unlockLink(pathed.data, pathed.elem)();
			}
		} else {
			// new chart, remove events and layers
			container
				.on('mousemove.node', null)
				.on('click.node', null)
				.on('click.link', null);
			this._removePathOverlays(container);
			this._removeNodeOptions(true);
			this._defaultInformation();
		}
	},

	pathing._render = function() {
		Object.getPrototypeOf(pathing)._render.apply(this);
		if (!this._dataAdapter.isValidPathingData()) { return; }

		this._createDiagram();

		// Handle resizing, check if we have activepaths
		var pathed = this._pathedObj;
		if (this._activePaths.length && pathed) {
			if (this._isDataObjNode(pathed.data)) {
				// Node paths
				this._renderNodePaths(pathed.data, pathed.elem, true);
				this._showNodeOptions(pathed.data, pathed.elem);
			} else {
				// Link paths
				this._renderLinkPaths(pathed.data, pathed.elem, true);
			}
		}
	};

	pathing._postRender = function() {
		Object.getPrototypeOf(pathing)._postRender.apply(this);
	};

	pathing._sizeChart = function(focusElem) {
		clearTimeout(this._wrapperAnimation);
		clearTimeout(this._scrollAnimation);
		var options = this._options, data = this._dataAdapter.data(),
			parent = d3.select(options.parent), self = this,
			infoWrapper = parent.selectAll('.pathing-cv-info-wrapper'),
			wrapper = infoWrapper.selectAll('.pathing-cv-wrapper'),
			container = wrapper.selectAll('.pathing-cv-container'),
			infoPane = infoWrapper.selectAll('.pathing-cv-info-pane'),
			parentWidth = options.parent.offsetWidth,
			parentHeight = options.parent.offsetHeight,
			visibleWidth = dv.util.getPercentValue(options.width, parentWidth),
			visibleHeight = dv.util.getPercentValue(options.height, parentHeight),
			adjustedWidth = visibleWidth - parseInt(infoPane.style('width'), 10), // TODO: make this dynamic, width of info pane
			padding = options.padding;

		// Number of columns that will be rendered
		var nodes = data && data.nodes || [],
			numCols = this._numColumns = nodes.length &&
				(Math.max.apply(null, nodes.map(function(n) { return n.column; } )) + 1) || 1,
			colNodeCount = [], maxNodes = 0;

		data.nodes.forEach(function(n, i) {
			if (colNodeCount[n.column]) { colNodeCount[n.column]++; }
			else { colNodeCount[n.column] = 1; }
		});
		maxNodes = colNodeCount.length && Math.max.apply(null, colNodeCount) || 0;

		// Determine the visible dimensions of the chart
		var containerWidth = adjustedWidth - 2, // adjust for borders
			containerHeight = visibleHeight - 2,
			neededWidth = (numCols * options.nodeWidth) + ((numCols - 1) * options.minNodeHorzPadding) + padding.left + padding.right,
			neededHeight = (maxNodes * options.avgNodeHeight) + (maxNodes * options.nodeVertPadding) + padding.top + padding.bottom,
			wider = neededWidth > adjustedWidth,
			taller = neededHeight > visibleHeight;

		// Check dimensions
		wrapper.classed('is-wider', wider);
		if ( wider ) { // will have horizontal scrolling
			containerWidth = neededWidth;
			containerHeight -= 20; // adjust for horizontal scrollbar
		}
		wrapper.classed('is-taller', taller);
		if ( taller ) { // will have vertical scrolling
			containerHeight = neededHeight;
			containerWidth -= 20; // adjust for vertical scrollbar
		}

		infoWrapper.style('width', visibleWidth + 'px').style('height', visibleHeight + 'px');
		wrapper.style('width', adjustedWidth + 'px').style('height', visibleHeight + 'px');
		container.style('width', containerWidth + 'px').style('height', containerHeight + 'px');
	};

	pathing._getInnerDimensions = function() {
		var options = this._options, padding = options.padding,
			container = d3.select(options.parent).select('.pathing-cv-container'),
			width = parseInt(container.style('width'), 10),
			height =  parseInt(container.style('height'), 10);
		return [width - padding.right - padding.left, height - padding.top - padding.bottom];
	};

	pathing._createDiagram = function() {
		var options = this._options, data = this._dataAdapter.data(),
			container = d3.select(options.parent).selectAll('.pathing-cv-container'),
			containerWidth = parseInt(container.style('width'), 10),
			containerHeight = parseInt(container.style('height'), 10),
			path = this._path = d3.pathing()
				.nodeWidth(options.nodeWidth)
				.nodePadding(options.nodeVertPadding)
				.size(this._getInnerDimensions())
				.nodes(data.nodes)
				.links(data.links)
				.minNodeHeight(options.minNodeHeight)
				.layout(options.interations);

		// Center if only 1 column
		// Must modify data now before links/nodes are processed
		if (!data.nodes.some(function(n) { return n.column !== 0; })) {
			var nodeWidth = path.nodeWidth(),
				padding = options.padding;
			data.nodes.forEach(function(d) {
				d.x += ((containerWidth - padding.left - padding.right) / 2) - (nodeWidth / 2);
			});
		}

		var link = this._updateLinks(path, data.links);
		this._updateNodes(path, data.nodes, link, containerHeight);

		// Force a redraw of the SVG because we sometimes get artifacts in Webkit
		var svg = d3.select(options.parent).select('.pathing-svg').node();
		svg.style.display = 'none';
		var h = svg.offsetHeight; // calling this will force the redraw, assigning because JSHINT doesn't like it by itself
		svg.style.display = '';
	};

	pathing._updateNodes = function(path, nodeData, link, height) {
		var self = this, options = this._options,
			svg = d3.select(options.parent).select('.pathing-svg-container'),
			nodeSelectHandler = this._options.onNodeSelect,
			padding = this._options.padding,
			isResize = (!this._changedOptions || !this._changedOptions.data),
			dur = (isResize) ? 0 : animationDuration;

		function dragmove(d) {
			var maxY = height - this.getBBox().height - padding.bottom;
			d3.select(this).attr('transform', 'translate(' + d.x + ',' + (d.y = Math.max(0, Math.min(maxY, d3.event.y))) + ')');
			path.relayout();
			link.attr('d', path.link());
		}

		var nodeGroup = svg.selectAll('.node-container').data([0]);
		nodeGroup.enter().append('g').classed('node-container', true);
		nodeGroup.exit().remove();

		var node = nodeGroup.selectAll('.node').data(nodeData, this._dataAdapter.nodeKey()),
			nodeWidth = path.nodeWidth();

		// position new nodes in the right column
		node.enter().append('g').classed('hide-node', true).attr('transform', function(d) { return 'translate(' + d.x + ',0)'; });
			/*.call(d3.behavior.drag()
				.origin(function(d) { return d; })
				.on('dragstart', function() { this.parentNode.appendChild(this); })
				.on('drag', dragmove));*/
		node.on('mouseover.node', function(d, i) {
				self._showNodePaths(d, this);
				self._showFullTitle(d, this);

				if (typeof self._eventMap['mouseover'] === 'function') {
					self._eventMap['mouseover'].call(this, d);
				}
			})
			.on('mouseout.node', function(d, i) {
				self._hideNodePaths();
				self._truncateFullTitle(d, this);

				if (typeof self._eventMap['mouseout'] === 'function') {
					self._eventMap['mouseout'].call(this, d);
				}
			})
			.on('click.node', function(d, i) {
				self._activateNode(d, this);

				if (typeof self._eventMap['click'] === 'function') {
					self._eventMap['click'].call(this, d);
				}
			});
		var exitNodes = node.exit();
		exitNodes
			.classed('hide-node', true)
			.on('mouseover.node', null).on('mouseout.node', null)
			.on('click.node', null)
			.transition().duration(dur).style('opacity', 0).attr('transform', function(d) { return 'translate(' + d.x + ',0)'; });

		setTimeout(function() {
			exitNodes.remove();
		}, dur);

		node.transition().duration(dur).attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });

		var numCols = this._numColumns;
		node.each(function(d, i) {
			var e = d3.select(this), isNew = e.classed('hide-node');
			e.attr('class', 'node'); // clear out other classes
			e.classed('hide-node', isNew);
			e.classed('filter', d.id === 'E_0');
			e.classed('exit-filter', d.id === 'X_0');
			if (d.classname) { e.classed(d.classname, true); }

			// Node background
			var rect = e.selectAll('.node-bg').data([d]);
			rect.enter().append('rect').classed('node-bg', true);
			rect.exit().remove();
			rect.attr('width', nodeWidth);
			rect.transition().duration(dur).attr('height', function(d) { return d.dy; });

			function setAlignment(d) {
				var midCol = true, firstCol = false, lastCol = false;
				if (numCols > 1) {
					firstCol = (0 === d.column);
					lastCol = (numCols - 1 === d.column);
					midCol = !(firstCol || lastCol);
				}
				d3.select(this)
					.attr('x', (midCol) ? nodeWidth/2 : (firstCol) ? 2 : nodeWidth - 4 )
					.attr('text-anchor', (midCol) ? 'middle' : (firstCol) ? 'start' : 'end');
			}

			function truncateTitle(title) {
				var maxChars = 20, endChars = 10, // middle truncation, leave 10 at the end
					delimiter = '\u2026'; // horizontal ellipsis
				if (title.length < maxChars) { return title; }
				return title.slice(0, maxChars - endChars) + delimiter + title.slice(title.length - endChars);
			}

			// Node title
			var text = e.selectAll('.node-title').data([d]);
			text.enter()
				.append('text')
				.classed('node-title', true)
				.attr('y', -5)
				.attr('transform', null);
			text.exit().remove();
			text.each(setAlignment);
			text.text(function(d) { return truncateTitle(d.label); });

			// Node total
			var num = e.selectAll('.node-total').data([d]);
			num.enter()
				.append('text')
				.classed('node-total', true)
				.attr('y', 15)
				.attr('transform', null);
			num.exit().remove();
			num.each(setAlignment);
			num.text(function(d) { return d3.format(',.0f')(d.value); });

			// Node hit area
			var hitArea = e.selectAll('.node-hit-area').data([d]);
			hitArea.enter().append('rect').classed('node-hit-area', true);
			hitArea.exit().remove();
			hitArea.attr('height', function(d) { return d.dy + 4; })
				.attr('y', -4)
				.attr('width', path.nodeWidth())
				.style('opacity', 0);

			setTimeout(function() {
				e.classed('hide-node', false);
			}, dur);

		});
	};

	pathing.gradientCounter = { // intentionally nested object so instances will share
		count : 0
	};
	pathing._updateLinks = function(path, linkData) {
		var options = this._options, self = this,
			svg = d3.select(options.parent).select('.pathing-svg-container'),
			container = d3.select(options.parent).selectAll('svg'),
			defs = container.selectAll('defs').data([0]),
			isResize = (!this._changedOptions || !this._changedOptions.data),
			dur = (isResize) ? 0 : animationDuration;

		defs.enter().append('defs');
		var group = defs.selectAll('.path-fills').data([0]),
			groupEnter = group.enter().append('g').classed('path-fills', true);

		// Create linear gradients
		// ID needs to be unique per graph so one graph doesn't use another
		// Browser was lowercasing 'linearGradient' so we had to add another attr (class) to key off of
		/*var gradId = 'cv-path-gradient' + (this.gradientCounter.count++),
			grads = group.selectAll('.cv-path-gradient').data(colors);

		grads.enter().append('linearGradient').classed('cv-path-gradient', true);
		grads.exit().remove();
		grads.each(function(d, i) {
			var grad = d3.select(this);
			grad.selectAll('stop').remove();
			if (i === colors.length - 1) { return; } // no gradient for last column
			grad.append('stop')
				.classed('stop1', true)
				.attr('offset', '0%')
				.attr('stop-color', d);
			grad.append('stop')
				.classed('stop2', true)
				.attr('offset', '100%')
				.attr('stop-color', colors[i+1]);
			grad.attr('id', gradId+i+'-'+(i+1));
		});*/

		var linkGroup = svg.selectAll('.link-container').data([0]);
		linkGroup.enter().append('g').classed('link-container', true);
		linkGroup.exit().remove();

		var linkOverlays = svg.selectAll('.path-overlay-container').data([0]);
		linkOverlays.enter().append('g').classed('path-overlay-container', true);
		linkOverlays.exit().remove();

		var link = linkGroup.selectAll('path').data(linkData, this._dataAdapter.linkKey());
		link.enter().append('path').classed('hide-link', true);
		link.on('mouseover.link', function(d, i) { self._showLinkPaths(d, this); })
			.on('mouseout.link', function(d, i) { self._hideLinkPaths(); })
			.on('click.link', function(d, i) { self._activateLink(d, this); });
		var exitLinks = link.exit();
			exitLinks
				.classed('hide-link', true)
				.on('click.link', null)
				.on('mouseover.link', null).on('mouseout.link', null);
			setTimeout(function() {
				exitLinks.remove();
			}, dur);
		link.each(function(d, i) {
			var e = d3.select(this), isNew = e.classed('hide-link');
			e.attr('class', function(d) { return !d.source ? 'entry' : !d.target ? 'exit' : 'link'; });
			e.classed('hide-link', isNew);
			if (e.classed('hide-link')) {
				e.attr('d', path.link()(d));
				setTimeout(function() {
					e.classed('hide-link', false);
				}, dur);
			} else {
				e.transition().duration(dur).attr('d', path.link()(d));
			}
			if (d.source && 'E_0' === d.source.id) {
				e.classed('entry-path', true);
			} else if (d.target && 'X_0' === d.target.id) {
				e.classed('exit-path', true);
			}
			var efilter = d.source && 'E_0' === d.source.id,
				xfilter = d.target && 'X_0' === d.target.id;
			e.classed('filter', efilter);
			e.classed('exit-filter', xfilter);
		});

		return link;
	};

	pathing._createGradients = function(svgContainer) {
		// Styles to apply gradients
		// We have to inline this as the url() is relative (FF enforces this)
		var styles = svgContainer.selectAll('style').data([0]);
		styles.enter().append('style');
		styles.text(function(d) {
			var style = '.pathing-svg .exit { fill: url(#exitFill); } \n';
			style += '.pathing-svg .entry { fill: url(#entryFill); } \n';
			style += '.pathing-svg .exit:hover { fill: url(#exitHighlightFill); } \n';
			style += '.pathing-svg .entry:hover { fill: url(#entryHighlightFill); } \n';
			style += '.pathing-svg .pivot-entry { mask: url(#pivotEnterMask); } \n';
			style += '.pathing-svg .pivot-exit { mask: url(#pivotExitMask); } \n';
			style += '.pathing-svg .link-container .entry-path { fill: url(#entryGradient); } \n';
			style += '.pathing-svg .link-container .exit-path { fill: url(#exitGradient); } \n';
			return style;
		});

		// Definitions for gradients/fills
		var defs = svgContainer.selectAll('defs').data([0]);
		defs.enter().append('defs');
		var group = defs.selectAll('.bounce-fills').data([0]),
			groupEnter = group.enter().append('g').classed('bounce-fills', true);

		var pivotEnterGrad = groupEnter.append('linearGradient').attr('id', 'pivotEnterGrad');
		pivotEnterGrad.append('stop').attr('offset', '0%').style('stop-color', '#fff').style('stop-opacity', 0);
		pivotEnterGrad.append('stop').attr('offset', '50%').style('stop-color', '#fff').style('stop-opacity', 0);
		pivotEnterGrad.append('stop').attr('offset', '70%').style('stop-color', '#fff').style('stop-opacity', 0.5);
		pivotEnterGrad.append('stop').attr('offset', '100%').style('stop-color', '#fff').style('stop-opacity', 1);
		var pivotEnterMask = groupEnter.append('mask').attr('id', 'pivotEnterMask')
			.attr('x', '0').attr('y', '0').attr('width', '1').attr('height', '1')
			.attr('maskUnits', 'objectBoundingBox').attr('maskContentUnits', 'objectBoundingBox');
		pivotEnterMask.append('rect')
			.attr('x', '0').attr('y', '0')
			.attr('width', '1').attr('height', '1')
			.attr('fill', 'url(#pivotEnterGrad)');

		var pivotExitGrad = groupEnter.append('linearGradient').attr('id', 'pivotExitGrad').attr('x1', '100%').attr('y1', '0%').attr('x2', '0%').attr('y2', '0%');
		pivotExitGrad.append('stop').attr('offset', '0%').style('stop-color', '#fff').style('stop-opacity', 0);
		pivotExitGrad.append('stop').attr('offset', '50%').style('stop-color', '#fff').style('stop-opacity', 0);
		pivotExitGrad.append('stop').attr('offset', '70%').style('stop-color', '#fff').style('stop-opacity', 0.5);
		pivotExitGrad.append('stop').attr('offset', '100%').style('stop-color', '#fff').style('stop-opacity', 1);
		var pivotExitMask = groupEnter.append('mask').attr('id', 'pivotExitMask')
			.attr('x', '0').attr('y', '0').attr('width', '1').attr('height', '1')
			.attr('maskUnits', 'objectBoundingBox').attr('maskContentUnits', 'objectBoundingBox');
		pivotExitMask.append('rect')
			.attr('x', '0').attr('y', '0')
			.attr('width', '1').attr('height', '1')
			.attr('fill', 'url(#pivotExitGrad)');

		var entryGradient = groupEnter.append('linearGradient').attr('id', 'entryGradient').attr('x1', '0%').attr('y1', '100%').attr('x2', '100%').attr('y2', '100%');
		entryGradient.append('stop').attr('offset', '0%').style('stop-color', '#8cc350');
		entryGradient.append('stop').attr('offset', '100%').style('stop-color', '#3287D2');

		var exitGradient = groupEnter.append('linearGradient').attr('id', 'exitGradient').attr('x1', '0%').attr('y1', '100%').attr('x2', '100%').attr('y2', '100%');
		exitGradient.append('stop').attr('offset', '0%').style('stop-color', '#3287D2');
		exitGradient.append('stop').attr('offset', '100%').style('stop-color', '#cc2539');

		var exitFill = groupEnter.append('linearGradient').attr('id', 'exitFill').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
		exitFill.append('stop').attr('offset', '0%').style('stop-color', '#FA5A50').style('stop-opacity', 0.5);
		exitFill.append('stop').attr('offset', '85%').style('stop-color', '#FA5A50').style('stop-opacity', 0.5);
		exitFill.append('stop').attr('offset', '100%').style('stop-color', '#FA5A50').style('stop-opacity', 0.1);

		var exitHighlightFill = groupEnter.append('linearGradient').attr('id', 'exitHighlightFill').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
		exitHighlightFill.append('stop').attr('offset', '0%').style('stop-color', '#FA5A50').style('stop-opacity', 1);
		exitHighlightFill.append('stop').attr('offset', '85%').style('stop-color', '#FA5A50').style('stop-opacity', 1);
		exitHighlightFill.append('stop').attr('offset', '100%').style('stop-color', '#FA5A50').style('stop-opacity', 0.1);

		var entriesFill = groupEnter.append('linearGradient').attr('id', 'entryFill').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
		entriesFill.append('stop').attr('offset', '0%').style('stop-color', '#58AF5E').style('stop-opacity', 0.1);
		entriesFill.append('stop').attr('offset', '15%').style('stop-color', '#58AF5E').style('stop-opacity', 0.5);
		entriesFill.append('stop').attr('offset', '100%').style('stop-color', '#58AF5E').style('stop-opacity', 0.5);

		var entriesHighlightFill = groupEnter.append('linearGradient').attr('id', 'entryHighlightFill').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
		entriesHighlightFill.append('stop').attr('offset', '0%').style('stop-color', '#58AF5E').style('stop-opacity', 0.1);
		entriesHighlightFill.append('stop').attr('offset', '15%').style('stop-color', '#58AF5E').style('stop-opacity', 1);
		entriesHighlightFill.append('stop').attr('offset', '100%').style('stop-color', '#58AF5E').style('stop-opacity', 1);
	};

	pathing._setOptionContainerContent = function(container, data) {
		var options = this._options, content = '', node, numOptions = 0,
			last = container.classed('is-last-column'), adapter = this._dataAdapter,
			l10n = adapter.l10n.labels.pathing,
			nodeOptions = [
				{ id : 'expand', label : l10n.expand, valid : (options.expandNode && adapter.canExpandNode(data)) },
				{ id : 'pivot', label : l10n.focus, valid : (options.pivotNode && adapter.canPivotNode(data)) },
				{ id : 'collapse', label : l10n.collapse, valid : (options.collapseNode && adapter.canCollapseNode(data)) }
			];
		if (last) { nodeOptions.reverse(); } // display in reverse order
		nodeOptions = nodeOptions.filter(function(n) { return n.valid; });

		if (options.expandNode || options.collapseNode || options.pivotNode) {
			for (var i=0, ii=nodeOptions.length; i<ii; ++i) {
				node = nodeOptions[i];
				content += '<a class="cv-node-option cv-node-option'+
					((last) ? (ii - numOptions - 1) : numOptions) +' cv-node-' + node.id +
					'"><i class="'+node.id+'"></i><span>' + node.label + '</span></a>';
				++numOptions;
			}
		}
		content = '<div class="cv-node-options num-options-'+ numOptions +'">' + content + '</div>';
		container.html(content);
	};

	pathing._activateNode = function(data, node) {
		var self = this,
				activeNode;

		// toggle node on/off
		if (this._pathLocked && data === this._pathLocked.data) {
			self._unlockNode(data, node)();
			// allow pivot node to relock on new side
			var side = (d3.mouse(node)[0] >= self._options.nodeWidth/2) ? 1 : -1; // left side = -1, right side = 1
			if (!data.isPivot || side === self._lastSide) {
				return;
			}
		}
		this._setPathLocked({ data: data, elem: node });
		d3.select(self._options.parent).select('.pathing-cv-container')
			.on('click.node', null)
			.on('click.link', null);
		activeNode = d3.selectAll('.cv-node-active');
		activeNode.classed('cv-node-active', false);
		d3.selectAll('.cv-link-active').classed('cv-link-active', false);
		d3.select(node).classed('cv-node-active', true);

		// truncate any existing nodes when a new node is activated
		if (activeNode.node()) {
			this._truncateFullTitle(activeNode.datum(), activeNode.node());
		}
		// show paths (if necessary)
		// this must be called before information so paths are set
		this._renderNodePaths(data, node);

		// show buttons on node
		this._showNodeOptions(data, node);

		// update/show info pane
		this._showInformation(data, node);

		// scroll
		this._scrollToElem(node);

		//show node title without truncation
		this._showFullTitle(data, node);

		setTimeout(function() {
			d3.select(self._options.parent).select('.pathing-cv-container')
				.on('click.node', self._unlockNode(data, node));
		}, 10);
	};

	// on hover, render the node paths
	pathing._showNodePaths = function(data, node) {
		if (this._pathLocked) { return; }

		// show link overlays
		this._renderNodePaths(data, node);
	};

	pathing._showFullTitle = function(data, node) {
		var title = d3.select(node).select('.node-title');
		if (title.text() !== data.label) {
			// Move node to bottom of nodes in the doc
			// to move text to the top of the z-index
			node.parentNode.appendChild(node);
			data.truncation = title.text();
			title.text(data.label);
			this._titleBackground(title, true);
		}
	};

	pathing._truncateFullTitle = function(data, node) {
		if (this._pathLocked && this._pathLocked.data === data) { return; }
		if (data.truncation) {
			var title = d3.select(node).select('.node-title');
			title.text(data.truncation);
			this._titleBackground(title, false);
		}
	};

	pathing._titleBackground = function(title, visible) {
		var container = d3.select(title.node().parentNode),
			titleRect, titleWidth;
		if (!visible) { // remove
			container.select('.text-bg').remove();
		} else {
			titleRect = title.node().getBoundingClientRect();
			titleWidth = titleRect.width + 10; // add padding to the ends
			container.insert('rect', ':first-child')
				.classed('text-bg', true)
				.attr('height', titleRect.height)
				.attr('width', titleWidth)
				.attr('x', this._getTitleBackgroundXValue(title, titleWidth))
				.attr('y', (titleRect.height + 1) * -1);
		}
	};

	pathing._getTitleBackgroundXValue = function(title, width) {
		var titleX = title.attr('x');
		if (title.attr('text-anchor') === 'start') {
			return titleX;
		} else if (title.attr('text-anchor') === 'middle') {
			return titleX - (width / 2);
		} else if (title.attr('text-anchor') === 'end') {
			return titleX - width;
		}
	};

	pathing._renderNodePaths = function(data, node, resize) {
		var parent = d3.select(this._options.parent).select('.pathing-cv-container');
		// if we were going to hide, don't now
		clearTimeout(this._hidePathOverlaysTimer);

		// Avoid re-rendering of same paths
		parent.on('mousemove.node', null);
		if (this._pathedObj && this._pathedObj.data === data && !resize) {
			return;
		}
		this._setPathedObj({ data: data, elem: node });

		var side = 0, self = this, overlays, paths,
			nodePaths = this._dataAdapter.nodePaths(data);

		// determine side of the node that we are over
		function sideLinkPaths() {
			// filter out one side or the other only if we have BOTH
			// full paths (no nulls) that start and end on the node aka pivot
			paths = self._activePaths = nodePaths.filter(function(p) {
				var index = p.nodes.indexOf(data._pid);
				return (side > 0 && index + 1 < p.nodes.length) ||
					(side < 0 && index > 0);
			});
			overlays = self._dataAdapter.nodePathData(paths, data, side);
			self._createPathOverlays(overlays);
		}

		function updateLinkPaths() {
			var x = 0;
			// d3 throws a javascript error if no mouse event occurred before we call
			try { x = d3.mouse(node)[0]; } // catch if there is no mouse event
			catch (e) {}
			var newSide = (x >= self._options.nodeWidth/2) ? 1 : -1; // left side = -1, right side = 1
			if (newSide !== side) {
				self._lastSide = side = newSide;
				sideLinkPaths();
			}
		}
		// determine if we need to handle sides of the node or just draw all paths
		if (data.isPivot) {
			if (resize) {
				side = self._lastSide;
				sideLinkPaths();
			} else {
				updateLinkPaths(); // set the side and overlays
				if (!self._pathLocked) {
					parent.on('mousemove.node', function(d, i) { updateLinkPaths(); });
				}
			}
		} else {
			self._lastSide = 0;
			self._activePaths = nodePaths;
			overlays = this._dataAdapter.nodePathData(nodePaths, data, side);
			self._createPathOverlays(overlays);
		}

		setTimeout(function() {
			parent.classed('path-overlays', true);
		}, 1);
	};

	pathing._showNodeOptions = function(data, node) {
		var self = this, numCols = this._numColumns,
			parent = d3.select(this._options.parent).select('.pathing-cv-container'),
			offsetContainer = parent.node(),
			options = this._options, delay = 50,
			rectNode = d3.select(node).select('.node-bg').node(),
			containerBounds = offsetContainer.getBoundingClientRect(),
			nodeBounds = rectNode.getBoundingClientRect(),
			top = nodeBounds.top - containerBounds.top,
			left = nodeBounds.left - containerBounds.left + (options.nodeWidth / 2),
			optionContainer = parent.select('.cv-path-node-options');

		if (optionContainer.empty()) {
			optionContainer = parent.append('div').classed('cv-path-node-options', true).attr('node', data._pid);
		} else if (optionContainer.attr('node') == data._pid && optionContainer.classed('is-open')){
			// just update the position, due to resize
		} else {
			this._removeNodeOptions();
			delay = 300; // wait for previous to close, better UI and performs better
			optionContainer = parent.append('div').classed('cv-path-node-options', true).attr('node', data._pid);
		}

		optionContainer
			.classed('is-last-column', (numCols > 1 && numCols - 1 === data.column))
			.style('top', top + 'px')
			.style('left', left + 'px');
		this._setOptionContainerContent(optionContainer, data);

		setTimeout(function() {
			optionContainer.classed('is-open', true);
		}, delay);
	};

	pathing._formatMetricValue = function(d) {
		return this._formatNumber('decimal', d.value) + ' ' + this._options.metricName;
	};

	pathing._formatPathInformation = function(t) {
		var options = this._options, self = this, colors = options.colors;
		return function(d, i) {
			var endNode = self._dataAdapter.getPathEnd(d),
				total = endNode ? (endNode.value) ? endNode.value : t : t, // if node and value is > 0, use it
				content = '', value = d.values[0], percent = value / total;
			i = i % colors.length;
			content += '<span class="pathing-path-marker" style="background-color: ' + colors[i] + '"></span>';
			// todo avg values if necessary
			content += '<span class="pathing-path-value"><span class="pathing-path-num">' + self._formatNumber('decimal', value) + '</span> <span class="pathing-path-perc">' +
				self._formatNumber('percent', percent) + '</span></span>';
			return content;
		};
	};

	pathing._highlightPath = function(data, index, elem) {
		var options = this._options, parent = options.parent,
			e = d3.event, lock = !e || (e && 'click' === e.type),
			container = d3.select(parent).selectAll('.path-overlay-container'),
			infoContainer = d3.select(parent).selectAll('.pathing-cv-info-pane'),
			line = container.selectAll('.link.path'+index),
			links = container.selectAll('.link:not(.path'+index+')');

			if (lock) { // tap, lock or unlock
				if (this._lineLocked === data) { // toggle
					this._setLineLock(null);
					return this._removeHightlightPath();
				}
				this._setLineLock(data);
				infoContainer.selectAll('.locked').classed('locked', false);
				d3.select(elem).classed('locked', true);
			} else if (this._lineLocked) { return; } // hover doesn't update when locked

			container.selectAll('.link.inactive').classed('inactive', false);
			links.classed('inactive', true);
			line.classed('active', true);
	};

	pathing._setLineLock = function(d) {
		var options = this._options;
		if (this._lineLocked === d) { return; } // only fire event if different
		this._lineLocked = d;
		this._callPathSelected(d);
	};

	pathing._setPathedObj = function(d) {
		this._pathedObj = d;
	};

	pathing._setPathLocked = function(d) {
		var options = this._options;
		if (this._pathLocked === d) { return; } // only fire event if different
		this._pathLocked = d;
		this._callPathSelected();
	};

	pathing._callPathSelected = function(path) {
		var params = {}, options = this._options,
			data = this._pathLocked && this._pathLocked.data || {};
		if (path) {
			params.path = path.nodes + '';
		}
		if ('undefined' !== typeof data._pid) {
			params.node = data._pid;
			params.side = this._lastSide;
		}
		if ('undefined' !== typeof data.source || 'undefined' !== typeof data.target) {
			params.source =  (data.source) ? data.source._pid : null;
			params.target = (data.target) ? data.target._pid : null;
		}
		if('function' == typeof options.pathSelected) {
			options.pathSelected(params, this._pathLocked, path);
		}
	};

	pathing._removeHightlightPath = function() {
		if (this._lineLocked) { return; }
		var options = this._options, parent = options.parent,
			infoContainer = d3.select(parent).selectAll('.pathing-cv-info-pane'),
			links = d3.select(parent).selectAll('.path-overlay-container').selectAll('.link');
			links.classed('inactive', false).classed('active', false);
			infoContainer.selectAll('.locked').classed('locked', false);
	};

	pathing._showInformation = function(data, elem) {
		var self = this, options = this._options, content = '',
			isNode = this._isDataObjNode(data),
			l10n = this._dataAdapter.l10n.labels.pathing,
			pane = d3.select(this._options.parent).select('.pathing-cv-info-pane'),
			paneTitle = pane.selectAll('.pathing-cv-info-title'),
			paneValue = pane.selectAll('.pathing-cv-info-value'),
			panePaths = pane.selectAll('.pathing-cv-info-paths');

		this._setLineLock(null);
		this._removeHightlightPath();

		// Handle link/node
		var label, value = this._formatMetricValue(data),
			last = false;
		if (isNode) {
			label = data.label;
			value = this._formatMetricValue(data);
			last = (data.column == this._numColumns - 1);
		} else {
			var pattern = l10n.percOfNode;
			if (!data.source) {
				label = l10n['nodeEntries'].replace(/\{label\}/i, data.target.label);
				value = this._formatMetricValue(data) + '<span class="perc">' +
					pattern
						.replace(/\{perc\}/i, this._formatNumber('percent', data.value / data.target.value))
						.replace(/\{label\}/i, data.target.label) + '</span>';
			} else if (!data.target) {
				label = l10n['nodeExits'].replace(/\{label\}/i, data.source.label);
				value = this._formatMetricValue(data) + '<span class="perc">' +
					pattern
						.replace(/\{perc\}/i, this._formatNumber('percent', data.value / data.source.value))
						.replace(/\{label\}/i, data.source.label) + '</span>';
			} else {
				var adapter = this._dataAdapter,
					dir = adapter.getPathDirection(adapter.data().paths[data.paths[0]]),
					node = (dir < 0) ? data.target : data.source;
				label = l10n['nodeToNode']
					.replace(/\{source\}/i, data.source.label)
					.replace(/\{target\}/i, data.target.label);
				value = this._formatMetricValue(data) + '<span class="perc">' +
					pattern
						.replace(/\{perc\}/i, this._formatNumber('percent', data.value / node.value))
						.replace(/\{label\}/i, node.label) + '</span>';
			}
		}
		pane.classed('is-last-column', last);
		paneTitle.html(label);
		paneValue.html(value);

		// Add path info
		var pathTitle = panePaths.selectAll('.pathing-cv-path-title').data([0]);
		pathTitle.enter().append('span').classed('pathing-cv-path-title', true);
		pathTitle.html(this._dataAdapter.activePathsTitle(this._activePaths));
		var path = panePaths.selectAll('.pathing-cv-path-info').data(this._activePaths);
		path.enter().append('span').classed('pathing-cv-path-info', true);

		path.on('click.line', function(d, i) { self._highlightPath(d, i, this); })
			.on('mouseover.line', function(d, i) { self._highlightPath(d, i, this); })
			.on('mouseout.line', function(d, i) { self._removeHightlightPath(); })
			.html(this._formatPathInformation(data.value));
		path.exit()
			.on('click.line', null)
			.on('mouseover.line', null).on('mouseout.line', null).remove();
	};

	pathing._defaultInformation = function() {
		this._setLineLock(null);
		this._removeHightlightPath();

		var pane = d3.select(this._options.parent).select('.pathing-cv-info-pane'),
			paneTitle = pane.selectAll('.pathing-cv-info-title'),
			paneValue = pane.selectAll('.pathing-cv-info-value'),
			panePaths = pane.selectAll('.pathing-cv-info-paths'),
			l10n = this._dataAdapter.l10n.labels.pathing;

		// Explanation on pathing TODO: Localize
		var help = '<p>'+ l10n.help1 + '</p>';
		help += '<p>'+ l10n.help2 + '</p>';
		help += '<p>'+ l10n.help3 + '</p>';
		// Focus
		help += '<p><span class="cv-node-option"><i class="pivot"></i></span><span class="cv-option-title">'+ l10n.focus + '</span></p>';
		help += '<p>'+ l10n.focusHelp + '</p>';
		// Expand
		help += '<p><span class="cv-node-option"><i class="expand"></i></span><span class="cv-option-title">'+ l10n.expand + '</span></p>';
		help += '<p>'+ l10n.expandHelp + '</p>';
		// Collapse
		help += '<p><span class="cv-node-option"><i class="collapse"></i></span><span class="cv-option-title">'+ l10n.collapse + '</span></p>';
		help += '<p>'+ l10n.collapseHelp + '</p>';

		paneTitle.html(l10n.title);
		paneValue.html('<div class="help">'+help+'</div>');
		panePaths.html('');
	};

	pathing._scrollToElem = function(elem) {
		// scroll to show node if needed
		var options = this._options,
			parent = d3.select(this._options.parent).select('.pathing-cv-container'),
			offsetContainer = parent.node(),
			wrapper = d3.select(options.parent).select('.pathing-cv-wrapper'),
			node = d3.select(elem),
			rectNode = (!node.selectAll('.node-bg').empty()) ? node.select('.node-bg').node() : node.node(),
			containerBounds = offsetContainer.getBoundingClientRect(),
			nodeBounds = rectNode.getBoundingClientRect(),
			top = nodeBounds.top - containerBounds.top,
			left = nodeBounds.left - containerBounds.left + (options.nodeWidth / 2);

		// no scroll, return
		if (!wrapper.classed('is-wider') && !wrapper.classed('is-taller')) { return; }

		function scrollTween(offsetX, offsetY) {
			return function() {
				var iX = (offsetX !== null) ? d3.interpolateNumber(wrapper.node().scrollLeft, offsetX) : null,
					iY = (offsetY !== null) ? d3.interpolateNumber(wrapper.node().scrollTop, offsetY) : null;
				return function(t) {
					if (iX !== null) { wrapper.node().scrollLeft = iX(t); }
					if (iY !== null) { wrapper.node().scrollTop = iY(t); }
				};
			};
		}

		var scrollX = null, scrollY = null;
		if (wrapper.classed('is-wider')) {
			var viewportWidth = parseInt(wrapper.style('width'), 10),
				visibleWidth = parseInt(parent.style('width'), 10);

			scrollX = Math.min(visibleWidth - viewportWidth,
						Math.max(0, left - (viewportWidth / 2)));
		}
		if (wrapper.classed('is-taller')) {
			var viewportHeight = parseInt(wrapper.style('height'), 10),
				visibleHeight = parseInt(parent.style('height'), 10);
			scrollY = Math.min(visibleHeight - viewportHeight,
						Math.max(0, top + 40 - (viewportHeight / 2))); // 40 adjust for title
		}

		d3.transition()
		    .duration(300)
		    .tween('scroll', scrollTween(scrollX, scrollY));
	};

	pathing._unlockNode = function(data, node) {
		var self = this;
		return function(d, i) {
			self._setPathLocked(null);
			d3.select(self._options.parent).select('.pathing-cv-container')
				.on('click.node', null);
			self._deactivateNode(d3.event, data, node);
			self._truncateFullTitle(data, node);
		};
	},

	pathing._deactivateNode = function(e, d, node) {
		var target = d3.select(e.target),
			options = this._options, data = d || {};
		d3.select(node).classed('cv-node-active', false);
		this._removeNodeOptions(false);
		this._defaultInformation();
		this._hideNodePaths();

		// Handle click on options
		// These must be handled AFTER cleanup since they could change data in sync
		if ('click' === e.type) {
			if (!target.classed('cv-node-option')) { // handle nested elements getting click event
				target = d3.select(target.node().parentNode);
			}
			if (target.classed('cv-node-expand') && ('function' === typeof options.expandNode)) {
				options.expandNode(data);
			}
			if (target.classed('cv-node-collapse') && ('function' === typeof options.collapseNode)) {
				options.collapseNode(data);
			}
			if (target.classed('cv-node-pivot') && ('function' === typeof options.pivotNode)) {
				options.pivotNode(data);
			}
		}
	};

	// Remove the node options popup
	pathing._removeNodeOptions = function(now) {
		var container = d3.selectAll('.cv-path-node-options');
		container.classed('is-open', false);
		setTimeout(function() { container.remove(); }, (now) ? 0 : 300); // give time to animate off
	};

	pathing._hideNodePaths = function() {
		var parent = d3.select(this._options.parent).select('.pathing-cv-container');
		parent.on('mousemove.node', null);
		if (this._pathLocked) { return; }
		this._removePathOverlays(parent);
	};

	pathing._activateLink = function(data, link) {
		var self = this;

		// toggle link on/off
		if (this._pathLocked && data === this._pathLocked.data) {
			self._unlockLink(data, link);
			return;
		}
		this._setPathLocked({ data: data, elem: link });

		d3.select(self._options.parent).select('.pathing-cv-container')
			.on('click.node', null)
			.on('click.link', null);
		d3.selectAll('.cv-node-active').classed('cv-node-active', false);
		d3.selectAll('.cv-link-active').classed('cv-link-active', false);
		d3.select(link).classed('cv-link-active', true);
		this._removeNodeOptions(); // handle popped up node options

		// show paths (if necessary)
		// this must be called before information so paths are set
		this._renderLinkPaths(data, link);

		// update/show info pane
		this._showInformation(data, link);

		// scroll
		this._scrollToElem(link);

		setTimeout(function() {
			d3.select(self._options.parent).select('.pathing-cv-container')
				.on('click.link', self._unlockLink(data, link));
		}, 10);
	};

	// on hover, render the link paths
	pathing._showLinkPaths = function(data, link) {
		if (this._pathLocked) { return; }

		// show link overlays
		this._renderLinkPaths(data, link);
	};

	pathing._renderLinkPaths = function(data, link, resize) {
		// if we were going to hide, don't now
		clearTimeout(this._hidePathOverlaysTimer);

		// Avoid re-rendering of same paths
		if (this._pathedObj && this._pathedObj.data === data && !resize) {
			return;
		}
		this._setPathedObj({ data: data, elem: link });

		// show link overlay
		var adapter = this._dataAdapter;
		this._activePaths = adapter.linkSortActivePaths(data);
		this._createPathOverlays(adapter.linkPathData(this._activePaths));

		var parent = d3.select(this._options.parent).select('.pathing-cv-container');
		setTimeout(function() {
			parent.classed('path-overlays', true);
		}, 1);
	};

	pathing._unlockLink = function(data, link) {
		var self = this;
		return function(d, i) {
			self._setPathLocked(null);
			d3.select(self._options.parent).select('.pathing-cv-container')
				.on('click.link', null);
			self._deactivateLink(d3.event, data, link);
		};
	},

	pathing._deactivateLink = function(e, d, link) {
		var parent = d3.select(this._options.parent).select('.pathing-cv-container');
		d3.select(link).classed('cv-link-active', false);
		this._defaultInformation();
		this._hideLinkPaths();
	};

	pathing._hideLinkPaths = function() {
		var parent = d3.select(this._options.parent).select('.pathing-cv-container');
		if (this._pathLocked) { return; }
		this._removePathOverlays(parent);
	};

	pathing._createPathOverlays = function(links) {
		// Graph the additional link content as an overlay
		var options = this._options, path = this._path,
			linkOverlay = d3.select(options.parent).select('.path-overlay-container'),
			link = linkOverlay.selectAll('path').data(links);
		link.enter().append('path');
		link.exit().remove();
		link.attr('class', function(d) {
				var pivot = (d.pivotStart) ? ' pivot-entry' : (d.pivotEnd) ? ' pivot-exit' : '';
				return 'link path' + d.path + pivot;
			})
			.attr('d', path.link())
			.attr('style', function(d, i) {
				var p = d.path % options.colors.length;
				return 'fill: ' + options.colors[p] + ';';
			})
			.sort(function(a, b) { // handle null values
				if (!a && !b) { return 0; }
				if (!a) { return 1; }
				if (!b) { return -1; }
				return b.dy - a.dy;
			});
	};

	pathing._removePathOverlays = function(parent) {
		clearTimeout(this._hidePathOverlaysTimer);
		this._setPathedObj(null);
		this._hidePathOverlaysTimer = setTimeout(function() {
			parent.classed('path-overlays', false);
		}, 20);
	};

	pathing._isDataObjNode = function(data) {
		return ('undefined' !== typeof data._pid);
	};

	/**
	 * Takes a data object with a path array and an _pid for a node or src/target _pids for a link
	 * If that node/link has that path, we lock the node/path and highlight the path
	 * @param {object} sel
	 *
	 * <pre><code>
	 *     {
	 *         path: '0,12,9,1',
	 *         node: '0'
	 *			// or
	 *         source: '12', // null
	 *         target: '9'
	 *     }
	 * </code></pre>
	 */
	pathing.setActivePath = function(params) {
		var options = this._options, self = this,
			data = this._dataAdapter.data();
		params = params || {};

		// Handle node/link first
		var isNode = ('undefined' !== typeof params.node), type, elems;
		if (isNode) {
			type = data.nodesById[params.node];
		} else {
			type = data.links.filter(function(l) {
				return ((!l.source && !params.source) || // both sources are null
						(l.source && params.source && l.source._pid + '' === params.source)) && // sources match
						((!l.target && !params.target) || // both targets are null
						(l.target && params.target && l.target._pid + '' === params.target)); // targets match
			});
			type = type.length && type[0] || null;
		}
		elems = (isNode) ? '.node' : '.link';
		if (!type) { return; }

		// Handle path if it exists
		var hasPath = false, path;
		hasPath = data.paths.some(function(p) {
			path = p.nodes;
			return p.nodes.toString() === params.path;
		});

		d3.select(options.parent).selectAll(elems).each(function(d, i) {
			if (d === type) {
				if (isNode) {
					self._activateNode(d, this);
				} else {
					self._activateLink(d, this);
				}
				if (!hasPath) { return; }
				d3.select(options.parent).selectAll('.pathing-cv-path-info').filter(function(d, i) {
					if (d.nodes.toString() === path.toString()) {
						self._highlightPath(d, i, this);
					}
				});
			}
		});
	};

	global.cloudViz.pathing = cloudViz.util.createConstructor(pathing);
}(this));
/*global d3*/
(function(global) {
	'use strict';

	d3.pathing = function() {
		var pathing = {},
			nodeWidth = 24,
			nodePadding = 8,
			size = [1, 1],
			nodes = [],
			links = [],
			numColumns = NaN,
			minNodeHeight = 0;

		pathing.nodeWidth = function(_) {
			if (!arguments.length) { return nodeWidth; }
			nodeWidth = +_;
			return pathing;
		};

		pathing.nodePadding = function(_) {
			if (!arguments.length) { return nodePadding; }
			nodePadding = +_;
			return pathing;
		};

		pathing.nodes = function(_) {
			if (!arguments.length) { return nodes; }
			nodes = _;
			return pathing;
		};

		pathing.links = function(_) {
			if (!arguments.length) { return links; }
			links = _;
			return pathing;
		};

		pathing.size = function(_) {
			if (!arguments.length) { return size; }
			size = _;
			return pathing;
		};

		pathing.numColumns = function() {
			return numColumns;
		};

		// Enforces a minimum height restriction on a node.  BE CAREFUL WITH THIS PROPERTY!
		// The minNodeHeight property will distort data by weighting smaller nodes more than
		// larger nodes.  1px seems to be ok (so you can actually see the node) and doesn't
		// noticeably distort the data.
		pathing.minNodeHeight = function(_) {
			if (!arguments.length) { return minNodeHeight; }
			minNodeHeight = _;
			return pathing;
		};

		pathing.layout = function(iterations) {
			computeNodeLinks();
			computeNodeValues();
			computeNodeBreadths();
			computeNodeDepths(iterations);
			computeLinkDepths();
			return pathing;
		};

		pathing.relayout = function() {
			computeLinkDepths();
			return pathing;
		};

		pathing.link = function() {
			var curvature = 0.5;

			function link(d) {
				var x0, x1, xi, x2, x3, x4, x5, y0, y1, y2, y3,
					curveWidth, curveHeight,
					heightOffset = 5, maxWidth = 15;

				// determine the size of the curve based on dy for entry/exit
				curveWidth = curveHeight = Math.min(d.dy + heightOffset, maxWidth);
				if (d.source === null) {
					x0 = d.target.x - curveWidth;
					x1 = d.target.x;
					y0 = d.target.y - heightOffset;
					y1 = d.target.y + d.dy;
					return 'M' + x0 + ',' + y0 +
							'h' + curveWidth + 'v' + (y1 - y0) +
							'c-' + curveWidth + ',0' +
							',-' + curveWidth + ',-' + (curveHeight/2) +
							',-' + curveWidth + ',-' + curveHeight +
							'z';
				}
				if (d.target === null) {
					x0 = d.source.x + d.source.dx;
					x1 = d.source.x + d.source.dx + curveWidth;
					y0 = d.source.y + d.source.dy - d.dy;
					y1 = d.source.y + d.source.dy + heightOffset;
					return 'M' + x1 + ',' + y1 +
							'h-' + curveWidth + 'v-' + (y1 - y0) +
							'c' + curveWidth + ',0' +
							',' + curveWidth + ',' + (curveHeight/2) +
							',' + curveWidth + ',' + curveHeight +
							'V' + y1 + 'z';
				}

				x0 = d.source.x + d.source.dx,
				x1 = d.target.x,
				xi = d3.interpolateNumber(x0, x1),
				x2 = xi(curvature),
				x3 = xi(1 - curvature),
				x4 = x3 + ((d.dy < 15) ? ((d.source.y < d.target.y) ? -1 * d.dy : d.dy) : 0),
				x5 = x2 + ((d.dy < 15) ? ((d.source.y < d.target.y) ? -1 * d.dy : d.dy) : 0),
				y0 = d.source.y + d.sy,
				y1 = d.target.y + d.ty,
				y2 = y1 + d.dy,
				y3 = y0 + d.dy;
				return 'M' + x0 + ',' + y0 +
						'C' + x2 + ',' + y0 +
						' ' + x3 + ',' + y1 +
						' ' + x1 + ',' + y1 +
						'v' + d.dy +
						'C' + x4 + ',' + y2 +
						' ' + x5 + ',' + y3 +
						' ' + x0 + ',' + y3 + 'Z';
			}

			link.curvature = function(_) {
				if (!arguments.length) { return curvature; }
				curvature = +_;
				return link;
			};

			return link;
		};

		// Populate the sourceLinks and targetLinks for each node.
		// Also, if the source and target are not objects, assume they are indices.
		function computeNodeLinks() {
			nodes.forEach(function(node) {
				node.sourceLinks = [];
				node.targetLinks = [];
				node.entryLinks = [];
				node.exitLinks = [];
			});
			links.forEach(function(link) {
				var source = link.source,
						target = link.target;

				if (source !== null && typeof source === 'number') { source = link.source = nodes[link.source]; }
				if (target !== null && typeof target === 'number') { target = link.target = nodes[link.target]; }

				if (source !== null && target !== null) {
					source.sourceLinks.push(link);
					target.targetLinks.push(link);
				}
				else if (source === null) {
					target.entryLinks.push(link);
				}
				else {
					source.exitLinks.push(link);
				}
			});
		}

		// Compute the value (size) of each node by summing the associated links.
		function computeNodeValues() {
			nodes.forEach(function(node) {
				// If the node has a property "total", disregard the adding up of links and just use that for the value (size).
				if (node.hasOwnProperty('total')) {
					node.value = node.total;
				}
				else {
					node.value = Math.max(
						d3.sum(node.sourceLinks, value) + d3.sum(node.exitLinks, value),
						d3.sum(node.targetLinks, value) + d3.sum(node.entryLinks, value)
					);
				}
			});
			function hasLinks(node) {
				return (node.sourceLinks && node.sourceLinks.length) ||
						(node.targetLinks && node.targetLinks.length) ||
						(node.exitLinks && node.exitLinks.length) ||
						(node.entryLinks && node.entryLinks.length);
			}
			// sort node values
			nodes.sort(function(a, b) {
				// sort nodes with links before those that don't
				var al = hasLinks(a), bl = hasLinks(b);
				if (al && !bl) { return -1; }
				if (bl && !al) { return 1; }
				// if same on links, sort on value
				return b.value - a.value;
			});
		}

		// Iteratively assign the breadth (x-position) for each node.
		// Nodes are assigned the maximum breadth of incoming neighbors plus one;
		// nodes with no incoming links are assigned breadth zero, while
		// nodes with no outgoing links are assigned the maximum breadth.
		function computeNodeBreadths() {
			var x = 0,
				columns = [],
				nodeSize = size[0] - nodeWidth;

			nodes.forEach(function(node) {
				node.x = node.column;
				node.dx = nodeWidth;
				if (columns.indexOf(node.column) < 0) {
					columns.push(node.column);
					node.columnIndex = columns.length - 1;
				}
				else {
					node.columnIndex = columns.indexOf(node.column);
				}
			});

			numColumns = columns.length;
			scaleNodeBreadths(numColumns > 1 ? nodeSize / (numColumns - 1) : nodeSize);
		}

		function moveSourcesRight() {
			nodes.forEach(function(node) {
				if (!node.targetLinks.length) {
					node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
				}
			});
		}

		function moveSinksRight(x) {
			nodes.forEach(function(node) {
				if (!node.sourceLinks.length) {
					node.x = x - 1;
				}
			});
		}

		function scaleNodeBreadths(kx) {
			nodes.forEach(function(node) {
				node.x *= kx;
			});
		}

		function computeNodeDepths(iterations) {
			var nodesByBreadth = d3.nest()
				.key(function(d) { return d.x; })
				.sortKeys(d3.ascending)
				.entries(nodes)
				.map(function(d) { return d.values; });

			function initializeNodeDepth() {
				var ky = d3.min(nodesByBreadth, function(nodes) {
					var sum = d3.sum(nodes, value) || 1;
					return (size[1] - (nodes.length - 1) * nodePadding) / sum;
				});

				nodesByBreadth.forEach(function(nodes) {
					nodes.forEach(function(node, i) {
						node.y = i;
						node.row = i;
						node.dy = Math.max(minNodeHeight, node.value * ky);
					});
				});

				links.forEach(function(link) {
					link.dy = link.value * ky;
				});
			}

			function relaxLeftToRight(alpha) {
				nodesByBreadth.forEach(function(nodes, breadth) {
					nodes.forEach(function(node) {
						if (node.targetLinks.length) {
							var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
							node.y += (y - center(node)) * alpha;
						}
					});
				});

				function weightedSource(link) {
					return center(link.source) * link.value;
				}
			}

			function relaxRightToLeft(alpha) {
				nodesByBreadth.slice().reverse().forEach(function(nodes) {
					nodes.forEach(function(node) {
						if (node.sourceLinks.length) {
							var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
							node.y += (y - center(node)) * alpha;
						}
					});
				});

				function weightedTarget(link) {
					return center(link.target) * link.value;
				}
			}

			function resolveCollisions() {
				nodesByBreadth.forEach(function(nodes) {
					var node,
							dy,
							y0 = 0,
							n = nodes.length,
							i;

					// Push any overlapping nodes down.
					nodes.sort(ascendingDepth);
					for (i = 0; i < n; ++i) {
						node = nodes[i];
						dy = y0 - node.y;
						if (dy > 0) { node.y += dy; }
						y0 = node.y + node.dy + nodePadding;
					}

					// If the bottommost node goes outside the bounds, push it back up.
					dy = y0 - nodePadding - size[1];
					if (dy > 0) {
						y0 = node.y -= dy;

						// Push any overlapping nodes back up.
						for (i = n - 2; i >= 0; --i) {
							node = nodes[i];
							dy = node.y + node.dy + nodePadding - y0;
							if (dy > 0) { node.y -= dy; }
							y0 = node.y;
						}
					}
				});
			}

			function ascendingDepth(a, b) {
				return a.y - b.y;
			}

			initializeNodeDepth();
			resolveCollisions();
			for (var alpha = 1; iterations > 0; --iterations) {
				relaxRightToLeft(alpha *= 0.99);
				resolveCollisions();
				relaxLeftToRight(alpha);
				resolveCollisions();
			}
		}

		function computeLinkDepths() {
			nodes.forEach(function(node) {
				node.sourceLinks.sort(ascendingTargetDepth);
				node.targetLinks.sort(ascendingSourceDepth);
			});
			nodes.forEach(function(node) {
				var sy = 0, ty = 0;
				node.entryLinks.forEach(function(link) {
					link.ty = ty;
					ty += link.dy;
				});
				node.sourceLinks.forEach(function(link) {
					link.sy = sy;
					sy += link.dy;
				});
				node.targetLinks.forEach(function(link) {
					link.ty = ty;
					ty += link.dy;
				});
				node.exitLinks.forEach(function(link) {
					link.sy = sy;
					sy += link.dy;
				});
			});

			function ascendingSourceDepth(a, b) {
				return a.source.y - b.source.y;
			}

			function ascendingTargetDepth(a, b) {
				return a.target.y - b.target.y;
			}
		}

		function center(node) {
			return node.y + node.dy / 2;
		}

		function value(link) {
			return link.value;
		}

		return pathing;
	};
}(this));


/**
 * Anomaly Detection
 * An overview chart for showing anomaly data across multiple metrics.
 * options are defined in the code below.
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {},
		core = cloudViz.core || {},
		dv = global.dv || {},
		d3 = global.d3 || {},
		anomaly = Object.create(core);

	anomaly.init = function(options) {
		this._type = 'anomaly';
		options = options || {};
		this._initDefaultOptions();
		this.setOptions(options);
		this._initializeAnomaly();
		return this;
	};

	anomaly._initDefaultOptions = function(options) {
		var defaults = {

			// An object which specifies which properties in each object of the data array refers to x and y.
			mappings: {	"x": "date", "y": "deviation", "category": "metric" },

			// The preferred number of bins that should be used.  This is only a suggestion that the d3.anomaly can override.
			//
			// The anomaly chart will use a number of bins that lead to pretty intervals that are easier to process.  For
			// example, if I ask for 3 bins for an interval of [0, 100], we would be showing bins of
			// [0-33.3333, 33.3333-66.6667, 66.6667-100]. Users would rather have 4 bins of [0-25, 25-50, 50-75, 75-100]
			// for reduced cognitive load, so this visualization will opt for 4 bins instead of 3.
			bins: 12,

			// Determines how many x ticks should be drawn.  This ultimately determines how things are grouped.  There are two
			// options that can be used here.
			//
			// Option 1: Supply an integer argument.  This will render a preferred number of x ticks and the  anomaly chart
			// will determine the closest most optimal number of ticks to that preferred number. There may be times where 4
			// may be supplied and the anomaly chart is rendered with 3 or 5 ticks.  This is because ticks is simply a hint
			// and in that particular case 4 ticks may have produced fractions or odd intervals which are not easily digested.
			//
			//     Usage:  { ... xTicks: 5, ... }  // Will draw a number of ticks close to 5, but could be 3 - 7.
			//
			// Option 2: Supply a function argument. This function will be invoked, being passed the start and end date of the
			// scale's domain, in addition to the step argument (xTickInterval). There are a few functions defined by D3 which
			// can be used here to specify time interval (https://github.com/mbostock/d3/wiki/Time-Intervals#aliases)
			//
			//     Usage:  .ticks(d3.time.weeks, 2)  // This will add a tick every 2 weeks.
			//             .ticks(d3.time.days, 1)  // This will add a tick for every day.
			xTicks: 7,

			// This property is only useful if xTicks is a function. It defines the interval which is passed into the xTicks
			// function.  In the case of d3.time.* functions, it represents the interval between ticks and defines when they
			// should be drawn.
			//
			//     Usage:  { ... xTicks: d3.time.weeks, xTickInterval: 2, ... } // This will add a tick every 2 weeks.
			//     Usage:  { ... xTicks: d3.time.days, xTickInterval: 1, ... }  // This will add a tick for every day.
			xTickInterval: undefined,

			// Sets the upper limit on the x axis (this should be a date). Depending on xTicks (and xTickInterval), this may
			// not guarantee that the preferred xUpperLimit is chosen.  There are cases where it could be extended in order
			// to keep x bins uniform in width -- which avoids distorting the anomaly rectangle nodes.
			xUpperLimit: undefined,

			// Sets the lower limit on the x axis (this should be a date).  Depending on xTicks (and xTickInterval), this
			// may not guarantee that the preferred xLowerLimit is chosen.  There are cases where it could be extended in
			// order to keep x bins uniform in width -- which avoids distorting the anomaly rectangle nodes.
			xLowerLimit: undefined,

			// Show all anomalies as positive even if they are negative. This is useful if positive/negative direction
			// aren't important to the user.
			normalizePositive: false,

			// A callback which will be called whenever an anomaly is moused-over. The supplied callback function will be
			// called and passed two parameters:  data and index with the context `this` being set to the moused-over node.
			// The data parameter refers to the data which has been bound to that moused-over anomaly. The index represents
			// the index of the data object which was bound to the anomaly in context of the entire array of data objects.
			onMouseOverAnomaly: null,

			// A callback which will be called whenever an anomaly is moused-out. The supplied callback function will be
			// called and passed two parameters:  data and index with the context `this` being set to the moused-out node.
			// The data parameter refers to the data which has been bound to that moused-out anomaly. The index represents
			// the index of the data object which was bound to the anomaly in context of the entire array of data objects.
			onMouseOutAnomaly: null,

			// A callback which will be called whenever one or more anomalies are selected. The supplied callback function
			// will be called and passed no parameters.  The `this` context of the function will be bound to the group of
			// anomaly nodes which were selected.  Each node has a __data__ property which exposes which data object was
			// associated with each node.
			onSelectAnomalies: null
		};
		return Object.getPrototypeOf(anomaly)._initDefaultOptions.call(this, defaults);
	};

	/**
	 * Renders the chart.
	 */
	anomaly._render = function() {
		this._configureAnomaly();
		this._anom.layout();
	};

	// Private
	anomaly._initializeAnomaly = function() {
		var options = this._options,
			mappings = options.mappings,
			self = this;

		this._anom = d3.anomaly()
			.on("mouseover", function(node, data, index) {
				self._anom.nodes(function(d, i) {
					var e = d3.select(this)
						.transition()
						.duration(750)
						.style("opacity", d[mappings.category] === data[mappings.category] ? 0.8 : 0.2);
				});

				if (options.onMouseOverAnomaly) {
					options.onMouseOverAnomaly.call(node, data, index);
				}
			})
			.on("mouseout", function(node, data, index) {
				self._anom.nodes(function(d, i) {
					var e = d3.select(this)
						.transition()
						.duration(750)
						.style("opacity", 1);
				});

				if (options.onMouseOutAnomaly) {
					options.onMouseOutAnomaly.call(node, data, index);
				}
			})
			.on("select", function(selection) {
				// Make all nodes unselected, and then select the ones we're interested in.
				self._anom.nodes(function(d, i) {
					d3.select(this)
						.classed("selected", false);
				});
				selection.classed("selected", true);

				if (options.onSelectAnomalies) {
					options.onSelectAnomalies.call(selection);
				}
			});
	};

	// Private
	anomaly._configureAnomaly = function() {
		var options = this._options;
		var width = dv.util.getPercentValue(options.width, options.parent.offsetWidth);
		var height = dv.util.getPercentValue(options.height, options.parent.offsetHeight);

		this._anom
			.data(zipData(options.data))
			.parent(options.parent)
			.mappings(options.mappings)
			.bins(options.bins)
			.size([width, height])
			.xUpperLimit(options.xUpperLimit)
			.xLowerLimit(options.xLowerLimit)
			.normalizePositive(options.normalizePositive)
			.xTicks(options.xTicks, options.xTickInterval);
	};

	anomaly._onAutoResize = function() {
		this.render();
	};

	/**
	 * Converts data from an object with tuples into an array of data objects which d3.anomaly expects.
	 */
	function zipData(data) {
		var retData = [],
			firstMapping = true;
		for (var mapping in data) {
			var tuple = data[mapping],
				i = -1,
				n = tuple.length;
			while (++i < n) {
				var obj,
					val = tuple[i];
				if (firstMapping) {
					obj = {};
					retData.push(obj);
				} else {
					obj = retData[i];
				}
				obj[mapping] = val;
			}
			firstMapping = false;
		}
		return retData;
	}

	/**
	 * Returns the inner d3.anomaly instance for customization and extension.
	 */
	anomaly.chart = function() {
		return this._anom;
	};

	global.cloudViz.anomaly = cloudViz.util.createConstructor(anomaly);
}(this));
(function(global){
	"use strict";
	d3.choropleth = function() {
		var salmonRun = ['#fae6be', '#eb782d', '#dc283c', '#640046'],
			salmonDarker = ['#c7b797', '#b85e23', '#a81e2e', '#300022'],
			sunnyDay = ['#faf0c8', '#d2dc73', '#5faf69', '#00505A'],
			sunnyDark = ['#c7bf9f', '#a0a858', '#437d4a', '#002226'],
			blueOcean = ['#d2e6fb', '#7dafe6', '#286eaf', '#1e5a8c'],
			blueDark = ['#b0d5fb', '#63a0e4', '#1c68af', '#10528a'],


			choropleth = {},
			data,
			size = [],
			p,
			$p,
			$wrapper,
			$container,
			svg,
			zoomContainer,

			options,
			projection,
			path,
			tooltip,
			max,
			min,
			extent = [0, 1],
			extentMin = (max - min) * extent[0],
			extentMax = (max - min) * extent[1],
			originalSibling = {},
			brushing = false,
			padding = { top: 0, left: 0, right: 0, bottom: 40 };

		choropleth.layout = function() {
			var self = this;
			if (!choropleth.data()) { throw new EmptyDataException(); }
			if (!choropleth.parent()) { throw new ParentNotSpecifiedException(); }
			size = choropleth.determineSize(options);
			choropleth.calcRange();
			$container = choropleth.createSVGContainer();

			// The GeoJSON is a String URL
			if (typeof options.geoJson === "string") {
				d3.json(options.geoJson, function(jsonData) {
					self._layoutWithData.call(self, jsonData);
				});
			} else {
				this._layoutWithData(options.geoJson);
			}
		};

		choropleth._layoutWithData = function(geoJsonData) {
			choropleth.drawGeos(geoJsonData);
			if (options.interactive) {
				choropleth.drawTooltip();
			}
			choropleth.drawLegend(options.theme, geoJsonData);
		};

		choropleth.determineSize = function(options) {
			var parent = options.parent,
				width = options.width ? options.width : parent.offsetWidth, // Grab the parent's width if we don't have width set
				height = options.height ? options.height : parent.offsetHeight; // Grab the parent's height if we don't have height set

			// If the parent's dimensions aren't set and there are no dimension options, fall back to defaults.
			width = width ? width : 700;
			height = height ? height : 450;

			return [width, height];
		};

		choropleth.calcRange = function() {
			for(var key in options.data.values) {
				if(typeof max == 'undefined') {
					max = options.data.values[key];
					min = options.data.values[key];
				}
				if(options.data.values[key] > max) {
					max = options.data.values[key];
				}
				if(options.data.values[key] < min) {
					min = options.data.values[key];
				}
			}
		};

		choropleth.drawLegend = function(theme, geoJsonData) {
			var self = this,
				height = 9,
				controlSpacer = 12,
				minMaxWidth = 35,
				legendWidth = Math.min(size[0] - padding.left, 630) - 25,
				leftPos = (size[0] - padding.left - legendWidth) / 2,
				barWidth = legendWidth - (minMaxWidth * 2) - (controlSpacer * 2),
				colors = [],
				darkColors = [];

			if(typeof theme != "undefined" && theme == "salmonRun") {
				colors = salmonRun;
				darkColors = salmonDarker;
			} else if(typeof theme != "undefined" && theme == "blueOcean") {
				colors = blueOcean;
				darkColors = blueDark;
			} else {
				colors = sunnyDay;
				darkColors = sunnyDark;
			}

			var legend = svg.selectAll(".legend").data([data]);
			legend.enter()
				.append("g")
					.classed("legend", true);
			legend.attr("transform", "translate(" + leftPos + "," + (size[1] - 24) + ")");

			var defs = legend.selectAll("defs").data([theme]);
			defs.enter().append("defs");
			defs.exit().remove();

			var defaultGradient = defs.selectAll("#defaultGradient-" + theme).data([theme]);
			defaultGradient.enter()
				.append("linearGradient")
					.attr("id", "defaultGradient-" + theme);
			defaultGradient.exit().remove();
			var darkGradient = defs.selectAll("#darkGradient-" + theme).data([theme]);
			darkGradient.enter()
				.append("linearGradient")
					.attr("id", "darkGradient-" + theme);
			darkGradient.exit().remove();

			var positions = ["0%", "33%", "67%", "100%"];

			var applyStops = function(selection, positions, colors) {
				var stop = selection.selectAll("stop").data(positions);
				stop.enter()
					.append("stop")
						.attr("class", function(d, i) { return "stop" + i; });
				stop.attr("offset", function(d) { return d; })
					.attr("stop-color", function(d, i) { return colors[i]; });
			};

			applyStops(defaultGradient, positions, colors);
			applyStops(darkGradient, positions, darkColors);

			var gradBg = legend.selectAll(".grad-bg").data([data]);
			gradBg.enter()
				.append("rect")
					.classed("grad-bg", true);
			gradBg
				.attr("x", minMaxWidth + controlSpacer)
				.attr("y", 0)
				.attr("rx", height / 2)
				.attr("ry", height / 2)
				.attr("width", barWidth)
				.attr("height", height);

			var gradRect = legend.selectAll(".grad-rect").data([data]);
			gradRect.enter()
				.append("rect")
					.classed("grad-rect", true);
			gradRect
				.classed("grad-rect", true)
				.attr("x", minMaxWidth + controlSpacer)
				.attr("y", 0)
				.style('stroke', 'url(#darkGradient-' + theme + ')')
				.style('fill', 'url(#defaultGradient-' + theme + ')')
				.attr("width", barWidth)
				.attr("height", height);


			var legendLabel = $wrapper.selectAll(".legend-label").data([min, max]);
			legendLabel.enter()
				.append("div")
					.attr("class", function(d, i) { return "legend-label " + (i ? "max" : "min"); });
			legendLabel
				.style("left", function(d, i) { return (i ? null : leftPos + "px"); })
				.style("right", function(d, i) { return (i ? leftPos + "px" : null); })
				.text(function(d, i) { return options.formatFunction(i ? max : min);});

			if (options.interactive) {
				var brush = d3.svg.brush()
					.x(d3.scale.linear().range([0, barWidth]))
					.extent(extent)
					.on("brushstart", function() {
						brushing = true;
					})
					.on("brushend", function() {
						brushing = false;
					})
					.on("brush", function() {
						extent = brush.extent();
						svg.selectAll(".grad-rect")
							.attr("width", (extent[1] - extent[0]) * barWidth)
							.attr("x", (barWidth * extent[0]) + minMaxWidth + controlSpacer);
						choropleth.drawGeos(geoJsonData);
					});

				var handleWidth = 9;
				var handleHeight = 26;

				var brushg = legend.selectAll(".brush").data([data]);
				brushg.enter()
					.append("g")
						.classed("brush", true);
				brushg
					.attr("transform", "translate(" + (minMaxWidth + controlSpacer) + ",0)")
					.call(brush);

				var resize = brushg.selectAll(".resize");
				var handle = resize.selectAll(".handle").data(function(d) { return d; });
				handle.enter()
					.append("rect")
						.classed("handle", true);
				handle
					.attr("transform", "translate(" + -(handleWidth/2) +  "," + -handleWidth + ")")
					.attr("rx", handleWidth/3)
					.attr("ry", handleWidth/3)
					.attr("width", handleWidth)
					.attr("height", handleHeight);
			}
		};

		choropleth.drawTooltip = function(data) {
			var self = this,
				dataUndefined = data == null || data.value == null;

			tooltip = $wrapper.selectAll(".tooltip").data(dataUndefined ? [] : [data]);
			tooltip.enter()
				.append("div")
					.classed("tooltip", true);
			tooltip.exit()
				.classed("visible", false);
			setTimeout(function() {
				tooltip
					.classed("visible", true);
			}, 10);

			var tooltipBack = tooltip.selectAll(".tooltip-back").data([data]);
			tooltipBack.enter()
				.append("div")
					.classed("tooltip-back", true);

			var ttName = tooltipBack.selectAll(".tt-name").data(function(d) { return [d.name]; });
			ttName.enter()
				.append("p")
					.classed("tt-name", true);
			ttName
				.text(function(d) { return d; });

			var ttValue = tooltipBack.selectAll(".tt-value").data(function(d) { return [d.value]; });
			ttValue.enter()
				.append("p")
					.classed("tt-value", true);
			ttValue
				.text(function(d) { return options.formatFunction(d); });

			var ttMetric = tooltipBack.selectAll(".tt-metric").data(typeof options.metric !== "undefined" ? [options.metric] : []);
			ttMetric.enter()
				.append("p")
					.classed("tt-metric", true);
			ttMetric.text(function(d) { return d; });
			ttMetric.exit().remove();
		};

		choropleth.hideTooltip = function() {
			choropleth.drawTooltip({});
		};

		choropleth.showTooltip = function(data) {
			if('value' in data && data.value) {
				choropleth.drawTooltip(data);
			} else {
				choropleth.hideTooltip();
			}
		};

		choropleth.drawGeos = function(geoJsonData) {
			var color = null,
				interpretedDomain,
				xStart,
				yStart,
				currentScale = 1,
				minDimScale = Math.min(size[0], size[1]),
				width = size[0] - padding.left - padding.right,
				height = size[1] - padding.top - padding.bottom,
				scale = 1,
				offset = [0, 0];

			if (options.projection) {
				projection = d3.geo[options.projection]();
			} else {
				projection = d3.geo.equirectangular();
			}

			projection.scale(scale).translate(offset);

			// create the path
			var path = d3.geo.path().projection(projection);

			// using the path, determine the bounds of the current map and use this information to determine better values
			// for the scale and translation.
			var bounds = path.bounds(geoJsonData);
			scale = 0.95 / Math.max((bounds[1][0] - bounds[0][0]) / width, (bounds[1][1] - bounds[0][1]) / height);
			offset = [(width - scale * (bounds[1][0] + bounds[0][0])) / 2, (height - scale * (bounds[1][1] + bounds[0][1])) / 2];

			var bboxHeight = (scale * ((bounds[1][1] - bounds[0][1]) / height)) * height,
				bboxWidth = (scale * ((bounds[1][0] - bounds[0][0]) / width)) * width;

			// new projection
			projection.scale(scale).translate(offset);
			path = path.projection(projection);

			if (options.interactive) {
				var zoom = d3.behavior.zoom(),
					zoomMax = 4;
				zoomContainer.call(zoom
					.scaleExtent([1, zoomMax])
					.translate([width/2, height/2])
					.scale(1)
					.on("zoom", function(){
						if(d3.event) {
							var t = d3.event.translate,
								s = d3.event.scale,
								widthScaled2 = width / 2 * s,
								heightScaled2 = height / 2 * s,
								newX = t[0] - widthScaled2,
								newY = t[1] - heightScaled2,
								visibleChartWidth = bboxWidth / 6,
								visibleChartHeight = bboxHeight / 6,

								minX = -widthScaled2 - visibleChartWidth,
								maxX = width - widthScaled2 + visibleChartWidth,
								minY = -heightScaled2 - visibleChartHeight,
								maxY = height - heightScaled2 + visibleChartHeight;

							newX = Math.min(newX, maxX);
							newX = Math.max(newX, minX);
							newY = Math.min(newY, maxY);
							newY = Math.max(newY, minY);

							// Update the translation
							t[0] = newX + widthScaled2;
							t[1] = newY + heightScaled2;

							zoom.translate(t);
							$container.attr("transform", "translate(" + newX + "," + newY + ") scale(" + s + ")");
						}
					})
				);
			}

			extentMin = ((max - min) * extent[0]) + min;
			extentMax = ((max - min) * extent[1]) + min;
			interpretedDomain = [extentMin, ((extentMax - extentMin)/3) + extentMin, (((extentMax - extentMin)/3)*2) + extentMin, extentMax];
			$p.selectAll('.legend-label.min').text(function(d, i) { return options.formatFunction(extentMin); });
			$p.selectAll('.legend-label.max').text(function(d, i) { return options.formatFunction(extentMax); });
			if(options.theme == 'salmonRun') {
				color = d3.scale.linear().domain(interpretedDomain).range(salmonRun);
			} else if(options.theme == 'blueOcean') {
				color = d3.scale.linear().domain(interpretedDomain).range(blueOcean);
			} else {
				color = d3.scale.linear().domain(interpretedDomain).range(sunnyDay);
			}

			var getColor = function(d) {
				if(
					typeof(data.values[d.properties.GEO_ID]) == 'undefined' ||
					data.values[d.properties.GEO_ID] < extentMin ||
					data.values[d.properties.GEO_ID] > extentMax
				) {
					return '#ddd';
				} else {
					return color(data.values[d.properties.GEO_ID]);
				}
			};

			var geoMouseOver = function(d, i) {
				if(brushing) {
					return;
				}
				var id = d.properties.GEO_ID,
					d3Elem = svg.selectAll("#" + id),
					elem = d3Elem.node();
				elem.parentNode.appendChild(elem);

				d3Elem
					.classed("selected", true);

				choropleth.showTooltip({
					name: d.properties.name,
					id: d.properties.GEO_ID,
					value: data.values[d.properties.GEO_ID]
				});
			};

			var geoMouseOut = function(d, i) {
				if(brushing) {
					return;
				}
				var id = d.properties.GEO_ID,
					d3Elem = svg.selectAll("#" + id),
					elem = d3Elem.node(),
					parentElem = elem.parentNode;
				d3Elem.classed("selected", false);
				choropleth.hideTooltip();
			};

			var geos = $container.selectAll(".geo").data(geoJsonData.features, function(d) { return d.properties.GEO_ID; });
			geos.enter()
				.append('path')
					.classed("geo", true)
					.attr('id', function(d, i) { return d.properties.GEO_ID; })
					.attr('vector-effect', 'non-scaling-stroke')
					.on("mouseover.choro", options.interactive ? geoMouseOver : null)
					.on("mouseout.choro", options.interactive ? geoMouseOut : null);
			geos.exit()
				.on("mouseover.choro", null)
				.on("mouseout.choro", null);
			geos
				.attr('d', path)
				.style('fill', getColor);
		};

		choropleth.createSVGContainer = function() {
			$p = d3.select(p);

			$wrapper = $p.selectAll(".cv-choropleth").data([data]);
			$wrapper.enter().append("div").classed("cv-choropleth", true);
			$wrapper.style("width", size[0] + "px")
				.style("height", size[1] + "px");

			svg = $wrapper.selectAll("svg").data([data]);
			svg.enter().append("svg")
				.attr("width", "100%")
				.attr("height", "100%");
			svg.exit().remove();

			var clipPath = svg.selectAll("#plotClip").data([0]);
			clipPath.enter()
				.append("clipPath")
					.attr("id", "plotClip")
						.append("rect");
			clipPath.select("rect")
				.attr("x", padding.left)
				.attr("y", padding.top)
				.attr("width", size[0] - padding.left - padding.right)
				.attr("height", size[1] - padding.top - padding.bottom);

			var zoomContainerBg = svg.selectAll(".container-bg").data([data]);
			zoomContainerBg.enter()
				.append("rect")
					.classed("container-bg", true)
					.attr("width", "100%")
					.attr("height", "100%");

			zoomContainer = svg.selectAll(".zoom-container").data([data]);
			zoomContainer.enter()
				.append("g")
					.classed("zoom-container", true)
					.attr("clip-path", "url(#plotClip)");

			var zoomContainerPlotBg = zoomContainer.selectAll(".zoom-container-plot-bg").data([data]);
			zoomContainerPlotBg.enter()
				.append("rect")
					.classed("zoom-container-plot-bg", true);
			zoomContainerPlotBg
				.attr("x", padding.left)
				.attr("y", padding.top)
				.attr("width", size[0] - padding.left - padding.right)
				.attr("height", size[1] - padding.top - padding.bottom);

			var container = zoomContainer.selectAll(".choro-container").data([data]);
			container.enter()
				.append("g")
					.classed("choro-container", true);

			return container;
		};

		choropleth.data = function(_) {
			if (!arguments.length) { return data; }
			data = _;
			return choropleth;
		};

		choropleth.parent = function(_) {
			if (!arguments.length) { return p; }
			p = _;
			return choropleth;
		};

		choropleth.options = function(_) {
			if (!arguments.length) { return options; }
			options = _;
			return choropleth;
		};

		function EmptyDataException() {
			this.type = "EmptyDataException";
			this.message = "The data is empty or null";
			this.toString = function() { return this.type + " - " + this.message; };
		}

		function ParentNotSpecifiedException() {
			this.type = "ParentNotSpecifiedException";
			this.message = "A parent was not specified for this visualization";
			this.toString = function() { return this.type + " - " + this.message; };
		}

		return choropleth;
	};

	d3.choropleth.gradIdCounter = 0; // This needs to be static so instances will share
}(this));

/**
 * Choropleth Generation
 *
 * A choropleth map is a thematic map in which areas are shaded or patterned
 * in proportion to the measurement of the statistical variable being
 * displayed on the map, such as population density or per-capita income.
 */
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {},
		core = cloudViz.core || {},
		dv = global.dv || {},
		d3 = global.d3 || {},
		choropleth = Object.create(core);

	choropleth.init = function(options) {
		this._type = 'choropleth';
		options = options || {};
		this._initDefaultOptions();
		this.setOptions(options);
		this._initChoropleth();
		return this;
	};

	choropleth._initDefaultOptions = function(options) {
		var defaults = {
			/**
			 * JSON Path data for map.
			 */
			geoJson: null,
			/**
			 * 'sunnyDay' for green scheme, 'salmonRun' for red scheme
			 */
			theme: 'sunnyDay',
			/**
			 * Metric name, shown in tooltip.
			 */
			metric: "",
			/**
			 * The type of projection being used.
			 */
			projection: "equirectangular",
			/**
			 * The numeric format that should be used on any number.  Options are decimal (default), percent, currency.
			 * @type {String}
			 */
			format: "decimal",
			/**
			 * If true, adds an interactive dual thumb slider to the legend for filtering and shows a tooltip when polygons
			 * are moused-over. If false, none of these behaviors are included.
			 */
			interactive: true
		};

		return Object.getPrototypeOf(choropleth)._initDefaultOptions.call(this, defaults);
	};

	choropleth._render = function() {
		this._configure();
		this._choro.layout();
	};

	choropleth._initChoropleth = function() {
		this._choro = d3.choropleth();
	};

	choropleth._configure = function() {
		var self = this,
			opts = this._options,
			adapter = this._dataAdapter;
		opts.formatFunction = function(val) { return self._formatNumber(opts.format, val); };
		opts.metric = adapter.metric();
		opts.format = adapter.format();
		opts.data = adapter.data();
		this._choro
			.data(this._options.data)
			.parent(this._options.parent)
			.options(this._options)
		;
	};

	global.cloudViz.choropleth = cloudViz.util.createConstructor(choropleth);
}(this));

// Taken from https://github.com/benfred/venn.js
(function(venn) {
    "use strict";
    /** given a list of set objects, and their corresponding overlaps.
    updates the (x, y, radius) attribute on each set such that their positions
    roughly correspond to the desired overlaps */
    venn.venn = function(sets, overlaps, parameters) {
        parameters = parameters || {};
        parameters.distance = parameters.distance || 0;
        parameters.maxIterations = parameters.maxIterations || 500;
        var lossFunction = parameters.lossFunction || venn.lossFunction;
        var initialLayout = parameters.layoutFunction || venn.greedyLayout;

        // initial layout is done greedily
        sets = initialLayout(sets, overlaps, parameters.distance);

        // transform x/y coordinates to a vector to optimize
        var initial = new Array(2*sets.length);
        for (var i = 0; i < sets.length; ++i) {
            initial[2 * i] = sets[i].x;
            initial[2 * i + 1] = sets[i].y;
        }

        // optimize initial layout from our loss function
        var totalFunctionCalls = 0;
        var solution = venn.fmin(
            function(values) {
                totalFunctionCalls += 1;
                var current = new Array(sets.length);
                for (var i = 0; i < sets.length; ++i) {
                    current[i] = {x: values[2 * i],
                                  y: values[2 * i + 1],
                                  radius : sets[i].radius,
                                  size : sets[i].size};
                }
                return lossFunction(current, overlaps);
            },
            initial,
            parameters);

        // transform solution vector back to x/y points
        var positions = solution.solution;
        for (i = 0; i < sets.length; ++i) {
            sets[i].x = positions[2 * i];
            sets[i].y = positions[2 * i + 1];
        }

        return sets;
    };

    /** Returns the distance necessary for two circles of radius r1 + r2 to
    have the overlap area 'overlap' */
    venn.distanceFromIntersectArea = function(r1, r2, overlap) {
        // handle complete overlapped circles
        if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI < overlap) {
            return Math.abs(r1 - r2);
        }

        return venn.bisect(function(distance) {
            return window.circleIntersection.circleOverlap(r1, r2, distance) - overlap;
        }, 0, r1 + r2);
    };

    /// gets a matrix of euclidean distances between all sets in venn diagram
    venn.getDistanceMatrix = function(sets, overlaps, dist) {
        // initialize an empty distance matrix between all the points
        var distances = [],
            i;
        for (i = 0; i < sets.length; ++i) {
            distances.push([]);
            for (var j = 0; j < sets.length; ++j) {
                distances[i].push(0);
            }
        }

        // compute distances between all the points
        for (i = 0; i < overlaps.length; ++i) {
            var current = overlaps[i];
            if (current.sets.length !== 2) {
                continue;
            }

            var left = current.sets[0],
                right = current.sets[1],
                r1 = Math.sqrt(sets[left].size / Math.PI),
                r2 = Math.sqrt(sets[right].size / Math.PI),
                distance = venn.distanceFromIntersectArea(r1, r2, current.size) + dist;
            distances[left][right] = distances[right][left] = distance;
        }
        return distances;
    };

    /** Lays out a venn diagram greedily, going from most overlapped sets to
    least overlapped, attempting to position each new set such that the
    overlapping areas to already positioned sets are basically right */
    venn.greedyLayout = function(sets, overlaps, distance) {
        // give each set a default position + radius
        var setOverlaps = {},
            set,
            i,
            j;
        for (i = 0; i < sets.length; ++i) {
            setOverlaps[i] = [];
            sets[i].radius = Math.sqrt(sets[i].size / Math.PI);
            sets[i].x = sets[i].y = 0;
        }

        // map each set to a list of all the other sets that overlap it
        for (i = 0; i < overlaps.length; ++i) {
            var current = overlaps[i];
            if (current.sets.length !== 2) {
                continue;
            }

            var left = current.sets[0], right = current.sets[1];

            if (!setOverlaps[left] || !setOverlaps[right]) {
                continue;
            }

            setOverlaps[left].push ({set:right, size:current.size});
            setOverlaps[right].push({set:left,  size:current.size});
        }

        // get list of most overlapped sets
        var mostOverlapped = [];
        for (set in setOverlaps) {
            if (setOverlaps.hasOwnProperty(set)) {
                var size = 0;
                for (i = 0; i < setOverlaps[set].length; ++i) {
                    size += setOverlaps[set][i].size;
                }

                mostOverlapped.push({set: set, size:size});
            }
        }

        // We don't have any overlaps, return.
        if (!mostOverlapped.length) {
            return sets;
        }

        // sort by size desc
        function sortOrder(a,b) {
            return b.size - a.size;
        }
        mostOverlapped.sort(sortOrder);

        // keep track of what sets have been laid out
        var positioned = {};
        function isPositioned(element) {
            return element.set in positioned;
        }

        // adds a point to the output
        function positionSet(point, index) {
            sets[index].x = point.x;
            sets[index].y = point.y;
            positioned[index] = true;
        }

        // add most overlapped set at (0,0)
        positionSet({x: 0, y: 0}, mostOverlapped[0].set);

        // get distances between all points
        var distances = venn.getDistanceMatrix(sets, overlaps, distance);

        for (i = 1; i < mostOverlapped.length; ++i) {
            var setIndex = mostOverlapped[i].set,
                overlap = setOverlaps[setIndex].filter(isPositioned);
            set = sets[setIndex];
            overlap.sort(sortOrder);

            if (overlap.length === 0) {
                throw "Need overlap information for set " + set;
            }

            var points = [];
            for (j = 0; j < overlap.length; ++j) {
                // get appropiate distance from most overlapped already added set
                var p1 = sets[overlap[j].set],
                    d1 = distances[setIndex][overlap[j].set];

                // sample postions at 90 degrees for maximum aesheticness
                points.push({x : p1.x + d1, y : p1.y});
                points.push({x : p1.x - d1, y : p1.y});
                points.push({y : p1.y + d1, x : p1.x});
                points.push({y : p1.y - d1, x : p1.x});

                // if we have at least 2 overlaps, then figure out where the
                // set should be positioned analytically and try those too
                for (var k = j + 1; k < overlap.length; ++k) {
                    var p2 = sets[overlap[k].set],
                        d2 = distances[setIndex][overlap[k].set];

                    var extraPoints = window.circleIntersection.circleCircleIntersection(
                        { x: p1.x, y: p1.y, radius: d1},
                        { x: p2.x, y: p2.y, radius: d2});

                    for (var l = 0; l < extraPoints.length; ++l) {
                        points.push(extraPoints[l]);
                    }
                }
            }

            // we have some candidate positions for the set, examine loss
            // at each position to figure out where to put it at
            var bestLoss = 1e50, bestPoint = points[0];
            for (j = 0; j < points.length; ++j) {
                sets[setIndex].x = points[j].x;
                sets[setIndex].y = points[j].y;
                var loss = venn.lossFunction(sets, overlaps);
                if (loss < bestLoss) {
                    bestLoss = loss;
                    bestPoint = points[j];
                }
            }

            positionSet(bestPoint, setIndex);
        }

        return sets;
    };

    /// Uses multidimensional scaling to approximate a first layout here
    venn.classicMDSLayout = function(sets, overlaps) {
        // get the distance matix
        var distances = venn.getDistanceMatrix(sets, overlaps, 0);

        // get positions for each set
        var positions = window.mds.classic(distances);

        // translate back to (x,y,radius) coordinates
        for (var i = 0; i < sets.length; ++i) {
            sets[i].x = positions[i][0];
            sets[i].y = positions[i][1];
            sets[i].radius = Math.sqrt(sets[i].size / Math.PI);
        }
        return sets;
    };

    /** Given a bunch of sets, and the desired overlaps between these sets - computes
    the distance from the actual overlaps to the desired overlaps. Note that
    this method ignores overlaps of more than 2 circles */
    venn.lossFunction = function(sets, overlaps) {
        var output = 0;

        function getCircles(indices) {
            return indices.map(function(i) { return sets[i]; });
        }

        for (var i = 0; i < overlaps.length; ++i) {
            var area = overlaps[i], overlap;
            if (area.sets.length == 2) {
                var left = sets[area.sets[0]],
                    right = sets[area.sets[1]];
                if (left == null || right == null) {
                    overlap = 0;
                }
                else {
                    overlap = window.circleIntersection.circleOverlap(left.radius, right.radius,
                                    window.circleIntersection.distance(left, right));
                }
            } else {
                overlap = window.circleIntersection.intersectionArea(getCircles(area.sets));
            }

            var weight = (area.weight == null) ? 1 : area.weight;
            output += weight * (overlap - area.size) * (overlap - area.size);
        }

        return output;
    };

    /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
    a rectangle of width/height - with padding around the borders. */
    venn.scaleSolution = function(solution, width, height, padding) {
        var minMax = function(d) {
            var hi = Math.max.apply(null, solution.map(
                                    function(c) { return c[d] + c.radius; } )),
                lo = Math.min.apply(null, solution.map(
                                    function(c) { return c[d] - c.radius;} ));
            return {max:hi, min:lo};
        };

        width -= 2*padding;
        height -= 2*padding;

        var xRange = minMax('x'),
            yRange = minMax('y'),
            xExtent = (xRange.max - xRange.min),
            yExtent = (yRange.max - yRange.min),
            xScaling = xExtent ? width  / xExtent : 0,
            yScaling = yExtent ? height / yExtent : 0,
            scaling = Math.min(yScaling, xScaling);

        for (var i = 0; i < solution.length; ++i) {
            var set = solution[i];
            set.radius = scaling * set.radius;
            set.x = padding + (set.x - xRange.min) * scaling;
            set.y = padding + (set.y - yRange.min) * scaling;
        }
        solution.scaling = scaling;

        return solution;
    };

    function weightedSum(a, b) {
        var ret = new Array(a[1].length || 0);
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = a[0] * a[1][j] + b[0] * b[1][j];
        }
        return ret;
    }

    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    venn.bisect = function(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "initial bisect points must have opposite signs";
        }

        if (fA === 0) { return a; }
        if (fB === 0) { return b; }

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    };

    /** minimizes a function using the downhill simplex method */
    venn.fmin = function(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.1,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-5,
            rho = parameters.rho || 1,
            chi = parameters.chi || 2,
            psi = parameters.psi || -0.5,
            sigma = parameters.sigma || 0.5,
            callback = parameters.callback;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);
            if (callback) {
                callback(simplex);
            }

            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            var centroid = new Array(N);
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            var reflected = weightedSum([1+rho, centroid], [-rho, worst]);
            reflected.fx = f(reflected);

            var replacement = reflected;

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx <= simplex[0].fx) {
                var expanded = weightedSum([1+chi, centroid], [-chi, worst]);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    replacement = expanded;
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;
                var contracted;

                if (reflected.fx <= worst.fx) {
                    // do an inside contraction
                    contracted = weightedSum([1+psi, centroid], [-psi, worst]);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        replacement = contracted;
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    contracted = weightedSum([1-psi * rho, centroid], [psi*rho, worst]);
                    contracted.fx = f(contracted);
                    if (contracted.fx <= reflected.fx) {
                        replacement = contracted;
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // do reduction. doesn't actually happen that often
                    for (i = 1; i < simplex.length; ++i) {
                        simplex[i] = weightedSum([1 - sigma, simplex[0]],
                                                 [sigma - 1, simplex[i]]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            }

            simplex[N] = replacement;
        }

        simplex.sort(sortOrder);
        return {f : simplex[0].fx,
                solution : simplex[0]};
    };

    venn.drawD3Diagram = function(element, dataset, width, height, parameters) {
        parameters = parameters || {};

        var colours = d3.scale.category10(),
            circleFillColours = parameters.circleFillColours || colours,
            circleStrokeColours = parameters.circleStrokeColours || circleFillColours,
            circleStrokeWidth = parameters.circleStrokeWidth || function(i) { return 0; },
            textFillColours = parameters.textFillColours || colours,
            textStrokeColours = parameters.textStrokeColours || textFillColours,
            nodeOpacity = parameters.opacity || 0.3,
            padding = parameters.padding || 6;

        dataset = venn.scaleSolution(dataset, width, height, padding);
        var svg = element.append("svg")
                .attr("width", width)
                .attr("height", height);

        var nodes = svg.selectAll("circle")
                         .data(dataset)
                         .enter()
                         .append("g");

        var circles = nodes.append("circle")
               .attr("r",  function(d) { return d.radius; })
               .style("fill-opacity", nodeOpacity)
               .attr("cx", function(d) { return d.x; })
               .attr("cy", function(d) { return d.y; })
               .style("stroke", function(d, i) { return circleStrokeColours(i); })
               .style("stroke-width", function(d, i) { return circleStrokeWidth(i); })
               .style("fill", function(d, i) { return circleFillColours(i); });

        var text = nodes.append("text")
               .attr("x", function(d) { return d.x; })
               .attr("y", function(d) { return d.y; })
               .attr("text-anchor", "middle")
               .style("stroke", function(d, i) { return textStrokeColours(i); })
               .style("fill", function(d, i) { return textFillColours(i); })
               .text(function(d) { return d.label; });

        return {'svg' : svg,
                'nodes' : nodes,
                'circles' : circles,
                'text' : text };
    };

    venn.updateD3Diagram = function(element, dataset) {
        var svg = element.select("svg"),
            width = parseInt(svg.attr('width'), 10),
            height = parseInt(svg.attr('height'), 10);

        dataset = venn.scaleSolution(dataset, width, height, 6);
        element.selectAll("circle")
            .data(dataset)
            .transition()
            .duration(400)
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("r",  function(d) { return d.radius; });

        element.selectAll("text")
            .data(dataset)
            .transition()
            .duration(400)
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; });
    };
}(window.venn = window.venn || {}));
(function(circleIntersection) {
    "use strict";
    var SMALL = 1e-10;

    /** Returns the intersection area of a bunch of circles (where each circle
     is an object having an x,y and radius property) */
    circleIntersection.intersectionArea = function(circles, stats) {
        // get all the intersection points of the circles
        var intersectionPoints = getIntersectionPoints(circles);

        // filter out points that aren't included in all the circles
        var innerPoints = intersectionPoints.filter(function (p) {
            return circleIntersection.containedInCircles(p, circles);
        });

        var arcArea = 0, polygonArea = 0, arcs = [], i;

        // if we have intersection points that are within all the circles,
        // then figure out the area contained by them
        if (innerPoints.length > 1) {
            // sort the points by angle from the center of the polygon, which lets
            // us just iterate over points to get the edges
            var center = circleIntersection.getCenter(innerPoints);
            for (i = 0; i < innerPoints.length; ++i ) {
                var p = innerPoints[i];
                p.angle = Math.atan2(p.x - center.x, p.y - center.y);
            }
            innerPoints.sort(function(a,b) { return b.angle - a.angle;});

            // iterate over all points, get arc between the points
            // and update the areas
            var p2 = innerPoints[innerPoints.length - 1];
            for (i = 0; i < innerPoints.length; ++i) {
                var p1 = innerPoints[i];

                // polygon area updates easily ...
                polygonArea += (p2.x + p1.x) * (p1.y - p2.y);

                // updating the arc area is a little more involved
                var midPoint = {x : (p1.x + p2.x) / 2,
                                y : (p1.y + p2.y) / 2},
                    arc = null;

                for (var j = 0; j < p1.parentIndex.length; ++j) {
                    if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
                        // figure out the angle halfway between the two points
                        // on the current circle
                        var circle = circles[p1.parentIndex[j]],
                            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
                            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);

                        var angleDiff = (a2 - a1);
                        if (angleDiff < 0) {
                            angleDiff += 2*Math.PI;
                        }

                        // and use that angle to figure out the width of the
                        // arc
                        var a = a2 - angleDiff/2,
                            width = circleIntersection.distance(midPoint, {
                                x : circle.x + circle.radius * Math.sin(a),
                                y : circle.y + circle.radius * Math.cos(a)
                            });

                        // pick the circle whose arc has the smallest width
                        if ((arc === null) || (arc.width > width)) {
                            arc = { circle : circle,
                                    width : width,
                                    p1 : p1,
                                    p2 : p2};
                        }
                    }
                }
                arcs.push(arc);
                arcArea += circleIntersection.circleArea(arc.circle.radius, arc.width);
                p2 = p1;
            }
        } else {
            // no intersection points, is either disjoint - or is completely
            // overlapped. figure out which by examining the smallest circle
            var smallest = circles[0];
            for (i = 1; i < circles.length; ++i) {
                if (circles[i].radius < smallest.radius) {
                    smallest = circles[i];
                }
            }

            // make sure the smallest circle is completely contained in all
            // the other circles
            var disjoint = false;
            for (i = 0; i < circles.length; ++i) {
                if (circleIntersection.distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
                    disjoint = true;
                    break;
                }
            }

            if (disjoint) {
                arcArea = polygonArea = 0;

            } else {
                arcArea = smallest.radius * smallest.radius * Math.PI;
                arcs.push({circle : smallest,
                           p1: { x: smallest.x,        y : smallest.y + smallest.radius},
                           p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},
                           width : smallest.radius * 2 });
            }
        }

        polygonArea /= 2;
        if (stats) {
            stats.area = arcArea + polygonArea;
            stats.arcArea = arcArea;
            stats.polygonArea = polygonArea;
            stats.arcs = arcs;
            stats.innerPoints = innerPoints;
            stats.intersectionPoints = intersectionPoints;
        }

        return arcArea + polygonArea;
    };

    /** returns whether a point is contained by all of a list of circles */
    circleIntersection.containedInCircles = function(point, circles) {
        for (var i = 0; i < circles.length; ++i) {
            if (circleIntersection.distance(point, circles[i]) > circles[i].radius + SMALL) {
                return false;
            }
        }
        return true;
    };

    /** Gets all intersection points between a bunch of circles */
    function getIntersectionPoints(circles) {
        var ret = [];
        for (var i = 0; i < circles.length; ++i) {
            for (var j = i + 1; j < circles.length; ++j) {
                var intersect = circleIntersection.circleCircleIntersection(circles[i],
                                                              circles[j]);
                for (var k = 0; k < intersect.length; ++k) {
                    var p = intersect[k];
                    p.parentIndex = [i,j];
                    ret.push(p);
                }
            }
        }
        return ret;
    }

    circleIntersection.circleIntegral = function(r, x) {
        var y = Math.sqrt(r * r - x * x);
        return x * y + r * r * Math.atan2(x, y);
    };

    /** Returns the area of a circle of radius r - up to width */
    circleIntersection.circleArea = function(r, width) {
        return circleIntersection.circleIntegral(r, width - r) - circleIntersection.circleIntegral(r, -r);
    };


    /** euclidean distance between two points */
    circleIntersection.distance = function(p1, p2) {
        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +
                         (p1.y - p2.y) * (p1.y - p2.y));
    };


    /** Returns the overlap area of two circles of radius r1 and r2 - that
    have their centers separated by distance d. Simpler faster
    circle intersection for only two circles */
    circleIntersection.circleOverlap = function(r1, r2, d) {
        // no overlap
        if (d >= r1 + r2) {
            return 0;
        }

        // completly overlapped
        if (d <= Math.abs(r1 - r2)) {
            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
        }

        var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
            w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
        return circleIntersection.circleArea(r1, w1) + circleIntersection.circleArea(r2, w2);
    };


    /** Given two circles (containing a x/y/radius attributes),
    returns the intersecting points if possible.
    note: doesn't handle cases where there are infinitely many
    intersection poiints (circles are equivalent):, or only one intersection point*/
    circleIntersection.circleCircleIntersection = function(p1, p2) {
        var d = circleIntersection.distance(p1, p2),
            r1 = p1.radius,
            r2 = p2.radius;

        // if to far away, or self contained - can't be done
        if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {
            return [];
        }

        var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
            h = Math.sqrt(r1 * r1 - a * a),
            x0 = p1.x + a * (p2.x - p1.x) / d,
            y0 = p1.y + a * (p2.y - p1.y) / d,
            rx = -(p2.y - p1.y) * (h / d),
            ry = -(p2.x - p1.x) * (h / d);

        return [{ x: x0 + rx, y : y0 - ry },
                { x: x0 - rx, y : y0 + ry }];
    };

    /** Returns the center of a bunch of points */
    circleIntersection.getCenter = function(points) {
        var center = { x: 0, y: 0};
        for (var i =0; i < points.length; ++i ) {
            center.x += points[i].x;
            center.y += points[i].y;
        }
        center.x /= points.length;
        center.y /= points.length;
        return center;
    };
}(window.circleIntersection = window.circleIntersection || {}));

/**
 * Venn Diagram
 *
 *
 */
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {},
		core = cloudViz.core || {},
		dv = global.dv || {},
		d3 = global.d3 || {},
		venn = Object.create(core);

	/**
	 * Called when cloudViz.venn is instantiated.
	 * @param  Object<optionName, optionValue> options Options specified by the user which should be merged into our default options.
	 */
	venn.init = function(options) {
		var self = this;

		this._type = 'venn';
		options = options || {};
		this._initDefaultOptions();
		this.setOptions(options);
		this._cvWrapper = null;

		// Initialize the seriesState object which keeps track of which items are enabled or not.
		this._seriesState = cloudViz.seriesState();
		this._seriesState.on('enableChange.venn', function(eventType, state) {
			// When a set has it's enabled/disabled flag toggled, call this function.
			self._onEnableState(state);
		});

		this._dvColorScale = dv.scale.ordinal();

		return this;
	};

	/**
	 * Initializes the default options that can be used for this chart. We also merge the user specified options over the top of the
	 * defaults object.  User-defined options always override defaults. The final merged options object is returned.
	 * @param  Object<optionName, optionValue> options Options specified by the user which should be merged into our default options.
	 * @return Object<optionName, optionValue> newly merged options Object which now has defaults included.
	 */
	venn._initDefaultOptions = function(options) {
		var defaults = {
			colors : [ // colors to use when displaying charts
				'#8cc350', // green
				'#d755a5', // fuchsia
				'#1ebed7', // cyan
				'#f0a01e', // tangerine
				'#9b8ce6', // periwinkle
				'#3cb5a0', // sea foam
				'#3287d2', // blue
				'#f0557d', // magenta
				'#c3d250', // chartreuse
				'#eb782d', // orange
				'#78b4f5', // sky blue
				'#5faf69', // kelly green
				'#aa5fa5', // plum
				'#fa5a50', // red
				'#f5c841', // yellow
				'#5a6eaa' // iris
			],
			legendVerticalWidth: 110, // The width the legend will take up when in interactive vertical layout.
			duration: 500, // The amount of time each animation will take. If duration is zero, the chart will not be animated (but still drawn on the next render frame).
			distance: 0
		};

		this._margins = { top: 0, left: 0, right: 0, bottom: 0 };

		return Object.getPrototypeOf(venn)._initDefaultOptions.call(this, defaults);
	};

	/**
	 * Called by core's internal render, this function represents the render loop for drawing this diagram.
	 */
	venn._render = function() {
		this._id = Math.floor(Math.random() * 10000); // pseudo random number to have unique clippath ids
		this._determineSize();
		this._initScales();
		this._draw();
	};

	/**
	 * The main drawing loop for the Venn Diagram.
	 */
	venn._draw = function() {
		var data = this._options.data;
		data.distance = this._options.distance;
		this._initSVG();
		this._createStates();
		this._parsedSetNotation = this._parseSetNotation(data.notation);
		this._overlapMap = this._createOverlapMap(data.sets, data.overlaps);
		var legendDimensions = this._drawLegend();
		this._positionContainer(legendDimensions);
		var sets = this._configureSets(data);
		var overlayCombos = this._generateOverlayCombinations(sets, this._parsedSetNotation);
		this._drawCircles(sets, overlayCombos);
	};

	/**
	 * Called when the chart is automatically resized. This will only fire if the autoResize option is true and the browser
	 * window size changes.
	 */
	venn._onAutoResize = function() {
		this.render();
	};

	/**
	 * Calculate the overall size based on width/height options or the size of the parent if no size options were specified.
	 */
	venn._determineSize = function(options) {
		var opts = this._options, data = this._dataAdapter.data(),
		parentWidth = opts.parent.offsetWidth,
		parentHeight = opts.parent.offsetHeight,
		width = dv.util.getPercentValue(opts.width, parentWidth)|| parentWidth, // Grab the parent's width if we don't have width set
		height = dv.util.getPercentValue(opts.height, parentHeight) || parentHeight; // Grab the parent's height if we don't have height set

		this._size = [width, height];
	};

	venn._initScales = function() {
		this._dvColorScale.range(this._options.colors);
	};

	/**
	 * Parses the notation string into an array of arrays.  Each subarray will represent an intersection of sets and each
	 * top level array represents a union. So a notation string of '1&2|3&4|0' will be converted to [[1, 2], [3, 4], [0]].
	 * @return json notation representation
	 */
	venn._parseSetNotation = function(notationString) {
		var jsonNotation = [];

		if (!notationString) {
			return jsonNotation;
		}

		var ors = notationString.split('|'),
			indexPattern = /\d+/g;

		var i,
			orLength = ors.length,
			or;
		for (i = 0; i < orLength; i++) {
			or = ors[i];
			var andMatches = or.match(indexPattern);
			var j,
				sets = [],
				andLength = andMatches.length,
				and;
			for (j = 0; j < andLength; j++) {
				sets.push(+andMatches[j]);
			}
			jsonNotation.push(sets);
		}
		return jsonNotation;
	};

	/**
	 * Build up the SVG containers which will hold the Venn Diagram.
	 */
	venn._initSVG = function() {
		var opts = this._options,
			d3Parent = d3.select(opts.parent);

		this._cvWrapper = d3Parent.selectAll('.cv-wrapper.cv-venn').data([0]);
		this._cvWrapper.enter()
			.append('div')
			.classed('cv-wrapper cv-venn', true);
		this._cvWrapper
			.style('width', this._size[0] + 'px')
			.style('height', this._size[1] + 'px');

		var chartContainer = this._cvWrapper.selectAll('.svg-wrapper').data([0]);
		chartContainer.enter()
			.append('div')
			.classed('svg-wrapper', true);

		var svg = chartContainer.selectAll('svg').data([0]);
		svg.enter()
			.append('svg');

		this._d3Container = svg.selectAll('g').data([0]);
		this._d3Container.enter()
			.append('g');
	};

	/**
	 * Now that we have rendered the legend and know it's dimensions, we can allocate the remaining space for the plot itself. This functions sizes the elements
	 * properly to allow for this.
	 * @param  {left:Number, top:Number, right:Number, bottom:Number} legendDimensions The amount of space taken up by legends
	 */
	venn._positionContainer = function(legendDimensions) {
		this._size[0] -= legendDimensions.left + legendDimensions.right;
		this._size[1] -= legendDimensions.top + legendDimensions.bottom;

		this._cvWrapper.select('.svg-wrapper')
			.style({
				'margin-left': legendDimensions.left + 'px',
				'margin-top': legendDimensions.top + 'px',
				'margin-right': legendDimensions.right + 'px',
				'margin-bottom': legendDimensions.bottom + 'px',
				'height': this._size[1] + 'px'
			});

		this._cvWrapper.selectAll('.cv-legend')
			.style('height', legendDimensions.left || legendDimensions.right ? this._size[1] - 1 + 'px' : null);
	};

	/**
	 * Converts the sets and overlaps datasets to a single dataset which shows where each set (circle) should be
	 * positioned and how large of a radius it should have.
	 * @param {Set[], Overlay[], Notation:String} data The original dataset
	 * @return sets An array of circle positions and sizes.
	 */
	venn._configureSets = function(data) {
		var opts = this._options;

		data = this._sanitizeOverlaps(data);
		// TODO: Should we only run venn.venn if we change our dataset?
		// TODO: Rename venn to be d3.venn.
		var circles = global.venn.scaleSolution(global.venn.venn(data.sets, data.overlaps, {distance:data.distance}), this._size[0], this._size[1], 7);

		var i, length = circles.length, circle;
		for (i = 0; i < length; i++) {
			circle = circles[i];
			circle.index = i;
		}
		return circles;
	};

	/**
	 * Generates all possible combintations of numbers given a set with a minimum number of items in the set.  An example of this would
	 * be the set [0, 1, 2] which would create sets: [0], [1], [2], [0, 1], [0, 2], [1, 2], [0, 1, 2].  This would happen if minLength
	 * was 1, if minLength was 2, we would receive sets: [0, 1], [0, 2], [1, 2], [0, 1, 2].  If minLength was 3, we would only receive
	 * [0, 1, 2].  If maxLength is specified, it caps the length of the items we can receive.  If minLength is 1 and maxLength is 2,
	 * given the set [0, 1, 2], we would receive sets [0], [1], [2], [0, 1], [0, 2], [1, 2].  Note that we wouldn't get [0, 1, 2]
	 * because it exceeds the specified length.
	 */
	venn._combine = function(sets, minLength, maxLength) {
		if (arguments.length < 3) {
			maxLength = sets.length - 1;
		} else {
			maxLength--;
		}
		if (arguments.length < 2) {
			minLength = 1;
		}

		var fn = function(n, src, got, all) {
			if (n === 0) {
				if (got.length > 0) {
					all[all.length] = got;
				}
				return;
			}
			for (var j = 0; j < src.length; j++) {
				fn(n - 1, src.slice(j + 1), got.concat([src[j]]), all);
			}
			return;
		};
		var all = [];
		for (var i = minLength; i <= maxLength + 1; i++) {
			fn(i, sets, [], all);
		}
		return all;
	};

	/**
	 * Find the commonalities between two sets.  For example, intersecting the sets: [0, 1, 2, 5] and [1, 3, 4, 5] would yield [1, 5]. Order
	 * is guaranteed to be the same as the two arrays.
	 * @param Array<Number> a An array of set indices
	 * @param Array<Number> b An array of set indices
	 * @return An unordered array with intersected set values
	 */
	venn._intersect = function(a, b) {
		var res = [];
		for (var i = 0; i < a.length; i++) {
			for (var j = 0; j < b.length; j++) {
				if (a[i] == b[j]) {
					res.push(a[i]);
					break;
				}
			}
		}
		return res;
	};

	/**
	 * Finds the unique values from each set.  For example, unioning the sets: [0, 1, 2, 5] and [1, 3, 4, 5] would yield [0, 1, 2, 3, 4, 5].
	 * Order is guaranteed to be the same as the input arrays.
	 * @param Array<Number> a An array of values
	 * @param Array<Number> b An array of values
	 * @return An unordered array with unioned set values
	 */
	venn._union = function(a, b) {
		var obj = {};

		for (var i = a.length - 1; i >= 0; --i) {
			obj[a[i]] = a[i];
		}
		for (var j = b.length - 1; j >= 0; --j) {
			obj[b[j]] = b[j];
		}
		var res = [];
		for (var k in obj) {
			if (obj.hasOwnProperty(k)) {
				res.push(obj[k]);
			}
		}
		res.sort(function(a, b) { return a - b; });
		return res;
	};

	/**
	 * Creates an overlayCombinations object which informs how the clips paths should be set up and created. We do this by taking each intersected group of sets
	 * defined by the data.notation string (which has been parsed into JSON -- parsedNotation param) and generate an array of intersected sets that make up these
	 * combinations.  We essentially take parsedNotation array such as:
	 *
	 * [[0, 1, 2], [3, 4]] // equivalent to data.notation string '0&1&2|3&4'
	 *
	 * and we convert it into all possible combinations of sets we can have:
	 *
	 * [
	 *   {key:'0', fill:false, area:Number},
	 *   {key:'1', fill:false, area:Number},
	 *   {key:'2', fill:false, area:Number},
	 *   {key:'0-1', fill:false, area:Number},
	 *   {key:'0-2', fill:false, area:Number},
	 *   {key:'1-2', fill:false, area:Number},
	 *   {key:'0-1-2', fill:true, area:Number},
	 *   {key:'3', fill:false, area:Number},
	 *   {key:'4', fill:false, area:Number},
	 *   {key:'3-4', fill:true, area:Number}
	 * ]
	 *
	 * We mark which sets should be filled in blue, and which sets should be invisible and exist only to create the clipPath combinations we need in order to
	 * properly clip our filled-in areas.
	 *
	 * The area parameter is the total area of the intersection.  It is based purely off how large the intersection would be when plotted. We use it to ensure
	 * the smaller areas are plotted on top of larger areas.  We don't want to have smaller fills behind larger fills.
	 *
	 * @param  {Array<Set>} sets Describes the position and size of each set that should be drawn.
	 * @param  {Array<Array<Number>>} parsedNotation An array of arrays containing set indices which should be intersected. The outer array is used to break up
	 * the sets which should be unioned (or'ed) which the inner area represents the sets which should be intersected (and'ed).
	 * @return {Array<ClipPath>} An array of object which are used to create the clipPaths which reveal the highlighted clip areas.
	 */
	venn._generateOverlayCombinations = function(sets, parsedNotation) {
		var self = this,
			comboMap = {},
			combinedPermutations = [],
			dataFills = [];

		// More specific notations first, follow by the most general
		parsedNotation.sort(function(a, b) {
			return b.length - a.length;
		});

		parsedNotation.forEach(function(and, i) {
			var joinedAnd = and.join('-'); // converts an anded set [0, 1, 2] into a key string '0-1-2'.
			combinedPermutations = combinedPermutations.concat(self._combine(and, 1));
			combinedPermutations.forEach(function(d, j) {
				var key = d.join('-'),
					obj = comboMap[key] || {},
					intersections;

				// If this has already been determined as being filled, don't change it.
				if (!obj.fill) {
					// Check this permutation against the permutation defined by the user. By intersecting both
					// sets, we can determine if the intersection matches the original permutation defined by
					// the user.  If this is true, we should color this area.
					intersections = self._intersect(and, d);
					obj.fill = intersections.join('-') === joinedAnd;
				}

				comboMap[key] = obj;
			});
		});

		// Change the map into an array
		for (var key in comboMap) {
			var setIndices = key.split('-'),
				setSubset = [],
				i,
				setLength = setIndices.length;
			for (i = 0; i < setLength; i++) {
				var set = sets[setIndices[i]];
				if (set) {
					setSubset.push(sets[setIndices[i]]);
				}
			}

			// Calculate the area of the set intersections.
			var intersectionData = {};

			if (setSubset.length > 1) {
				global.circleIntersection.intersectionArea(setSubset, intersectionData);
			}
			if (!setSubset.length) {
				intersectionData.area = 0;
			}
			else {
				intersectionData.area = Math.PI * Math.pow(setSubset[0].radius, 2);
			}

			dataFills.push({
				key: key,
				fill: comboMap[key].fill,
				area: intersectionData.area
			});
		}

		// Larger sized areas come first, then smaller sized areas.  We want our smaller clips to
		// display on top of larger areas so they aren't obscurred by them.
		dataFills.sort(function(a, b) {
			var diff = b.area - a.area;
			if (diff) {
				return diff;
			}

			// If they are the same area, check to see if their key length is the same.  If you have
			// two circles A and B, and B is a subset of A (B is contained wholly within A), and we
			// want the intersection A&B, the area of B and A&B will be identical, however, the key
			// of B will be "B" and the key of A&B will be "A-B".  Since "A-B" is more specific, we
			// want it last so it is always on top of "B".
			return a.key.length - b.key.length;
		});

		return dataFills;
	};

	/**
	 * Here we manually add overlaps of any 2-combination set that wasn't specified in data.overlaps.  These manually added 2-set combinations have a size zero overlap.
	 * This was made to satisfy the bug listed here:  https://github.com/benfred/venn.js/issues/11
	 * @param  {sets:Array[Set], overlaps:Array[Overlap], notation:String} data The data supplied to the Venn Diagram
	 * @return {sets:Array[Set], overlaps:Array[Overlap], notation:String} new data object with added overlaps.
	 */
	venn._sanitizeOverlaps = function(data) {
		// TODO: Need to make sure the data is valid before we get here.
		// TODO: We are only adding zeros to combinations of 2, maybe we should add them to combinations of n?
		var sets = data.sets,
			overlaps = data.overlaps,
			zeroOverlaps = [],
			setIndex,
			otherSetIndex,
			overlapIndex,
			set,
			otherSet,
			overlap,
			found,
			setLen = sets.length,
			overlapLen = overlaps.length,
			overlapMap = {},
			overlapSort = function(a, b) { return +a - +b; };

		// Build up an overlap map we can use for quick indexing.
		for (overlapIndex = 0; overlapIndex < overlapLen; overlapIndex++) {
			overlap = overlaps[overlapIndex];
			overlap.sets.sort(overlapSort); // Sort each set so lowest set index comes first.
			overlapMap[overlap.sets.join('-')] = overlap;
		}

		// Iterate through each set and check if there is an overlap for the other sets.
		for (setIndex = 0; setIndex < setLen; setIndex++) {
			set = sets[setIndex];
			// Compare this set against the remaining sets
			for (otherSetIndex = setIndex + 1; otherSetIndex < setLen; otherSetIndex++) {
				otherSet = sets[otherSetIndex];
				found = false;

				// Look through all the overlaps to see if we have an overlap that matches these two sets.
				if (!overlapMap.hasOwnProperty(setIndex + '-' + otherSetIndex) || overlapMap[setIndex + '-' + otherSetIndex].size === "0" ) {
					// We didn't find an overlap for these two sets, let's create one and zero out the size.
					zeroOverlaps.push({
						sets: [setIndex, otherSetIndex],
						size: 0
					});
				}
			}
		}

		// Add missing overlaps to our data
		data.overlaps = overlaps.concat(zeroOverlaps);
		return data;
	};

	/**
	 * Turns all the overlap data and sets into a Hash of the sizes of each area with a given key.
	 * @param {{sets:[Set], overlaps:[Overlap], notation:string}} data The raw data associated with this visualization
	 * @return {Object<setIndexKey, setSize>} A hash containing all the overlap information associated by key.
	 */
	venn._createOverlapMap = function(sets, overlaps) {
		var overlapMap = {},
			sort = function(a, b) { return a - b; };

		var i,
			setLength = sets.length,
			set;
		for (i = 0; i < setLength; i++) {
			set = sets[i];
			overlapMap[i] = set.size;
		}

		var j,
			overlapLength = overlaps.length,
			overlap;
		for (i = 0; i < overlapLength; i++) {
			overlap = overlaps[i];
			overlap.sets.sort(sort);
			overlapMap[overlap.sets.join('-')] = overlap.size;
		}

		return overlapMap;
	};

	/**
	 * The drawing routine for creating the circles and their filled areas.
	 * @param  {[type]} sets          [description]
	 * @param  {[type]} overlayCombos [description]
	 * @return {[type]}               [description]
	 */
	venn._drawCircles = function(sets, overlayCombos) {
		this._drawSetHitAreas(sets);
		this._createClipPaths(sets, overlayCombos);
		this._drawFilledRegions(overlayCombos);
		this._drawPadding(sets);
		this._drawSetFills(sets);
		this._drawBorders(sets);
		this._makePlotFit(sets);
	};

	/**
	 * Draws a circle for each set. The purposes of these circles is to create a hit area that will listen to mouse events. This hit area must be underneath
	 * the filled-in areas so we can mouse-over those filled-in areas too without them being covered by other set circles.
	 * corresponding legend entry.
	 * @param  {Array[Set]} sets Describes the position and size of each set that should be drawn.
	 */
	venn._drawSetHitAreas = function(sets) {
		var self = this,
			opts = this._options;

		var nodes = this._d3Container.selectAll('.set-hit-areas-container').data([sets]);
		nodes.enter().append('g').classed('set-hit-areas-container', true);
		nodes.exit().remove();

		var circles = nodes.selectAll("circle").data(function(d) { return d; });
		circles.enter().append('circle')
			.attr('r', 0)
			.attr('cx', function(d) { return d.x; })
			.attr('cy', function(d) { return d.y; })
			.attr('tooltip', function(d) { return d.tooltip; });
		circles.exit().remove();
		circles
			// The largest circles should be on bottom to not eat all the events of smaller circles that may be underneath it.
			.sort(function(a, b) { return b.radius - a.radius; })
			.on('mouseover', function(d, i) { self._seriesState.enableStateByTypeAndId('standard', d.index, true); })
			.on('mouseout', function(d, i) { self._seriesState.enableStateByTypeAndId('standard', d.index, false); })
			.transition()
			.duration(opts.duration)
				.attr('r', function(d) { return Math.max(d.radius - 1, 0); })
				.attr('cx', function(d) { return d.x; })
				.attr('cy', function(d) { return d.y; });
	};

	/**
	 * Creates a series of clippaths that will be used as masks for our filled areas.
	 * @param  {Array[Set]} sets Describes the position and size of each set that should be drawn.
	 * @param  {Array[Overlay]} overlayCombos All the overlays we will be drawing
	 */
	venn._createClipPaths = function(sets, overlayCombos) {
		var self = this;

		// Each filled region should have a mask that we can apply to overlaps
		var defs = this._cvWrapper.select('svg').selectAll('defs').data(overlayCombos.length ? [0] : []);
		defs.enter().insert('defs', ':first-child');
		defs.exit().remove();

		var masks = defs.selectAll('clipPath').data(overlayCombos);
		masks.enter().append('clipPath');
		masks.exit().remove();
		masks.attr('id', function(d) { return 'clip-' + self._id + '-' + d.key; });

		var clipCircle = masks.selectAll('circle').data(function(d) {
			// Turn the key string '0-2-3' into {circleIndex: 0, maskInfo: '2-3'}
			// This is used to make it easy to create the masks.
			if (!d.key || !d.key.length) { return []; }
			var setIndices = d.key.split('-'),
				maskInfo = {
					circleIndex : setIndices.shift()
				};
			if (setIndices.length) {
				maskInfo.maskId = setIndices.join('-');
			}
			if (!sets || !sets[maskInfo.circleIndex]) {
				return [];
			}
			return [maskInfo];
		});
		clipCircle.enter().append('circle');
		clipCircle.exit().remove();
		clipCircle.attr('clip-path', function(d) { return d.hasOwnProperty('maskId') ? 'url(#clip-' + self._id + '-' + d.maskId + ')' : null; })
			.attr('r', function(d) { return sets[d.circleIndex].radius; })
			.attr('cx', function(d) { return sets[d.circleIndex].x; })
			.attr('cy', function(d) { return sets[d.circleIndex].y; })
			.style('fill', '#FFF');
	};

	/**
	 * Fill in the areas defined by the overlay combinations.  We only fill in areas that have been specified by the notation.
	 * @param  {Array[Overlay]} overlayCombos All the overlays we will be drawing.
	 */
	venn._drawFilledRegions = function(overlayCombos) {
		var self = this,
			opts = this._options;

		var filledRegions = this._d3Container.selectAll('.filled-regions').data(overlayCombos ? [overlayCombos] : []);
		filledRegions.enter().append('g').classed('filled-regions', true);
		filledRegions.exit().remove();

		var regions = filledRegions.selectAll('.fill-region').data(function(d) { return d; });
		regions.enter().append('rect').classed('fill-region', true);
		regions.exit().remove();
		regions.attr('clip-path', function(d) { return 'url(#clip-' + self._id + '-' + d.key + ')'; })
			.style('opacity', 1e-6)
			.attr('width', self._size[0])
			.attr('height', self._size[1])
			.classed('overlay', function(d) { return d.fill; }) // If these should be filled in, give them a class to give them a color.
			.on('mouseover', function(d, i) { self._seriesState.enableStateByTypeAndId('highlight', 'audience', true); })
			.on('mouseout', function(d, i) { self._seriesState.enableStateByTypeAndId('highlight', 'audience', false); })
			.transition()
				.delay(opts.duration)
				.duration(opts.duration)
					.style('opacity', 1);
	};

	/**
	 * Draws a circle for each set with a white very thick stroke.  This will help break up the filled overlays so the colored
	 * circle strokes are easily seen.
	 * @param  {Array[Set]} sets Describes the position and size of each set that should be drawn
	 */
	venn._drawPadding = function(sets) {
		var opts = this._options;

		var nodes = this._d3Container.selectAll('.padding-container').data([sets]);
		nodes.enter().append('g').classed('padding-container', true);
		nodes.exit().remove();

		var circles = nodes.selectAll('circle').data(function(d) { return d; });
		circles.enter().append('circle')
			.attr('r', 0)
			.attr('cx', function(d) { return d.x; })
			.attr('cy', function(d) { return d.y; });
		circles.exit().remove();
		circles
			.transition()
			.duration(opts.duration)
				.attr('r', function(d) { return d.radius; })
				.attr('cx', function(d) { return d.x; })
				.attr('cy', function(d) { return d.y; });
	};

	/**
	 * Draws a circle for each set that has a colored fill. These circles are only visible when they are moused-over on the plot or on the
	 * corresponding legend entry.
	 * @param  {Array[Set]} sets Describes the position and size of each set that should be drawn.
	 */
	venn._drawSetFills = function(sets) {
		var self = this,
			opts = this._options;

		var nodes = this._d3Container.selectAll('.set-fills-container').data([sets]);
		nodes.enter().append('g').classed('set-fills-container', true);
		nodes.exit().remove();

		var circles = nodes.selectAll("circle").data(function(d) { return d; });
		circles.enter().append('circle')
			.attr('r', 0)
			.attr('cx', function(d) { return d.x; })
			.attr('cy', function(d) { return d.y; });
		circles.exit().remove();
		circles
			.style('fill', function(d, i) { return self._dvColorScale.mapValue(i); })
			.transition()
			.duration(opts.duration)
				.attr('r', function(d) { return Math.max(d.radius - 3, 0); })
				.attr('cx', function(d) { return d.x; })
				.attr('cy', function(d) { return d.y; });
	};

	/**
	 * Draws a circle for each set with a colored stroke.
	 * @param  {Array[Set]} sets Describes the position and size of each set that should be drawn
	 */
	venn._drawBorders = function(sets) {
		var self = this,
			opts = this._options;

		var nodes = this._d3Container.selectAll('.border-container').data([sets]);
		nodes.enter().append('g').classed('border-container', true);
		nodes.exit().remove();

		var circles = nodes.selectAll("circle").data(function(d) { return d; });
		circles.enter().append('circle')
			.attr('r', 0)
			.attr('cx', function(d) { return d.x; })
			.attr('cy', function(d) { return d.y; });
		circles.exit().remove();
		circles
			.style('stroke', function(d, i) { return self._dvColorScale.mapValue(i); })
			.classed('predicted', function(d) { return d.predicted; })
			.transition()
			.duration(opts.duration)
				.attr('r', function(d) { return d.radius; })
				.attr('cx', function(d) { return d.x; })
				.attr('cy', function(d) { return d.y; });
	};

	/**
	 * Creates the state objects that will be used to maintain the enabled/disabled states of the sets and filled areas we are highlighting.
	 */
	venn._createStates = function() {
		var opts = this._options,
			sets = opts.data.sets;

		if ('data' in this._changedOptions && this._changedOptions.data) {
			// Remove old states
			this._seriesState.removeStatesByType('standard');
			this._seriesState.removeStatesByType('highlight');

			this._seriesState.appendState(this._dataAdapter.l10n.labels.venn.definedAudience, 'audience', 'highlight', false);

			var i,
				length = sets.length,
				domain = [],
				set;
			for (i = 0; i < length; i++) {
				set = sets[i];
				domain.push(i);
				this._seriesState.appendState(set.label || i, i, 'standard', false);
			}

			// Update the the color scale's domain, which will be used by the legend.
			this._dvColorScale.domain(domain);
		}
	};

	/**
	 * Uses our DV interactive legend to draw legend entries.
	 * @return {left:Number, top:Number, right:Number, bottom:Number} An object representing the space the legend took up that we'll subtract from the plot area.
	 */
	venn._drawLegend = function() {
		var opts = this._options,
			self = this;

		if (!this._legend) {
			this._legend = cloudViz.interactiveLegend();
		}

		// Use the DV interactive legend for this.  It forces us to do things a little differently than we do in DVCore, but forces
		// consistency and reduces code.
		this._legend
			.parent(this._cvWrapper.node())
			.orientation('bottom')
			.chartWidth(this._size[0]) // this used to be opts.width which now could be a percent string or undefined
                        .chartHeight(this._size[1]) // this used to be opts.height which now could be a percent string or undefined
			.chartPadding({left: 0, top: 0, right: 0, bottom: 0})
			.validOrientations(['bottom', 'left'])
			.legendVerticalWidth(opts.legendVerticalWidth)
			.type('line')
			.seriesState(this._seriesState)
			.interactive(false)
			.values(this._calculateValues(this._options.data.sets, this._overlapMap, this._parsedSetNotation))
			._render(null, {'fill': [this._dvColorScale]});
		var left = this._legend._getUsedWidth(),
			bottom = this._legend._getUsedHeight(),
			isHorizontallyOriented = bottom !== 0; // determine if the legends have a horizontal or vertical layout.

		var legendEntries = this._cvWrapper.selectAll('.cv-legend-entry')
				.on('mouseover', function(d) { self._seriesState.enableStateByTypeAndId(d.type, d.id, true); })
				.on('mouseout', function(d) { self._seriesState.enableStateByTypeAndId(d.type, d.id, false); });
		// Only apply the stretching of legends to fill the width if we have a horizontal orientation. Otherwise leave them alone.
		if (isHorizontallyOriented) {
			legendEntries.style('width', function(d, i) { return (self._size[0] / (self._options.data.sets.length + 1)) + 'px'; }); //divide equally the sets (+ 1 for defined audience).
		}

		return { left: left, bottom: bottom, right: 0, top: 0 };
	};

	/**
	 * This function is called whenever a state has been enabled/disabled.  We show elements and mute (change opacity) of other elements.
	 * @param  {State} state The state object that has been changed
	 */
	venn._onEnableState = function(state) {
		this._cvWrapper.selectAll('.set-fills-container circle')
			.style('display', function(d, i) { return state.type === 'standard' && state.id === i && state.enabled ? 'block' : 'none'; });
		this._cvWrapper.selectAll('.border-container circle')
			.classed('muted', function(d, i) { return state.id !== i && state.enabled; });
		this._cvWrapper.selectAll('.filled-regions rect')
			.classed('muted', function(d, i) { return state.type === 'standard' && state.enabled; });

		this._cvWrapper.selectAll('.padding-container circle')
			.style('display', function(d, i) { return state.type === 'highlight' && state.enabled ? 'none' : 'block'; });

		// Highlight the legend entry of the highlighted area
		this._cvWrapper.selectAll('.cv-legend-entry')
			.classed('inactive', function(d) { return state.enabled && (d.id !== state.id || d.type !== state.type); });
	};

	/**
	 * Determines the values that will be displayed in the legend entries.
	 * @param {{sets:[Set], overlaps:[Overlap], notation:string}} data The raw data associated with this visualization
	 * @return {[String]} Each formatted number that needs to be displayed in the legend entries.
	 */
	venn._calculateValues = function(sets, overlapMap, parsedNotation) {
		// First drop in the sum of all the highlighted areas, since that is always the first legend entry and is handled
		// differently than the remaining legend entries.
		var values = [ this._formatNumber('decimal', this._calculateHighlightedValue(sets, overlapMap, parsedNotation)) ],
			i,
			length = sets.length,
			set;
		for (i = 0; i < length; i++) { // Now add in the values for each of the sets.
			set = sets[i];
			values.push( set.sizeText ? set.sizeText: this._formatNumber('decimal', set.size));
		}

		return values;
	};

	/**
	 * Determines the value of the highlighted area.  NOTE: This will only work if every overlap is given a size, otherwise zero is assumed.  If you are wanting to display
	 * the intersection value of three overlapping sets: (0, 1, 2), there must be an overlap defined that looks like:
	 *
	 * {sets: [0, 1, 2], size: 10}.
	 *
	 * It is not enough to have definitions for 3 intersections like this:
	 *
	 * {sets: [0, 1], size: 10}
	 * {sets: [0, 2], size: 10}
	 * {sets: [1, 2], size: 10}
	 *
	 * without specifing what [0, 1, 2]'s size is.
	 *
	 * @param {{sets:[Set], overlaps:[Overlap], notation:string}} data The raw data associated with this visualization
	 * @return {Number} The calculated total of the highlighted region(s).
	 */
	venn._calculateHighlightedValue = function(sets, overlapMap, parsedNotation) {
		// A recursive function which calculates the sum of all highlighted areas. For example, the area for A | B | C | D with overlaps
		// can be computed as follows (U = union, ∩ = intersection):
		//
		// (A U B U C U D) = A + B + C + D - (A ∩ B) - (A ∩ C) - (A ∩ D) - (B ∩ C) - (B ∩ D) - (C ∩ D) + (A ∩ B ∩ C) + (A ∩ B ∩ D) + (A ∩ C ∩ D) + (B ∩ C ∩ D) - (A ∩ B ∩ C ∩ D).
		//
		// The pattern for achieving this is described here:
		//
		// http://statistics.about.com/od/Formulas/a/Probability-Of-The-Union-Of-Three-Or-More-Sets.htm
		// http://www.math.dartmouth.edu/archive/m19w03/public_html/Section6-2.pdf
		var calculateTotalByLevel = function(parsedNotation, indexArray, total, depth) {
				// Get set index combinations by combining each parsedNotation object with as many other indices as indicated
				// by depth.
				var combinations = this._combine(indexArray, depth, depth);

				// Check each unioned combination and either add or subtract their values from the total. Add the values if depth % 1
				// is != to zero, otherwise subtract.
				var i,
					combinationsLength = combinations.length,
					combo,
					sign = depth % 2 ? 1 : -1;
				for (i = 0; i < combinationsLength; i++) {
					combo = combinations[i];

					var j,
						comboLength = combo.length,
						index,
						setOverlapKey,
						unionedSets = [];
					for (j = 0; j < comboLength; j++) {
						index = combo[j];
						unionedSets = this._union(parsedNotation[index], unionedSets);
					}

					setOverlapKey = unionedSets.join('-');
					total += (overlapMap.hasOwnProperty(setOverlapKey) ? overlapMap[setOverlapKey] : 0) * sign;
				}

				depth++;

				// If depth < number of parsedNotation objects, recurse and increment depth.
				if (depth <= parsedNotation.length) {
					total = calculateTotalByLevel.call(this, parsedNotation, indexArray, total, depth);
				}

				return total;
			},
			generateIndexArray = function(length) {
				var indexArray = [], i;
				for (i = 0; i < length; i++) {
					indexArray.push(i);
				}
				return indexArray;
			};

		return calculateTotalByLevel.call(this, parsedNotation, generateIndexArray(parsedNotation.length), 0, 1);
	};

	/**
	 * Centers the venn diagram in the middle of the plot area.  By default, the venn diagram will appear in the top left.
	 * @param  {[Set]} sets Each set that is represented as a circle on the screen
	 */
	venn._makePlotFit = function(sets) {
		var opts = this._options,
			transformCoords = {x: 0, y: 0},
			largestX = 0,
			largestY = 0,
			padding = 4;

		sets.forEach(function(d) {
			largestX = Math.max(largestX, d.x + d.radius);
			largestY = Math.max(largestY, d.y + d.radius);
		});

		// Which dimension is most underutilized?
		if (this._size[0] - largestX > this._size[1] - largestY) {
			transformCoords.x = (this._size[0] - largestX) / 2 - padding;
		} else {
			transformCoords.y = (this._size[1] - largestY) / 2 - padding;
		}

		// Shift the entire group over to center the plot.
		this._cvWrapper.select('g')
			//.transform()
			//.duration(opts.duration)
				.attr('transform', 'translate(' + transformCoords.x + ',' + transformCoords.y + ')');
	};

	global.cloudViz.venn = cloudViz.util.createConstructor(venn);
}(this));

/**
 * Sunburst
 * The sunburst chart is designed to show multiple layers of ranked reports as they relate to each parent report
 * This chart is condusive to allowing users to interact with the ranked reports to determine segments and trends within those segments
 */

/*global document*/
(function(global) {
	'use strict';

	// Standard creation code for a CloudViz chart
	var cloudViz = global.cloudViz || {}, core = cloudViz.core || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		sunburst = Object.create(core);

	sunburst.init = function(options) {
		this._type = 'sunburst';
		this._hiddenNodes = []; // user hidden nodes, manually set and manually unset
		this._outRangeNodes = []; // hidden nodes when color slider is used
		this._invalidNodes = []; // hidden nodes when secondary metric is used aka other
		this._initDefaultOptions();
		this.setOptions(options);
		return this;
	};

	sunburst._initDefaultOptions = function() {
		var metricName = 'Visits',
			defaults = {
				otherColor : '#ccc',
				otherGrayColor : '#999',
				outRangeColor : '#5a5a5a',
				metricColor : '#fff',
				seqColors : [
					'#faf0c8',
					'#d2dc73',
					'#5faf69',
					'#00505A'
				],
				seqColorsHeat : [
					'#5a6eaa',
					'#3287d2',
					'#3cb5a0',
					'#5faf69',
					'#8cc350',
					'#c3d250',
					'#f5c841',
					'#f0a01e',
					'#eb782d',
					'#fa5a50'
				],
				colors : [
					'#3287d2',
					'#9b8ce6',
					'#d755a5',
					'#fa5a50',
					'#f0a01e',
					'#c3d250',
					'#5faf69',
					'#1ebed7',
					'#5a6eaa',
					'#78b4f5',
					'#aa5fa5',
					'#f0557d',
					'#e8782d',
					'#f5c841',
					'#8cc350',
					'#3cb5a0', // 16
					'#286eaf',
					'#826ee1',
					'#b93282',
					'#f04641',
					'#e18c00',
					'#a0b400',
					'#50965a',
					'#00a0be',
					'#465a87',
					'#4196e6',
					'#964196',
					'#dc3c69',
					'#dc5f00',
					'#e6b43c',
					'#7daf4b',
					'#32a08c' // 32
				],
				padding : {
					top: 10,
					bottom: 60,
					left: 10,
					right: 10
				}
			};
		return Object.getPrototypeOf(sunburst)._initDefaultOptions.call(this, defaults);
	};

	sunburst._onAutoResize = function() {
		this.resize();
	};

	/**
	 * Update container dimensions and update the graph with new values
	 * Don't reprocess the data so we lose the current state
	 **/
	sunburst.resize = function() {
		if (!d3.select(this._options.parent).selectAll('.sunburst-cv').node()) {
			return; // not a valid chart, probably in an error state
		}
		this._sizeChart();
		this._render(true);
	};

	/**
	 * Resets the chart instance.  Called on both render and destroy.
	 **/
	sunburst.reset = function() {
		Object.getPrototypeOf(sunburst).reset.apply(this, arguments);
		// Since we use render() on resize (which calls reset in core)
		// we cannot use reset to actually remove behaviors and other additional layers
		// Instead we detect it in preRender and reset there
	};

	sunburst._preRender = function() {
		// Before we process data, lets save off the x/y positions of the path keys
		// Then we can animate them to their new positions if/when needed
		if (this._paths) {
			// initial render, but previous paths
			// go over data and match up keys and put in previous values so we can animate from them
			var keys = this._oldKeys = this._dataAdapter.getDataByPathKey(), k, d;
			// store off the position data on the key
			for (k in keys) {
				d = keys[k];
				keys[k] = {
						xo : d.x, dxo : d.dx,
						yo : d.y, dyo : d.dy
					};
			}
		}

		Object.getPrototypeOf(sunburst)._preRender.apply(this);

		var options = this._options, self = this,
			adapter = this._dataAdapter,
			l10n = adapter.l10n.labels.sunburst,
			parent = d3.select(options.parent);

		// update hidden array for secondary metric
		if (adapter.getSecondaryMetricIndex()) {
			self._hideNode(adapter.data(), self._invalidNodes, function(d) { return self._isInvalidNode(d); });
		}
		// update hidden with same nodes and possibly same children
		var oldHidden = this._hiddenNodes, currentKeys = adapter.getDataByPathKey();
		this._hiddenNodes = [];
		oldHidden.forEach(function(n, i) {
			// find the node in the current data set and hide it and its children
			var nkey = adapter.getPathKey(n);
			if (currentKeys[nkey]) { self._hideNode(currentKeys[nkey], self._hiddenNodes); }
		});
		// update zoomed if same node still applies
		var zoomed = this._zoomedPath;
		this._zoomedPath = null;
		if (zoomed) {
			zoomed = currentKeys[adapter.getPathKey(zoomed)];
			this._zoomedPath = this._oldZoomed = zoomed;
		}

		// locked for path and category
		var locked = this._lockedNode;
		this._lockedNode = null;
		if (locked) {
			if ('path' === locked.type) {
				locked.data = currentKeys[adapter.getPathKey(locked.data)];
				if (locked.data) { this._oldLockedNode = locked; }
			}
			if ('category' === locked.type) {
				var found = adapter.categories().some(function(c) {
					if (locked.data && locked.data.name === c.name) {
						locked.data = c;
						return true;
					}
					return false;
				});
				if (found) { this._oldLockedNode = locked; }
			}
		}

		// Wrap the sunburst chart in a new wrapper to allow for scrolling
		var infoWrapper = parent.selectAll('.sunburst-cv').data([0]);
		infoWrapper.enter().insert('div', ':first-child').classed('sunburst-cv', true);
		var wrapper = infoWrapper.selectAll('.sunburst-cv-wrapper').data([0]);
		wrapper.enter().insert('div', ':first-child').classed('sunburst-cv-wrapper', true);
		var container = wrapper.selectAll('.sunburst-cv-container').data([0]);
		container.enter().insert('div', ':first-child').classed('sunburst-cv-container', true);
		var svg = container.selectAll('.sunburst-svg').data([0]);
		svg.enter().append('svg').classed('sunburst-svg', true);
		var paths = svg.selectAll('.sunburst-svg-container').data([0]);
		paths.enter().append('g').classed('sunburst-svg-container', true);
		var chartLabel = wrapper.selectAll('.sunburst-cv-label').data([0]);
		chartLabel.enter().append('div').classed('sunburst-cv-label', true);
		var chartLabelWrap = chartLabel.selectAll('.sunburst-cv-label-wrap').data([0]);
		chartLabelWrap.enter().append('div').classed('sunburst-cv-label-wrap', true);
		var chartLabelMetric = chartLabelWrap.selectAll('.sunburst-cv-label-metric').data([0]);
		chartLabelMetric.enter().append('div').classed('sunburst-cv-label-metric', true);
		var chartAudiences = chartLabelWrap.selectAll('.sunburst-audiences').data([0]);
		chartAudiences.enter().append('div').classed('sunburst-audiences', true);
		chartAudiences.exit().remove();

		// Chart actions
		var actions = infoWrapper.selectAll('.sunburst-cv-actions-pane').data([0]);
		actions.enter().append('div').classed('sunburst-cv-actions-pane', true);
		actions.exit().remove();
		var zoomout = actions.selectAll('.actions-pane-zoomout').data([0]);
		zoomout.enter().append('div').classed('actions-pane-zoomout', true).classed('actions-pane-action', true);
		zoomout.html('<i class="icon zoomout"></i><span>'+ l10n.zoomout +'</span>');
		zoomout.on('click', function() {
			self._zoomPath(adapter.data());
		});
		zoomout.exit().remove();
		var hidden = actions.selectAll('.actions-pane-hidden').data([0]);
		hidden.enter().append('div').classed('actions-pane-hidden', true).classed('actions-pane-action', true);
		hidden.html('<i class="icon hide"></i><span>'+self._hideLabelText()+'</span>');
		hidden.on('click', function() {
			self._unhidePaths();
		});
		hidden.exit().remove();

		// Secondary metric options
		var second = wrapper.selectAll('.sunburst-cv-sec-viz').data([0]);
		var secondEntry = second.enter().append('div').classed('sunburst-cv-sec-viz', true);
		secondEntry.append('span').classed('title', true);
		var secondEntryBar = secondEntry.append('span').classed('bar', true);
		secondEntryBar.append('span').classed('button', true).classed('color', true).append('span');
		secondEntryBar.append('span').classed('button', true).classed('height', true).append('span');
		secondEntryBar.append('span').classed('button', true).classed('both', true).append('span');
		// Add clicks for this instance
		second.selectAll('.button.color').on('click', function() {
				adapter.setSecondaryMetricType('color');
				self._secondaryMetricChanged();
			})
			.selectAll('span').html(l10n.color);
		second.selectAll('.button.height').on('click', function() {
				adapter.setSecondaryMetricType('height');
				self._secondaryMetricChanged();
			})
			.selectAll('span').html(l10n.height);
		second.selectAll('.button.both').on('click', function() {
				adapter.setSecondaryMetricType('both');
				self._secondaryMetricChanged();
			})
			.selectAll('span').html(l10n.both);
		second.exit().remove();

		// Secondary Metrics Interface
		var secSeq = wrapper.selectAll('.sunburst-cv-secondary').data([0]);
		secSeq.enter().append('div').classed('sunburst-cv-secondary', true);
		secSeq.exit().remove();

		// Color slider interface
		var paneSeq = secSeq.selectAll('.sunburst-cv-color').data([0]);
		paneSeq.enter().append('div').classed('sunburst-cv-color', true);
		paneSeq.exit().remove();

		// Side information pane
		var pane = infoWrapper.selectAll('.sunburst-cv-info-pane').data([0]);
		pane.enter().append('div').classed('sunburst-cv-info-pane', true);
		pane.exit().remove();
		var paneContent = pane.selectAll('.info-pane-content').data([0]);
		paneContent.enter().append('div').classed('info-pane-content', true);
		paneContent.exit().remove();
		var paneCategories = paneContent.selectAll('.info-pane-categories').data([0]);
		paneCategories.enter().append('div').classed('info-pane-categories', true)
			.append('div').classed('pane-title', true).append('span');
		paneCategories.exit().remove();
		var paneAudiences = paneContent.selectAll('.sunburst-audiences').data([0]);
		paneAudiences.enter().append('div').classed('sunburst-audiences', true)
			.append('div').classed('pane-title', true).append('span').text(l10n.audience);
		paneAudiences.exit().remove();
		var paneActions = paneContent.selectAll('.info-pane-actions').data([0]);
		paneActions.enter().append('div').classed('info-pane-actions', true);
		paneActions.exit().remove();
		var paneMetrics = paneContent.selectAll('.info-pane-metrics').data([0]);
		var metricsEnter = paneMetrics.enter().append('div').classed('info-pane-metrics', true);
		metricsEnter.append('div').classed('pane-title', true).classed('pri-metric', true).append('span');
		metricsEnter.append('div').classed('info-pane-metrics-labels', true).classed('pri-metric-labels', true);
		metricsEnter.append('div').classed('pane-title', true).classed('sec-metric', true).append('span');
		metricsEnter.append('div').classed('info-pane-metrics-labels', true).classed('sec-metrics-labels', true)
			.append('span').classed('sec-metrics-help', true);
		metricsEnter.append('div').classed('pane-title', true).classed('rank-chart', true).append('span');
		metricsEnter.append('div').classed('info-pane-metrics-chart', true);
		paneMetrics.exit().remove();
		var paneExtra = paneContent.selectAll('.info-pane-extra').data([0]);
		paneExtra.enter().append('div').classed('info-pane-extra', true);
		paneExtra.exit().remove();

		// Mobile scroll tip
		// This will show if the screen is mobile size and screen is too short
		var scrollTip = infoWrapper.selectAll('.sunburst-cv-mobile-scroll').data([0]);
		scrollTip.enter().append('div').classed('sunburst-cv-mobile-scroll', true);
		scrollTip.html(l10n.mobilescroll);
		scrollTip.exit().remove();

		// Size wrapping divs
		this._sizeChart();

		// update wrapper classes for zoom/hidden
		infoWrapper.classed('hiddenpaths', !!this._hiddenNodes.length);
	};

	sunburst._render = function(resize) {
		Object.getPrototypeOf(sunburst)._render.apply(this);

		var self = this, options = this._options,
			adapter = this._dataAdapter, data = adapter.data(),
			wrapper = d3.select(options.parent).selectAll('.sunburst-cv'),
			container = wrapper.selectAll('.sunburst-cv-container'),
			svg = container.selectAll('.sunburst-svg-container'),
			width = parseInt(container.style('width'), 10),
			height = parseInt(container.style('height'), 10),
			radius = this._radius = Math.min(width, height) / 2;

		// Determine inner radius dimensions
		var isMobileSize = this._isMobileSize(),
			numRings = (data.categories.length + 1), // counts inner radius as a ring
			ringDivisor = this._ringDivisor = 1 / numRings,
			centerLabelWidth = isMobileSize ? 20 : 140, // width of the square inside the circle
			centerRadius = this._centerRadius = Math.ceil((centerLabelWidth / 2) / (Math.cos(Math.PI / 4))); // determine center radius

		// Position svg for paths
		svg.attr('transform', 'translate(' + (width / 2) + ',' + (height / 2) + ')');

		// Save off the old yscale to convert values to the new scale
		if (!resize && this._yScale) {
			this._oldYScale = this._yScale;
		}
		if (!resize && this._xScale) {
			this._oldXScale = this._xScale;
		}

		// Create actual diagram
		var xScale = this._xScale = d3.scale.linear().domain(this._oldXScale ? this._oldXScale.domain() : [0,1]).range([0, 2 * Math.PI]),
			yScale = this._yScale = d3.scale.linear().domain([0, ringDivisor, 1]).range([0, centerRadius, radius]),
			arc = this._arc = d3.svg.arc()
				// Both ending angles must be between 0 and 2PI radians
				.startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, xScale(d.x))); })
				.endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, xScale(d.x + d.dx))); })
				// A minimum of zero is required for each radius value
				.innerRadius(function(d) { return Math.max(0, yScale(d.y)); })
				.outerRadius(function(d) { return Math.max(0, yScale(d.y + d.dy)); });

		// Set the path data
		this._layoutPaths(resize);

		// Create labels
		var chartLabel = d3.select(options.parent).select('.sunburst-cv-label'),
			labelWidth = Math.ceil((centerRadius * Math.cos(Math.PI / 4)) * 2), // (radius * cos 45 deg) * 2
			labelHeight = labelWidth,
			labelTop = options.padding.top + Math.floor(height/2 - labelHeight/2),
			labelLeft = options.padding.left + Math.floor(width/2 - labelWidth/2);
		// Position chart label
		if (!isMobileSize) {
			chartLabel.style('top', labelTop + 'px').style('left', labelLeft + 'px')
				.style('width', labelWidth + 'px').style('height', labelHeight + 'px');
		} else {
			chartLabel.style('top', '').style('left', '')
				.style('width', '').style('height', '');
		}

		// Update info in the right rail
		this._updateDetails(this._lockedNode);

		// Handle empty data set
		if (adapter.isDataEmpty()) {
			this._setErrorMessage(adapter.l10n.labels.core.nodata);
		} else if (adapter.isSizeEmpty()) {
			this._setErrorMessage(adapter.l10n.labels.sunburst.emptyFirstMetric);
		} else {
			this._clearErrorMessage();
		}
	};

	/**
	 * Joins all hidden arrays into one to determine if a node is hidden or not
	 * @returns {array} array of hidden nodes
	 * @private
	 */
	sunburst._getHiddenNodes = function() {
		return this._hiddenNodes.concat(this._outRangeNodes, this._invalidNodes);
	};

	/**
	 * Use a secondary metric to adjust the height of each of the nodes
	 * Used after partition layout
	 * Recursively calls itself down through the children to adjust the height of the node
	 * and the y position of its children using the modifier
	 * @param {object} path data obj
	 * @param {num} amount to adjust the y down
	 * @param {array} min/max objects for each level
	 * @private
	 */
	sunburst._adjustDataSize = function(node, modifier, minmax) {
		var options = this._options, self = this,
			adapter = this._dataAdapter,
			level = node.depth - 1,
			zoomed = this._zoomedPath,
			minHeight = 0.15, // minimum percentage height
			metricIndex = adapter.getStackedMetricIndex();
		if (level >= 0 && node.metrics && node.metrics[metricIndex]) {
			// adjust y by modifier
			node.y -= modifier;
			// determine new dy value based on metric value percentage
			var value = node.metrics[metricIndex].value,
				cat = minmax[level],
				max = cat.max,
				min = Math.min(0, cat.min),
				scale = d3.scale.linear().domain([min, max]).range([minHeight,1]),
				newDy = scale(value) * node.dy;
			if (max === min || // 1 value, dont' modify
				(zoomed && zoomed.depth > node.depth)) { newDy = node.dy; } // below the zoom
			modifier += (node.dy - newDy);
			node.dy = newDy;
		}
		if (!node.children || !node.children.length) { return; }
		// recursively update
		node.children.forEach(function(c) {
			self._adjustDataSize(c, modifier, minmax);
		});
	};

	/**
	 * Gets the level's unique set of nodes
	 * Will strip out nodes that are hidden if flag is set
	 * Recursively sorts through the nodes
	 * @param {object} path data obj
	 * @param {number} level to get
	 * @param {boolean} flag to include hidden nodes
	 * @return {array} [nodes]
	 * @private
	 */
	sunburst._getLevelUniqueNodes = function(node, level, includeHidden) {
		var adapter = this._dataAdapter, hidden = this._getHiddenNodes(),
			nodes = [], nodesByName = [], self = this, zoomed = this._zoomedPath;
		function getNodes(d) {
			if (zoomed && zoomed.depth === d.depth && zoomed !== d) { return; } // outside zoom
			if (d.depth === level) {
				if (!includeHidden && hidden.indexOf(d) >= 0) { return; }
				if (nodesByName.indexOf(d.name) >= 0) { return; } // already have it
				nodes.push(d);
				nodesByName.push(d.name);
				return; // no need to go deeper
			}
			if (!d.children || !d.children.length) { return; }
			// recursively update
			d.children.forEach(function(c) {
				getNodes(c);
			});
		}
		getNodes(node);
		return nodes || [];
	};

	/**
	 * Update the layout of the paths from the adapter data
	 * @param {boolean} data is being modified, false if initial render
	 * @private
	 */
	sunburst._layoutPaths = function(modify) {
		var options = this._options, arc = this._arc, self = this,
			adapter = this._dataAdapter,
			data = adapter.data(), hidden = this._getHiddenNodes(),
			container = d3.select(options.parent).selectAll('.sunburst-svg-container'),
			partition = d3.layout.partition().value(function(d) {
				return (hidden.indexOf(d) < 0) ? d.size : 0;
			}).sort(function(a, b) {
				if (adapter.isOther(a)) { return 1; } // b first
				if (adapter.isOther(b)) { return -1; } // a first
				return b.size - a.size;
			});

		// Take the current position/dimension and store for animation
		if (modify && self._paths) {
			self._paths.each(function(d) {
				d.xo = d.x;
				d.dxo = d.dx;
				d.yo = d.y;
				d.dyo = d.dy;
			});
		}

		// update with new paths based on data
		var nodes = partition.nodes(data);
		var paths = this._paths = container.selectAll('path').data(nodes,adapter.getPathKey);
		paths.enter().insert('path', ':first-child');
		paths
			.attr('data-sid', function(d, i) { return d._sid; })
			.on('click', function(d, i) { self._lockNode({ data:d, type:'path' }); })
			.on('dblclick', function(d, i) { self._zoomPath(d); })
			.on('mouseenter', function(d, i) {
				if (self._lockedNode || self._isTouch()) { return; }
				self._highlightNode({ data:d, type:'path' });
			});
		var pathsExit = paths.exit().classed('removing', true);
		setTimeout(function() {
			pathsExit.remove();
		}, 501);

		// set color scale
		self.setColorScale();

		// update colors
		this._updatePathColors();

		// update slider
		self._buildColorSlider();

		// Modify the y/dy of each node based on its percentage of the min/max
		// Other is always zero value (maybe)
		var metric;
		if (metric = adapter.getStackedMetric()) {
			// create object with min max for each category for stacked metric
			var index = adapter.getStackedMetricIndex(),
				zoomed = this._zoomedPath,
				// TODO: We need more accurate data type than the format type
				isRate = false, //'percent' === metric.format,
				minMax;

			// only run the calculation if needed
			if (isRate) {
				var metricMinMax = self.getMetricCategoryMinMax(index);
				minMax = Array.apply(null, new Array(data.categories.length)).map(function(){
					return metricMinMax;
				});
			} else {
				minMax = data.categories.map(function(c, i) {
						return self.getMetricCategoryMinMax(index, i);
					});
			}
			self._adjustDataSize(data, 0, minMax);
		}

		if (this._oldKeys) {
			// update if we are rendering a new data set on an older graph
			var key, k, os = this._oldYScale, osd = os.domain(),
				s = this._yScale, sd = s.domain();
			self._paths.each(function(d) {
				key = adapter.getPathKey(d);
				if (k = self._oldKeys[key]) {
					d.xo = k.xo;
					d.dxo = k.dxo;
					d.yo = s.invert(os(k.yo));
					if (adapter.isRoot(d)) {
						// convert to new domain so we draw from the same range
						d.dyo = s.invert(os(k.dyo));
					} else {
						// convert but make sure we don't use the interval reserved for the center
						d.dyo = s.invert(os(osd[1] + k.dyo)) - sd[1];
					}
				}
			});
			this._oldKeys = null;
		}

		// handle new paths created, always animate from zero
		paths.each(function(d) {
			var key = adapter.getPathKey(d);
			if ('undefined' === typeof d.xo) {
				d.xo = d.x;
				d.dxo = d.dx;
				d.yo = 0;
				d.dyo = 0;
			}
		});

		// Transition the paths
		paths.transition()
			.duration(500)
			.attrTween('d', this._changeTween(true));

		container.on('mouseleave', function(d, i) {
			if (self._lockedNode || self._isTouch()) { return; }
			self._unhighlightNode();
		});

		if (!modify) {
			// update locked state now that we have paths
			if (this._oldLockedNode) { this._lockNode(this._oldLockedNode); }
			else { this._unlockNode(); }
			this._oldLockedNode = null;
			this._updateZoomPathStyles(this._oldZoomed);
			this._oldZoomed = null;
		}

	};

	sunburst._isMobileSize = function() {
		var options = this._options,
			parentWidth = options.parent.offsetWidth,
			visibleWidth = dv.util.getPercentValue(options.width, parentWidth);
		return visibleWidth < 640;
	};

	sunburst._isTouch = function() {
		return 'ontouchstart' in document.documentElement;
	};

	sunburst._postRender = function() {
		Object.getPrototypeOf(sunburst)._postRender.apply(this);
	};

	sunburst._sizeChart = function(focusElem) {
		var options = this._options, data = this._dataAdapter.data(),
			parent = d3.select(options.parent), self = this,
			infoWrapper = parent.selectAll('.sunburst-cv'),
			wrapper = infoWrapper.selectAll('.sunburst-cv-wrapper'),
			container = wrapper.selectAll('.sunburst-cv-container'),
			infoPane = infoWrapper.selectAll('.sunburst-cv-info-pane'),
			scrollTip = infoWrapper.selectAll('.sunburst-cv-mobile-scroll'),
			parentWidth = options.parent.offsetWidth,
			parentHeight = options.parent.offsetHeight,
			visibleWidth = dv.util.getPercentValue(options.width, parentWidth),
			visibleHeight = dv.util.getPercentValue(options.height, parentHeight),
			isMobileSize = this._isMobileSize(),
			adjustedWidth = visibleWidth + (isMobileSize ? 0 : -250), // can't use dynamic since it starts at 100%
			adjustedHeight = isMobileSize ? Math.min(adjustedWidth, visibleHeight) : visibleHeight, // mobile make height same is width
			padding = options.padding;


		// Determine the visible dimensions of the chart
		var containerWidth = adjustedWidth - 2 - (padding.left + padding.right), // adjust for borders
			containerHeight = adjustedHeight - 2 - (padding.top + padding.bottom);

		infoWrapper.style('width', visibleWidth + 'px').style('height', visibleHeight + 'px')
			.classed('is-desktop', !isMobileSize).classed('not-touch', !this._isTouch());
		wrapper.style('width', adjustedWidth + 'px').style('height', adjustedHeight + 'px');
		container.style('width', containerWidth + 'px').style('height', containerHeight + 'px');
		container.style('padding-top', padding.top + 'px').style('padding-left', padding.left + 'px');
		scrollTip.style('top', (visibleHeight - 30) + 'px')
			.classed('visible', !infoWrapper.node().scrollTop)
			.classed('show', visibleHeight <= adjustedHeight + 130); // padding on bottom
		infoWrapper.on('scroll', function() {
				scrollTip.classed('visible', !infoWrapper.node().scrollTop);
			});
	};

	/**
	 * Build the color slider to display values for color
	 * to be used as a legend for a second metric
	 * @param {object} path data obj
	 * @private
	 */
	sunburst._buildColorSlider = function() {
		var options = this._options, self = this, adapter = this._dataAdapter,
			pane = d3.select(options.parent).selectAll('.sunburst-cv-color');
		if (!adapter.getColorMetric()) { return pane.text(''); }
		var data = adapter.data(), metric = adapter.getColorMetric(),
			extent = this._colorExtent,
			min = self._colorExtentMin, max = self._colorExtentMax,
			container = d3.select(options.parent).selectAll('.sunburst-cv-container'),
			containerWidth = parseInt(container.style('width'), 10),
			paneWidth = containerWidth / 2,
			colors = adapter.seqColors(),
			colorDiv = Math.round(100 / (colors.length - 1)),
			positions = [],
			// Layout
			height = 12,
			padding = 10,
			controlSpacer = 9,
			minMaxWidth = 40,
			legendHeight = (height + (padding * 2) + 2),
			legendWidth = paneWidth,
			barWidth = legendWidth - (minMaxWidth * 2) - (controlSpacer * 2);

		// Populate positions
		colors.forEach(function(c, i) {
			positions.push((i * colorDiv) + '%');
		});

		// Pane
		pane.style('width', legendWidth + 'px');

		// Color title
		var legendTitle = pane.selectAll('.legend-title').data([0]);
			legendTitle.enter()
				.insert('div', ':first-child')
				.classed('legend-title', true);
		legendTitle.text(metric.name);

		// SVG slider
		var legend = pane.selectAll('.color-slider-legend').data([0]);
		legend.enter().append('div').classed('color-slider-legend', true);
		legend.style('width', legendWidth + 'px').style('height', legendHeight + 'px');
		var svg = legend.selectAll('.color-slider').data([0]);
		svg.enter().append('svg').classed('color-slider', true)
			.style('height', legendHeight + 'px').style('width', '100%');

		// Styles to apply gradients
		// We have to inline this as the url() is relative (FF enforces this)
		var styles = svg.selectAll('style').data([0]);
		styles.enter().append('style');
		styles.text(function(d) {
			var style = '.sunburst-cv .sunburst-cv-color .grad-rect { fill: url(#backGradient); \n';
			return style;
		});

		// Add linear gradients definitions
		var defs = svg.selectAll('defs').data([0]);
		defs.enter().append('defs');
		var backGradient = defs.selectAll('#backGradient').data([0]);
		backGradient.enter().append('linearGradient').attr('id', 'backGradient');

		var applyStops = function(selection, positions, colors) {
			var stop = selection.selectAll('stop').data(positions);
			stop.enter()
				.append('stop')
					.attr('class', function(d, i) { return 'stop' + i; });
			stop.attr('offset', function(d) { return d; })
				.attr('stop-color', function(d, i) { return colors[i]; });
		};
		applyStops(backGradient, positions, colors);

		// Gray Background
		/*var gradBg = svg.selectAll('.grad-bg').data([0]);
		gradBg.enter().append('rect').classed('grad-bg', true);

		gradBg
			.style('fill', options.outRangeColor)
			.attr('x', minMaxWidth + controlSpacer)
			.attr('y', padding)
			.attr('rx', height / 2)
			.attr('ry', height / 2)
			.attr('width', barWidth)
			.attr('height', height);*/

		// Gradient Background
		var gradRect = svg.selectAll('.grad-rect').data([0]);
		gradRect.enter().append('rect').classed('grad-rect', true);
		gradRect
			.attr('x', minMaxWidth + controlSpacer)
			.attr('y', padding)
			.attr('rx', height / 2)
			.attr('ry', height / 2)
			.attr('width', barWidth)
			.attr('height', height);

		// End Labels
		var legendLabel = legend.selectAll('.legend-label').data(['min', 'max']);
		legendLabel.enter()
			.append('div').attr('class', function(d) { return 'legend-label ' + d; });
		legendLabel
			.style('left', function(d) { return (d === 'min' ? 0 : minMaxWidth + (controlSpacer * 2) + barWidth) + 'px'; })
			.style('width', minMaxWidth + 'px')
			.text(function(d) {
				var val = d === 'min' ? min : max;
				val = (null === val) ? (d === 'min') ? '-' : '+' : self._formatNumber(metric.format, val);
				return val;
			});

		/*var brushing = false,
			brush = d3.svg.brush()
			.x(d3.scale.linear().range([0, barWidth]))
			.extent(extent)
			.on('brushstart', function() {
				brushing = true;
			})
			.on('brushend', function() {
				brushing = false;
				self._outRangeNodes = [];
				self._hidePath(adapter.data(), self._outRangeNodes, function(d) { return self._isNodeOutsideRange(d); });
			})
			.on('brush', function() {
				var curExtent;
				self.setColorScale(curExtent = brush.extent());
				svg.selectAll('.grad-rect')
					.attr('width', (curExtent[1] - curExtent[0]) * barWidth)
					.attr('x', (barWidth * curExtent[0]) + minMaxWidth + controlSpacer);

				self._updatePathColors();
				legend.selectAll('.legend-label.min').text(self._formatNumber(metric.format, self._colorExtentMin));
				legend.selectAll('.legend-label.max').text(self._formatNumber(metric.format, self._colorExtentMax));
			});

		var handleWidth = 10;
		var handleHeight = height + 20;

		var brushg = svg.selectAll('.brush').data([data]);
		brushg.enter()
			.append('g')
				.classed('brush', true);
		brushg
			.attr('transform', 'translate(' + (minMaxWidth + controlSpacer) + ',' + (padding + (height/2) - (handleHeight/2)) + ')')
			.call(brush);

		var resize = brushg.selectAll('.resize');
		var handle = resize.selectAll('.handle').data(function(d) { return d; });
		handle.enter()
			.append('rect')
				.classed('handle', true);
		handle
			.attr('transform', 'translate(' + -(handleWidth/2) +  ',0)')
			.attr('rx', handleWidth/3)
			.attr('ry', handleWidth/3)
			.attr('width', handleWidth)
			.attr('height', handleHeight);*/
	};

	/**
	 * Recursive method to determine if node is outside
	 * the current adapter extent range
	 * as well as all of its children
	 * @param {object} path data obj
	 * @returns {boolean} true if node and all its children are outside
	 * @private
	 */
	sunburst._isNodeOutsideRange = function(n) {
		var adapter = this._dataAdapter, self = this,
			children = n.children || [],
			inside = children.some(function(c) {
				return !self._isNodeOutsideRange(c);
			});
		return !inside && this.isOutsideRange(n);
	};

	/**
	 * If a secondary metric is set and the node is other, it is invalid
	 * @param {object} path data obj
	 * @returns {boolean} true if node is invalid
	 * @private
	 */
	sunburst._isInvalidNode = function(n) {
		return this._dataAdapter.isOther(n);
	};

	/**
	 * Returns string for number of hidden items
	 * @returns {string}
	 * @private
	 */
	sunburst._hideLabelText = function() {
		var num = this._hiddenNodes.length, l10n = this._dataAdapter.l10n.labels.sunburst,
			label = (num === 1) ? l10n.hidden: l10n['hidden2+'];
		return label.replace(/\{value\}/i, num);
	};

	/**
	 * Recursive hide method
	 * Hides node and children based on the hide method
	 * If no hide method is provided, it will hide the node and every child
	 * @param {object} path data obj
	 * @param {func} return true to hide current n
	 * @private
	 */
	sunburst._hideNode = function(n, hidden, hide) {
		var self = this;
		if (hidden.indexOf(n) > -1) { return; } // already hidden
		if (hide && hide(n) || !hide) { hidden.push(n); } // func to determine if we should hide the node
		if (!n.children || !n.children.length) { return; }
		n.children.forEach(function(c) { self._hideNode(c, hidden, hide); });
	};

	/**
	 * Removes paths from the visualization
	 * They are still accounted for in numbers/percents etc
	 * @param {object} path data obj
	 * @param {array} array to place the hidden nodes in
	 * @param {func} test method to see if a node should be hidden
	 * @private
	 */
	sunburst._hidePath = function(d, hidden, hide) {
		var options = this._options,
			adapter = this._dataAdapter,
			paths = this._paths;
		// add hidden to specified nodes
		this._hideNode(d, hidden, hide);
		// rerun the partition
		this._layoutPaths(true);
		// remove the locked path if it was locked
		if (this._lockedNode && hidden.indexOf(this._lockedNode.data) > -1) {
			this._unlockNode();
		}
		if (this._zoomedPath && hidden.indexOf(this._zoomedPath) > -1) {
			this._zoomPath(adapter.data());
		}
		// update hidden label
		var num = this._hiddenNodes.length, parent = d3.select(options.parent);
		parent.selectAll('.actions-pane-hidden').selectAll('span').html(this._hideLabelText());
		parent.selectAll('.sunburst-cv').classed('hiddenpaths', !!num);
	};

	/**
	 * Restores all paths from the data set
	 * @param {object} path data obj
	 * @private
	 */
	sunburst._unhidePaths = function() {
		this._hiddenNodes = [];
		// rerun the partition
		this._layoutPaths(true);
		// remove hidden class
		d3.select(this._options.parent).selectAll('.sunburst-cv').classed('hiddenpaths', false);
	};

	/**
	 * Zooms the selected path if possible
	 * @param {object} path data obj
	 * @private
	 */
	sunburst._zoomPath = function(d) {
		// Setup the zoom transition
		if (!this._canZoomIn(d)) { return; }
		this._zoomedPath = d;
		this._layoutPaths(true);
		this._updateZoomPathStyles(d);
		// Update options in the right rail
		this._updateDetails(this._lockedNode);
	};

	sunburst._updateZoomPathStyles = function(d) {
		// Update fill color of inner rings
		var self = this, container = d3.select(this._options.parent).selectAll('.sunburst-cv');
		container.classed('zoomed', d && d.depth > 0);
		container.selectAll('.sunburst-cv-container').selectAll('path').each(function(node) {
			d3.select(this).classed('beyondzoom', node && d && // we do have a zoomed node
				node !== d && node.depth > 0 && // node is not the zoomed node and not base metric
				(node.depth <= d.depth || // node is above or a sibling of zoomed or
					!self._hasAncestorNode(node, d))); // node is not a child of zoomed
			d3.select(this).classed('zoomed', node === d);
		});
	};

	/**
	 * The tween animation function for D3 to handle the d attribute tween
	 * Handles zoom and/or hiding elements
	 * @param {object} path data obj
	 * @private
	 */
	sunburst._changeTween = function(hide) {
		var x = this._xScale, y = this._yScale,
			path = this._zoomedPath || this._dataAdapter.data(),
			arc = this._arc, radius = this._radius,
			ringDivisor = this._ringDivisor,
			centerRadius = this._centerRadius,
			cats = this._dataAdapter.categories(),
			xd = d3.interpolate(x.domain(), [path.x, path.x + path.dx]),
			yd = d3.interpolate(y.domain(), (path.y) ? [0, ringDivisor, path.y, 1] : [0, ringDivisor, 1]),
			yr = d3.interpolate(y.range(), (path.y) ? [0, centerRadius, centerRadius, radius] : [0, centerRadius, radius]);

		return function(d, i) {
			var ip = d3.interpolate({ x: d.xo, dx : d.dxo, y: d.yo, dy: d.dyo }, d);
			return i ?
				function(t) {
					return hide ? arc(ip(t)) : arc(d);
				} :
				function(t) {
					// set the updated domains for each step
					x.domain(xd(t));
					y.domain(yd(t)).range(yr(t));
					return hide ? arc(ip(t)) : arc(d);
				};
		};
	};

	/**
	 * Update the fill colors for all paths based on the current state
	 * @private
	 */
	sunburst._updatePathColors = function() {
		var self = this, adapter = this._dataAdapter, hidden = this._getHiddenNodes(),
			container = d3.select(this._options.parent).selectAll('.sunburst-cv'),
			highlighted = container.classed('node-highlighted');
		this._paths.style('fill', function(d) {
			var path = d3.select(this),
				gray = highlighted && (!path.classed('highlighted'));
			return self.getNodeColor(d, gray);
		}).classed('hidden', function(d) {
			return hidden.indexOf(d) >= 0;
		});
	};

	/**
	 * Lock in the highlight/details for a node with type: path, category, item
	 * A type 'path' is the node as it relates to its parents in the data structure
	 * A type 'category' is the category obj as it relates to all nodes at that depth
	 * A type 'item' is the node as it relates to all other nodes with the same name
	 * @param {object} node obj with data and type
	 * @private
	 */
	sunburst._lockNode = function(node) {
		var self = this, options = self._options,
			locked = self._lockedNode;

		if (locked && locked.data === node.data && locked.type === node.type) {
			// toggle
			return self._unlockNode(node);
		}
		self._lockedNode = node;
		self._highlightNode(node);
		self._updateLockedState(node);
		setTimeout(function() {
			d3.select(self._options.parent).select('.sunburst-cv-wrapper')
				.on('click.cvpath', function() {
					// ignore clicking on the paths in the svg
					if (d3.event && d3.event.target && d3.event.target.nodeName === 'path') { return; }
					self._unlockNode();
				});
		}, 10);
	};

	/**
	 * Remove the lock on a node for its highlights/details
	 * @param {object} node data obj with type
	 * @private
	 */
	sunburst._unlockNode = function(node) {
		var self = this, options = self._options;
		self._lockedNode = null;
		self._updateLockedState();
		if (node && !self._isTouch()) { // only highlight if they can hover off to unhighlight it
			self._highlightNode(node);
		} else {
			self._unhighlightNode();
		}
		d3.select(self._options.parent).select('.sunburst-cv-container')
			.on('click.cvpath', null);
	};

	/**
	 * Update the sunburst to color the node and its relations based on type
	 * Update the node details as well
	 * @param {object} node data obj with type
	 * @private
	 */
	sunburst._highlightNode = function(d) {
		// Get the segment path, may not be needed by lets do it only once
		var self = this, type = d && d.type || 'path', node = d && d.data || null,
			nodes = this._getAncestorNodes(node), methods = {}; // default to path

		// Highlight all nodes on the category depth
		methods.category = function(n) {
			return n.depth === node.index + 1;
		};
		// Highlight all nodes of the same name
		methods.item = function(n) {
			return n && node && n.name === node.name;
		};
		// Highlight all nodes in the path and the children of d
		methods.path = function(n) {
			return nodes.indexOf(n) >= 0 || (self._lockedNode && n.parent === node);
		};

		// Fade all the segments.
		var container = d3.select(this._options.parent).selectAll('.sunburst-cv');
		container.classed('node-highlighted', true);

		// Highlight based on type
		container.selectAll('.sunburst-cv-container').selectAll('path').each(function(n) {
			d3.select(this).classed('highlighted', methods[type](n));
		});

		// Highlight categories
		if (!self._lockedNode) {
			container.selectAll('.info-pane-category').each(function(c) {
				// hovering
				d3.select(this).classed('disabled', 'category' === type && c !== node);
			});
		}

		this._updateDetails(d);
		this._updatePathColors();
	};

	/**
	 * Remove the highlights for the node and update details accordingly
	 * @private
	 */
	sunburst._unhighlightNode = function() {
		this._removeHighlights();
		this._updateDetails();
	};

	/**
	 * Unhighlight all paths
	 * @private
	 */
	sunburst._removeHighlights = function() {
		var container = d3.select(this._options.parent);
		// Transition each segment to full opacity and then reactivate it.
		container
			.selectAll('.sunburst-cv').classed('node-highlighted', false)
			.selectAll('path').classed('highlighted', false);
		// Highlight categories
		container
			.selectAll('.info-pane-category').classed('disabled', false);
		this._updatePathColors();
	};

	/**
	 * User has modified the active secondary metric or which visualization is being used
	 * Redraw the sunburst and update the right rail
	 * @private
	 */
	sunburst._secondaryMetricChanged = function() {
		var self = this, adapter = this._dataAdapter,
			l10n =  adapter.l10n.labels.sunburst,
			m = adapter.getSecondaryMetricIndex();
		// reset slider or remove
		self._outRangeNodes = [];
		if (m) {
			// remove invalids
			self._hidePath(adapter.data(), self._invalidNodes, function(d) { return self._isInvalidNode(d); });
			// hide path will call layoutPaths for us
		} else {
			self._invalidNodes = [];
			// rerun the partition
			self._layoutPaths(true);
		}
		// update classes
		var container = d3.select(this._options.parent);
		container.selectAll('.sunburst-cv').classed('secondary-metric', !!m);
		var secondary = container.selectAll('.sunburst-cv-sec-viz');
		secondary.selectAll('.button').classed('active', false);
		var type = adapter.getSecondaryMetricType();
		if (type) {
			secondary.selectAll('.button.'+type).classed('active', true);
		}
		var metric = adapter.getSecondaryMetric(),
			name = metric && metric.name || null;
		secondary.selectAll('.title').html(name ? l10n['mapmetric'].replace(/\{metric\}/i, name) : '');

		// update the details
		this._updateDetails(this._lockedNode);
		// fire event
		this._updateMetricState();
	};


	/**
	 * Based on the data path object that is passed, display either the details about that object
	 * or if not present, display the general chart information based on the chart state
	 * @param {object} data
	 * @private
	 */
	sunburst._updateDetails = function(d) {
		// don't update for item
		if (d && d.type === 'item') { return; }

		// update chart/details
		this._setChartMetrics(d);
		this._setDetailsMetrics(d);
		this._setDetailsAudiences(d);
		this._setDetailsCategories(d);
		this._setDetailsActions(d);
	};


	/**
	 * Update the categories list in the info pane
	 * @param {object} data
	 * @private
	 */
	sunburst._setDetailsCategories = function(d) {
		var self = this, adapter = this._dataAdapter,
			l10n =  adapter.l10n.labels.sunburst,
			data = adapter.data(), categories = adapter.categories(),
			pane = d3.select(this._options.parent).select('.info-pane-categories'),
			zoomDepth = Math.max(0, self._zoomedPath ? self._zoomedPath.depth - 1 : 0),
			list = d && d.type === 'path' && self._lockedNode ? [] : categories.slice(zoomDepth),
			numCats = list.length, node = d || {},
			categoryLabel = pane.selectAll('.info-pane-category').data(list),
			categoryEnter = categoryLabel.enter().append('div').classed('info-pane-category', true).classed('inactive', true);
		pane.select('.pane-title').select('span').text((1 === numCats.length) ? l10n['category'] : l10n['category2+'] );
		categoryLabel.each(function(d, i) {
			var label = d3.select(this);
			label.text(''); // clear
			self._createRingMarker(label, numCats, i);
			label.append('span').classed('name', true).html(d && d.name || '');
			label.append('span').classed('top', true)
				.html('(' + l10n['topresults'].replace(/\{value\}/i, d.top) + ')');
			if (node.type === 'path') {
				label.classed('disabled', !self._lockedNode &&
					node.data && node.data.depth - 1 !== i - zoomDepth);
			} else if (self._lockedNode && self._lockedNode.type === 'category') {
				label.classed('disabled', d !== self._lockedNode.data);
			}
		});
		setTimeout(function() {
			categoryEnter.classed('inactive', false);
		}, 1);
		var categoryExit = categoryLabel.exit().classed('inactive', true)
			.on('mouseenter', null).on('mouseleave', null).on('click', null);
		setTimeout(function() {
			categoryExit.remove();
		}, 400);
		categoryLabel.on('mouseenter', function(d, i) {
			if (self._lockedNode || self._isTouch()) { return; }
			self._highlightNode({ data:d, type:'category' });
		});
		categoryLabel.on('mouseleave', function(d, i) {
			if (self._lockedNode || self._isTouch()) { return; }
			self._unhighlightNode();
		});
		categoryLabel.on('click', function(d, i) {
			self._lockNode({ data:d, type:'category' });
		});
		pane.classed('empty', !list.length);
	};

	/**
	 * Update the audiences list in the info pane and chart label
	 * If no array is passed, clear out the list
	 * @param {array} data obj
	 * @private
	 */
	sunburst._setDetailsAudiences = function(d) {
		// Update the audience
		var self = this, adapter = this._dataAdapter,
			type = d && d.type || '', node = d && d.data || null,
			isCategory = type === 'category', data = adapter.data(),
			nodes = isCategory ? this._getLevelUniqueNodes(data, node.index + 1, false) :
				this._getAncestorNodes(node),
			dataKey = isCategory ? function(d, i) { return i; } :
				function(d, i) { return d && d.depth || 0; },
			categories = adapter.categories(),
			container = d3.select(this._options.parent).selectAll('.sunburst-audiences'),
			endNode = nodes && nodes[0] || data,
			pathIsMetric = data === endNode,
			nodesList = (!nodes || pathIsMetric) ? [] : nodes.slice();

		// Loop over all audience panes for sunburst
		container.each(function(d) {
			var pane = d3.select(this), list = nodesList.slice();
			// Audiences within the center label are different in that they:
			// - display the audience with the most specific audience first
			// - height is static, so no need to set it
			var isCenterLabel = d3.select(pane.node().parentNode).classed('sunburst-cv-label-wrap');

			// path data needs to be reversed but only for right side
			if (!isCategory && !isCenterLabel) {
				if (!self._lockedNode) { list = []; } // don't show audience when hover on path
				list.reverse();
			}
			else if (isCategory && isCenterLabel) { list = []; } // don't show category list

			// Create audience list, remove if empty
			var audienceLabel = pane.selectAll('.sunburst-audience').data(list, dataKey),
				audienceEnter = audienceLabel.enter().append('span').classed('sunburst-audience', true).classed('inactive', true);
			audienceEnter.append('span').classed('marker', true).style('background-color', '#dcdcdc');
			audienceEnter.append('span').classed('category', true);
			audienceEnter.append('span').classed('name', true);
			audienceLabel.each(function(d, i) {
				var label = d3.select(this), category = categories[d.depth - 1];
				label.select('.marker').style('background-color', self.getNodeColor(d));
				label.select('.category').classed('hidden', isCategory || isCenterLabel).text(!isCategory && category && category.name || '');
				label.select('.name').text(d.name);
				label.classed('to-remove', false).attr('my-name', d.name).attr('my-depth', d.depth);
				label.on('mouseenter', function(d, i) {
					if (self._isTouch()) { return; }
					self._highlightNode({ data: d, type: 'item'});
				});
				label.on('mouseleave', function(d, i) {
					if (self._isTouch()) { return; }
					if (self._lockedNode) {
						self._highlightNode(self._lockedNode);
					} else {
						self._unhighlightNode();
					}
				});
				if (isCenterLabel) { return; } // no need to scale height, locked at 1 line

				// clone it and get the actual height without affecting the node
				var clone = d3.select(label.node().cloneNode(true)).style('height', '')
					.classed('test', true).classed('inactive', false);
				pane.node().appendChild(clone.node());
				label.attr('my-height', parseInt(clone.style('height'), 10));
				clone.remove();
			});
			audienceLabel.order();
			setTimeout(function() {
				audienceLabel.each(function(d, i) {
					var label = d3.select(this);
					label.classed('inactive', false);
					if (isCenterLabel) { return; } // no need to set height
					label.style('height', label.attr('my-height') + 'px');
				});
			}, 1);
			var audienceExit = audienceLabel.exit().classed('inactive', true).style('height', '')
				.classed('to-remove', true).on('mouseenter', null).on('mouseleave', null).on('click', null);
			setTimeout(function() {
				audienceExit.each(function(d, i) {
					var exitLabel = d3.select(this);
					if (exitLabel.classed('to-remove')) { exitLabel.remove(); }
				});
			}, 400);
			pane.classed('empty', !list.length);
		});
	};

	/**
	 * Update the actions panel
	 * Allow for integrator to throw actions in as well
	 * @private
	 */
	sunburst._setDetailsActions = function(d) {
		var self = this, adapter = this._dataAdapter,
			data = adapter.data(),
			pane = d3.select(this._options.parent).select('.info-pane-actions');

		// Setup the two columns, one for chart interactions, other for integrator options
		var chartActions = pane.selectAll('.info-pane-actions-chart').data([0]);
		chartActions.enter().append('div').classed('info-pane-actions-chart', true).classed('info-pane-actions-pane', true);
		var extraActions = pane.selectAll('.info-pane-actions-extra').data([0]);
		extraActions.enter().append('div').classed('info-pane-actions-extra', true).classed('info-pane-actions-pane', true);

		// Handlers
		function zoomin() { self._zoomPath(self._lockedNode.data); }
		function zoomout() { self._zoomPath(data); }
		function hide() { self._hidePath(self._lockedNode.data, self._hiddenNodes); }
		function hideall() {
			// hide the locked path and all of other nodes with the same name
			var node = self._lockedNode.data, hidden = self._hiddenNodes;
			if (!node) { return; } // something wrong, we shouldn't have this option if not a locked path
			self._hidePath(data, hidden, function(d) {
					return d.name === node.name || hidden.indexOf(d.parent) >= 0;
				});
			}

		// Compile the chart actions
		var actions = [], // array of obj with label and icon
			l10n =  adapter.l10n.labels.sunburst;
		// If d is passed, we need to show either hover or click options
		if (d && d.type === 'path' && self._lockedNode) {
			// Add options info if locked, otherwise show help info
			var node = d.data, allowedZoom = self._canZoomIn(node),
				pathIsMetric = node === data;
			if (!self._lockedNode) {
				// hover
				if (!pathIsMetric) {
					actions.push( { click: false, icon: 'more', label: l10n.moreAction });
				}
				if (allowedZoom) {
					actions.push( { click: false, icon: 'zoomin', label: l10n.zoomAction });
				}
			} else if (!pathIsMetric) {
				// click
				if (allowedZoom) {
					actions.push( { click: zoomin, className:'zoomin', icon: 'zoomin', label: l10n.zoomin }); }
				else if (self._canZoomOut(node)) {
					actions.push( { click: zoomout, className:'zoomout', icon: 'zoomout', label: l10n.zoomout });
				}
				actions.push( { click: hide, className:'hide', icon: 'hide', label: l10n.hide });
				actions.push( { click: hideall, className:'hideallname', icon: 'hide', label: l10n.hideall });
			}
		}
		// allow full width if only one is showing options
		var extras = self._getExtraActions(d),
			ap = !!actions.length, ep = !!extras.length;
		pane.classed('full-width', (!ap && ep) || (!ep && ap));
		pane.classed('empty', (!ap && !ep));

		// build chart options
		self._buildActionsPane(chartActions, actions);
		// build extra options
		self._buildActionsPane(extraActions, extras);

		// update hover on hideall
		var hidename = pane.selectAll('.hideallname');
		hidename.on('mouseenter', function() {
			if (self._isTouch()) { return; }
			self._highlightNode({ data: self._lockedNode.data, type: 'item'});
		});
		hidename.on('mouseleave', function(d, i) {
			if (self._isTouch()) { return; }
			if (self._lockedNode) {
				self._highlightNode(self._lockedNode);
			} else {
				self._unhighlightNode();
			}
		});
	};

	/**
	 * Adds actions as quiet buttons to actions pane
	 * @param {element} d3 dom element
	 * @param {array} array of objs to create action buttons
	 * @returns {boolean} true if contains content
	 * @private
	 */
	sunburst._buildActionsPane = function(container, actions) {
		var actionButtons = container.selectAll('.info-pane-action').data(actions);
		var actionEnter = actionButtons.enter().append('a').classed('info-pane-action', true).classed('inactive', true);
		actionEnter.append('i').classed('icon', true);
		actionEnter.append('span');
		actionButtons.each(function(d, i) {
			var btn = d3.select(this);
			btn.select('.icon').attr('class', 'icon').classed(d.icon, true);
			btn.select('span').text(d.label);
			btn.attr('class', 'info-pane-action' +
				(btn.classed('inactive') ? ' inactive' : '') +
				(d.click || d.href ? ' action' : ' help'));
			if (d.click) { btn.on('click', d.click); }
			else { btn.on('click', null); }
			if (d.href) { btn.attr('href', d.href); }
			else { btn.attr('href', null); }
			if (d.className) { btn.classed(d.className, true); }

			// clone it and get the actual height without affecting the node
			var clone = d3.select(btn.node().cloneNode(true)).style('height', '')
				.classed('test', true).classed('inactive', false);
			container.node().appendChild(clone.node());
			btn.attr('my-height', parseInt(clone.style('height'), 10));
			clone.remove();
		});
		setTimeout(function() {
			actionButtons.each(function(d, i) {
				var btn = d3.select(this);
				btn.style('height', btn.attr('my-height') + 'px').classed('inactive', false);
			});
		}, 1);
		var actionExit = actionButtons.exit().classed('inactive', true).style('height', '')
			.classed('to-remove', true).on('click', null);
		setTimeout(function() {
			actionExit.each(function(d, i) {
				var exitAction = d3.select(this);
				if (exitAction.classed('to-remove')) { exitAction.remove(); }
			});
		}, 400);

		return !!actions.length;
	};

	/**
	 * Update the metrics labels at the top of the info pane
	 * @param {object} path data obj
	 * @private
	 */
	sunburst._setDetailsMetrics = function(d) {
		var self = this,
			container = d3.select(this._options.parent).select('.info-pane-metrics'),
			plabels = container.select('.pri-metric-labels'),
			slabels = container.select('.sec-metrics-labels'),
			chart = container.select('.info-pane-metrics-chart'),
			adapter = this._dataAdapter, data = adapter.data(),
			pmetric = data.metrics.slice(0,1),
			smetrics = data.metrics.slice(1),
			categories = adapter.categories(),
			l10n = adapter.l10n.labels.sunburst,
			pathNode = d && d.type === 'path' ? d.data : null,
			node = pathNode || data,
			hasChildren = pathNode && pathNode.children && pathNode.children.length && this._lockedNode;

		container.classed('total', !hasChildren);
		container.selectAll('.pane-title').each(function(d, i) {
			var title = d3.select(this),
				label = title.select('span');
			if (title.classed('pri-metric')) { return label.text(l10n['primarymetric']); }
			if (title.classed('sec-metric')) {
				title.classed('hidden', !smetrics.length);
				return label.text(!smetrics.length ? '' :
					(smetrics.length === 1) ? l10n['secondarymetric'] : l10n['secondarymetric2+']);
			}
			if (title.classed('rank-chart')) {
				label.text((hasChildren) ? categories[pathNode.depth] && categories[pathNode.depth].name : '');
			}
		});
		container.selectAll('.sec-metrics-help').each(function(d, i) {
			d3.select(this).text(smetrics.length === 1 ? l10n['secondarymetrichelp'] : l10n['secondarymetrichelp2+'])
				.classed('hidden', !smetrics.length);
		});
		this._setNodeMetricLabels(plabels, node, pmetric, !!pathNode);
		this._setNodeMetricLabels(slabels, node, smetrics, !!pathNode);
		this._setNodeMetricChart(chart, this._lockedNode ? pathNode : null);
	};

	/**
	 * Update the label that is centered in the sunburst
	 * @param {object} data obj
	 * @private
	 */
	sunburst._setChartMetrics = function(d) {
		var chartLabel = d3.select(this._options.parent).select('.sunburst-cv-label-wrap'),
			data = this._dataAdapter.data(), metrics = data.metrics.slice(),
			node = d && d.type === 'path' ? d.data : data;
		// Limit the center chart label to the top metric
		if (metrics.length > 1) { metrics.length = 1; }
		this._setNodeMetricLabels(chartLabel, node, metrics, false);
	};

	/**
	 * Show labels for all passed metrics for the specific node
	 * @param {element} D3 DOM element
	 * @param {object} path data obj
	 * @param {array} list of metrics for data obj
	 * @param {boolean} show marker
	 * @private
	 */
	sunburst._setNodeMetricLabels = function(container, node, metrics, marker) {
		var self = this, adapter = this._dataAdapter, data = adapter.data(),
			l10n = adapter.l10n.labels.sunburst,
			primary = container.classed('pri-metric-labels') || container.classed('sunburst-cv-label-wrap'),
			metricLabel = container.selectAll('.sunburst-cv-label-metric').data(metrics),
			metricEntry = metricLabel.enter().append('div').classed('sunburst-cv-label-metric', true);
		// remove marker if no children to graph
		marker = (node && node.children && node.children.length && this._lockedNode) ? marker : false;
		metricLabel.each(function(metric, i) {
			var label = d3.select(this),
				value = self.getNodeValue(node, primary ? i : i + 1),
				total = self.getNodeValue(data, primary ? i : i + 1),
				isPercent = 'percent' === metric.format,
				isInvalid = (adapter.isOther(node) && !primary ) || (0 === total),
				percent = isPercent ? value : value / self.getNodeValue(data, primary ? i : i + 1),
				activeLabel = primary || (i + 1) === adapter.getSecondaryMetricIndex(),
				hasMarker = marker && activeLabel,
				hasTotalPercent = null !== value && !isPercent && !isInvalid && node !== data;
			// fill in
			label.classed('active', activeLabel);
			// icon
			var icon = label.selectAll('.sunburst-cv-label-icon').data([metric]);
			icon.enter().append('i');
			icon.each(function(d) {
				d3.select(this).attr('class', 'sunburst-cv-label-icon icon') // reset
					.classed(metric.icon || (primary ? 'donut' : 'stack'), true);
			});
			// value
			var number = label.selectAll('.sunburst-cv-label-number').data([metric]);
			number.enter().append('span').classed('sunburst-cv-label-number', true);
			number.html(isInvalid ? '' : self._formatValue(metric, value))
				.classed('hidden', isInvalid);
			// name with percent (if needed)
			var name = label.selectAll('.sunburst-cv-label-name').data([metric]);
			name.enter().append('span').classed('sunburst-cv-label-name', true).append('span');
			name.select('span').html(hasTotalPercent ?
				l10n.percmetric.replace(/\{percent\}/i, self._formatNumber('percent', percent))
					.replace(/\{metric\}/i, metric.name)
				: metric.name);
			// marker
			var masknum = self.getMetricMaskNum(primary ? i : i + 1);
			var svg = name.selectAll('.sunburst-cv-label-marker').data([metric]);
			svg.enter().insert('svg', ':first-child').classed('sunburst-cv-label-marker', true)
				.append('rect').attr('width', 12).attr('height', 12);
			svg.classed('hidden', !hasMarker)
				.select('rect').attr('style', (null === masknum) ? '' : 'mask: url(#diagmask'+ masknum+');');
				label.on('click', primary ? null : function() {
				adapter.setSecondaryMetricIndex(i + 1);
				self._secondaryMetricChanged();
			});
		});
		metricLabel.exit().remove();
	};

	/**
	 * Wrap the core _formatNumber function to handle time
	 * @param {object} metric
	 * @param {number} value
	 * @private
	 */
	sunburst._formatValue = function(metric, value, abbr) {
		if ('time' !== metric.format) { return this._formatNumber(metric.format, value); }
		var v = value, adapter = this._dataAdapter,
			l10n = abbr ? adapter.l10n.time.abbreviation : (1 === v) ?
				adapter.l10n.time.singular : adapter.l10n.time.plural,
			time = adapter.getTimeGranularity(v, true);

		return this._formatNumber(metric.format, v / time.divisor) + ' ' + l10n[time.gran];
	};

	/**
	 * Creates a horizontal bar chart for the specific node's children for the passed metrics
	 * @param {element} DOM element to insert the chart into
	 * @param {object} data obj
	 * @private
	 */
	sunburst._setNodeMetricChart = function(container, node) {
		var self = this, adapter = this._dataAdapter,
			data = adapter.data(),
			hidden = self._getHiddenNodes(),
			children = node && node.children || [],
			visible = children.filter(function(c) {
				return hidden.indexOf(c) < 0;
			}),
			x = [], y = [], fill = [], metric = [], nodes = [], format = [],
			barData = { x:x, y:y, fill:fill, metric:metric, format:format, node:nodes };

		function validMetric(m, i) {
			return 0 === i || i === adapter.getSecondaryMetricIndex();
		}

		var metrics = data.metrics.slice(),
			valid = metrics.filter(validMetric),
			uniqs = valid.map(function(m) { return m.name; });

		// Fill in bar data
		// reverse to compensate for flip reversing our nodes
		visible.reverse().forEach(function(n) {
			var value;
			// create an entry for each valid metric value
			metrics.forEach(function(m, i) {
				if (!validMetric(m, i)) { return; }
				if (null !== (value = self.getNodeValue(n, i))) {
					y.push(value);
					x.push(n.name);
					fill.push(m.name);
					metric.push(m.name);
					format.push(m.format);
					nodes.push(n);
				}
			});
		});

		var hasContent = !!y.length;

		var paneSVG = container.selectAll('.info-pane-chart-svg').data([0]);
		paneSVG.enter().append('div').classed('info-pane-chart-svg', true);
		paneSVG.exit().remove();
		container.classed('hidden', !hasContent);

		// Create bar chart
		if (hasContent) {

			var barHeight = 15,
				groupPadding = 25,
				dodgeSpacing = 0.05, // percentage of the height
				numInGroup = valid.length,
				numOfGroup = visible.length,
				groupHeight = (numInGroup * barHeight) + groupPadding,
				groupSpacing = groupPadding / groupHeight,
				// 2 * to compensate for 0.5 padding between each group
				chartHeight = Math.ceil((numInGroup * numOfGroup * barHeight) / (1 - groupSpacing));

			// Set height of the div
			paneSVG.style('height', chartHeight + 'px');
			var chart = dv.chart()
				.layers([
					dv.geom.bar()
						.map('group', 'fill')
						.set('fill', function(d, i) {
							return self.getNodeColor(d.data.node);
						})
						.each('start', function(d, i) {
							var masknum = self.getMetricMaskNum(uniqs.indexOf(d.data.metric));
							d3.select(this).attr('mask', (null === masknum) ? '' : 'url(#diagmask'+masknum+')');
						})
						.on('click', function(d) { self._selectChildFromRanked(d); } )
						.dodgePadding(dodgeSpacing),
					dv.geom.text()
						.map('label', 'y')
						.map('group', 'fill')
						.set('fill', '#4b4b4b')
						.textFormat(function(d, i) {
							return d ? self._formatValue({ format: this.__data__.data.format }, d, true) : '';
						})
						.textAnchor('start').set('fill', '#4b4b4b').dx(4).dy(5)
						.on('click', function(d) { self._selectChildFromRanked(d); } )
				])
				.coord(dv.coord.cartesian().flip(true))
				.data(barData)
				.position('dodge')
				.guide('x', dv.guide.axis()
					.tickDx(function(d, i) {
						return d3.select(this).select('span').node().offsetWidth;
					})
					.tickDy(function(d, i) {
						return ((-numInGroup * barHeight) / 2) -
							(d3.select(this).select('span').node().offsetHeight / 2);
					})
					.tickSize(0)
					.tickAnchor('end'))
				.guide('y', dv.guide.axis().ticks(0).tickSize(0).tickFormat(function(d, i) { return ''; }))
				.map('x', 'x', dv.scale.ordinal().padding(groupSpacing))
				.width('100%')
				.height(chartHeight)
				.duration(400)
				.padding({top: 2, right : 65}) // CV-542: cropping on some FF browsers on top with JP chars
				.parent(paneSVG.node());

			// Train each metric on its own scale
			uniqs.forEach(function(g, index) {
				var scale = dv.scale.linear().lowerLimit(0);
				scale.includeInDomain(function(d, i) {
					return d.data['metric'] === uniqs[index];
				});
				chart.map('y', 'y', scale, index);
			});
			chart.render();


			// Patterning for metrics
			var group = paneSVG.select('svg').selectAll('defs').data([0]);
			group.enter().append('defs');

			var patterns = [45]; //[45, 135, 90, 0];
			var pattern = group.selectAll('pattern').data(patterns);
			var patternEnter = pattern.enter()
				.append('pattern')
					.attr('id', function(d, i) {
						return 'diag' + i;
					})
					.attr('patternUnits', 'userSpaceOnUse')
					.attr('width', '3').attr('height', '3')
					.attr('patternTransform', function(d, i) {
						return 'rotate('+d+' 2 2)';
					});
			// Rect allows for the entire background to come through
			patternEnter.append('rect').attr('x', '0').attr('y', '0').attr('width', '3').attr('height', '3').attr('style', 'fill:#fff;');
			// Path is then repeated to fade out some lines
			patternEnter.append('path').attr('d', 'M -1,0 l 10,0').attr('style', 'stroke:#222; fill:none; stroke-width: 3px;');

			var mask = group.selectAll('mask').data(patterns);
			mask.enter()
				.append('mask')
					.attr('id', function(d, i) {
						return 'diagmask' + i;
					})
					.attr('x', '0').attr('y', '0')
				.append('rect')
					.attr('x', '0').attr('y', '0')
					.attr('width', '100%').attr('height', '1')
					.attr('style', function(d, i) {
						return 'stroke:none; fill:url(#diag'+i+')';
					});

			// update mask height
			group.selectAll('mask').selectAll('rect').attr('height', chartHeight);

		} else {
			paneSVG.style('height', '0px');
		}
	};

	/**
	 * Take a data object from the ranked bar chart and determine if its a child of the locked path
	 * If it is, based on name, lock that child path obj
	 * @param {array} dv data obj
	 * @private
	 */
	sunburst._selectChildFromRanked = function(d) {
		var locked = this._lockedNode.data, name = d.data.x;
		if (!locked || !locked.children || !locked.children.length) { return; }
		var i, ii=locked.children.length, child, selected = null;
		for (i=0; i<ii; ++i) {
			if ((child = locked.children[i]).name === name) {
				selected = child;
				break;
			}
		}
		if (selected) {
			this._lockNode( { data: selected, type: 'path' });
		}
	};

	/**
	 * Creates a SVG representation of the sunburst to highlight a ring
	 * @param {element} DOM element to insert the SVG to
	 * @param {number} number of rings in the SVG
	 * @param {highlighted} the ring to highlight
	 * @private
	 */
	sunburst._createRingMarker = function(container, num, highlighted) {
		var svg = container.append('svg').classed('category-ring', true),
			g = svg.append('g').attr('transform', 'translate(12,12)'),
			width = parseInt(svg.style('width'), 10), radius = width / 2,
			lineWidth = 2, lineGap = 1,
			center = radius - (lineWidth * num) - (lineGap * (num - 1)),
			inner, outer, i;
		for (i=0; i<num; ++i) {
			inner = center + ((lineWidth + lineGap) * i);
			outer = inner + lineWidth;
			g.append('path')
				.classed('active', i === highlighted)
				.attr('d', d3.svg.arc()
					    .innerRadius(inner)
					    .outerRadius(outer)
					    .startAngle(0)
					    .endAngle(2 * Math.PI));
		}
	};

	/**
	 * If the path data object is allowed to zoom in
	 * @param {object} path data obj
	 * @returns {boolean}
	 * @private
	 */
	sunburst._canZoomIn = function(d) {
		var metric = this._dataAdapter.data(),
			zPath = this._zoomedPath;
		//return d.children && d.children.length &&
			// Non metric that is not currently zoomed
		return (d !== metric && d !== zPath) ||
			// Metric but another path is zoomed
			(d === metric && metric !== zPath && !!zPath);
	};

	/**
	 * If the path data object is allowed to zoom out
	 * @param {object} path data obj
	 * @returns {boolean}
	 * @private
	 */
	sunburst._canZoomOut = function(d) {
		return d === this._zoomedPath;
	};

	/**
	 * Returns a list of ancestor nodes that have a parent, including d
	 * If d doesn't have any parents, will return just d
	 * @param {object} data
	 * @returns {array} list of nodes
	 * @private
	 */
	sunburst._getAncestorNodes = function(d) {
		var path = [], current = d;
		if (!d) { return path; }
		while (current.parent) {
			path.push(current);
			current = current.parent;
		}
		if (!path.length) { path = [d]; }
		return path;
	};

	/**
	 * Returns true if passed data object has node as an ancestor
	 * returns false otherwise
	 * @param {object} data node
	 * @param {object} ancestor node
	 * @returns {bool} true if data node contains ancestor node
	 * @private
	 */
	sunburst._hasAncestorNode = function(d, node) {
		if (!d || !node || d.depth < node.depth || d === node) { return false; }
		var current = d;
		while (current.parent) {
			if (current.parent === node) { return true; }
			current = current.parent;
		}
		return false;
	};

	/**
	 * Determines height of pane based on direct children height/padding
	 * @param {elem} d3 element
	 * @returns {number} calculated height
	 * @private
	 */
	sunburst._getInfoPaneHeight = function(pane) {
		var height = 0, node;
		d3.selectAll(pane.node().childNodes).each(function(n, i) {
			node = d3.select(this);
			height += parseInt(node.style('height'), 10) +
						parseInt(node.style('padding-bottom'), 10) +
						parseInt(node.style('padding-top'), 10);
		});
		return height;
	};

	/**
	 * Informs of the current locked state with node
	 * @param {object} data object if one is selected
	 * @private
	 */
	sunburst._updateLockedState = function(d) {
		var self = this;
		if (self._eventMap['sunburst.locked']) {
			self._eventMap['sunburst.locked'].call(this, d, self._dataAdapter.data());
		}
	};

	/**
	 * Informs of the current secondary metric
	 * @private
	 */
	sunburst._updateMetricState = function() {
		var self = this, adapter = self._dataAdapter;
		if (self._eventMap['sunburst.metric']) {
			self._eventMap['sunburst.metric'].call(this, adapter.getSecondaryMetricIndex(),
				adapter.getSecondaryMetricType() ,adapter.data());
		}
	};

	/**
	 * Calls actions handler to see if we should populate some actions
	 * @param {object} data object if one is selected
	 * @private
	 */
	sunburst._getExtraActions = function(d) {
		var self = this;
		if (self._eventMap['sunburst.actions']) {
			return self._eventMap['sunburst.actions'].call(this, d, !!this._lockedNode, self._dataAdapter.data());
		}
		return [];
	};

	/**
	 * Gets the numerical value of the path object
	 * This may or may not match the visual representation
	 * Use the metric index to get the correct metric value, otherwise..
	 * Use the size attribute, otherwise ...
	 * Use the computed sum of the children nodes
	 * Show the path objects details
	 * @param {object} path data obj
	 * @param {num} metric array index
	 * @private
	 */
	sunburst.getNodeValue = function(n, i) {
		if (!n) { return 0; }
		if (n.metrics && n.metrics.length && n.metrics[i] &&
			'undefined' !== typeof n.metrics[i].value) { return n.metrics[i].value; }
		if (i > 0) { return null; } // invalid value
		if ('undefined' !== typeof n.size) { return n.size; }
		return n.value;
	};

	/**
	 * Gets the category's minimum value and maximum value for a specific metric
	 * If no category index is passed, min/max for metric for all categories
	 * Will ignore nodes from the hidden list
	 * Recursively sorts through the nodes
	 * @param {number} metric index
	 * @param {number} category index or undefined
	 * @return {object} { min:val, max:val }
	 */
	sunburst.getMetricCategoryMinMax = function(mIndex, cIndex) {
		var o, self = this, adapter = this._dataAdapter, data = adapter.data(),
			hidden = this._getHiddenNodes(), zoomed = this._zoomedPath;
		function getMinMax(d) {
			if (zoomed && zoomed.depth === d.depth && zoomed !== d) { return; } // outside zoom
			// check if same level or if no level is set
			if ('undefined' === typeof cIndex || d.depth === cIndex + 1) { // depth is 1 based, categories are 0 based
				if (adapter.isOther(d)) { return; } // never count other
				if (hidden.indexOf(d) >= 0) { return; }
				var val = self.getNodeValue(d, mIndex);
				if ('undefined' === typeof o) {
					o = { min: val, max: val };
				} else {
					o.min = Math.min(o.min, val);
					o.max = Math.max(o.max, val);
				}
				if (cIndex) {
					return; // no need to go deeper
				}
			}
			if (!d.children || !d.children.length) { return; }
			// recursively update
			d.children.forEach(function(c) {
				getMinMax(c);
			});
		}
		getMinMax(data);
		return o || null;
	};

	/**
	 * Determines the correct hex color for the data object
	 * @param {object} data object
	 * @param {boolean} true if should be grayscaled
	 * @returns {string} hex color
	 */
	sunburst.getNodeColor = function(d, gray) {
		var adapter = this._dataAdapter, scale = this.getColorScale(d), color;
		// Handle metric, can't be grayscaled
		if (!d.depth) { return adapter.metricColor(); }
		// Handle other
		if (adapter.isOther(d)) { color = adapter.otherColor(); }
		// Handle sequential colors, inside and outside of range
		else if (adapter.getColorMetric()) {
			color = this.isOutsideRange(d) ? adapter.outRangeColor() : scale(d.metrics[adapter.getColorMetricIndex()].value);
		// Categorical coloring
		} else { color = scale(d.name); }
		// Grayscale color
		if (gray) { color = this._grayColor(color, d); }
		return color;
	};

	/**
	 * Get the grayscale color for the passed color
	 * @param {string} hex color '#ff0000'
	 * @param {object} data object
	 * @returns {string} gray hex color
	 * @private
	 */
	sunburst._grayColor = function(c, d) {
		var adapter = this._dataAdapter;
		if (adapter.isOther(d)) { return adapter.otherGrayColor(); }
		// convert hex to rgb
		var rhex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
			match = c && c.match(rhex);
		if (!match) { return c; } // not able to parse, return the same color
		var rgb = [parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16)],
			// using luminosity method of grayscale, which does an average but weights for human perception
			avg = Math.round((0.21 * rgb[0]) + (0.71 * rgb[1]) + (0.07 * rgb[2]));
		return '#' + ((1 << 24) + (avg << 16) + (avg << 8) + avg).toString(16).slice(1);
	};

	/**
	 * Get the index of the pattern to be used
	 * We only have one pattern, so if the metric index is > 0,
	 * then the pattern index is 0
	 * @param {number} metric index
	 * @returns {number} index inside patterns array
	 */
	sunburst.getMetricMaskNum = function(i) {
		return (i === 0) ? null : 0; // hardcoded to single pattern
	};

	/**
	 * Determine if the value for the color metric for the node is within the range
	 * @param {object} node data object
	 * @returns {boolean}
	 */
	sunburst.isOutsideRange = function(d) {
		var adapter = this._dataAdapter,
			metric = adapter.getColorMetric(),
			mIndex = adapter.getColorMetricIndex();
		if (!metric || !d || !d.metrics || 'percent' !== metric.format) { return false; }
		var val = d.metrics[mIndex].value;
		return val > this._colorExtentMax || val < this._colorExtentMin;
	};

	/**
	 * Get the correct color scale based on secondary metric and node
	 * @params {object} node object
	 * @returns {object} d3 scale
	 */
	sunburst.getColorScale = function(d) {
		var adapter = this._dataAdapter, metric;
		// categorical, only one scale
		if (!(metric = adapter.getColorMetric())) { return this._colorScale; }
		// rate, only one scale
		if ('percent' === metric.format) { return this._colorScale; }
		return this._categoryColorScales[d.depth - 1];
	};

	/**
	 * Creates a d3 scale for color based on the extent and max/min values
	 * @params {array} normally [0,1]
	 * @params {number} maximum value
	 * @params {number} minimum value
	 * @params {boolean} store the extent max/min for later use
	 * @returns {function} method to call to get value from scale
	 */
	sunburst._createColorScale = function(extent, max, min, rate) {
		var adapter = this._dataAdapter, colors = adapter.seqColors(),
			extentMin = ((max - min) * extent[0]) + min,
			extentMax = ((max - min) * extent[1]) + min,
			dif = extentMax - extentMin,
			div = colors.length - 1;

		if (rate) {
			this._colorExtent = extent;
			this._colorExtentMin = extentMin;
			this._colorExtentMax = extentMax;
		}

		var colorDomain = [extentMin];
		for (var i=1; i<div; ++i) { colorDomain.push(((dif/div)*i) + extentMin); }
		colorDomain.push(extentMax);
		return d3.scale.linear().domain(colorDomain).range(colors).clamp(true);

		// Log scaling of colors, commented out for now but we may make it an option
		/*var colorDomain = [extentMin],
			shiftDomain = [0.01];
		for (var i=1; i<div; ++i) {
			colorDomain.push(((dif/div)*i) + extentMin);
			shiftDomain.push(((1/div)*i) + 0.01);
		}
		colorDomain.push(extentMax);
		shiftDomain.push(1);
		// shift scale to a known linear scale, then apply log
		var linScale = d3.scale.linear().domain(colorDomain).range(shiftDomain).clamp(true),
			scale = d3.scale.log().domain(shiftDomain).range(colors);
		return function(d) {
			return scale(linScale(d));
		};*/
	};

	/**
	 * Set the color scale based on if there is a secondary metric for color
	 * as well as to what extent of the values should be shown
	 * @params {array} [0,1] or smaller if resizing
	 */
	sunburst.setColorScale = function(extent) {
		extent = extent || [0,1];
		var self = this, adapter = this._dataAdapter, data = adapter.data(), metric;
		// Categorical
		if (!(metric = adapter.getColorMetric())) {
			this._colorScale = d3.scale.ordinal().domain(adapter.uniques()).range(adapter.colors());
			return;
		}
		var index = adapter.getColorMetricIndex(), minMax;
		// Rate - same scale for all nodes
		if ('percent' === metric.format) {
			minMax = self.getMetricCategoryMinMax(index);
			this._colorScale = this._createColorScale(extent, minMax.max, minMax.min, true);
			return;
		}

		// Get min max for each category
		minMax = data.categories.map(function(c, i) {
			return self.getMetricCategoryMinMax(index, i);
		});
		this._categoryColorScales = minMax.map(function(o, i) {
				return self._createColorScale(extent, o.max, o.min, !i);
			});
		// overwrite min/max
		this._colorExtentMin = null;
		this._colorExtentMax = null;
	};

	global.cloudViz.sunburst = cloudViz.util.createConstructor(sunburst);
}(this));
/**
 * flower
 * The flower chart is designed to work similar to a spider web or radar chart.
 */

(function (global) {
	'use strict';

	// Standard creation code for a CloudViz chart
	var cloudViz = global.cloudViz || {}, core = cloudViz.core || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		flower = Object.create(core);

	flower.init = function(options) {
		this._type = 'flower';
		this._initDefaultOptions(); // merge in the options
		this.setOptions(options);
		this.colorScale = dv.scale.color()._d3Scale; // This seems very wrong.....
		return this;
	};

	flower._initDefaultOptions = function() {
		var defaults = {
				animationDuration: 500,          // Set to 0 to remove animation.
				labelFormatter: null,            // Function to format the labels. To hide the labels, use function(d){return "";}
				clickHandler : null,             // Function to call when a petal is clicked.
				onlyUseThreePetalLengths: true,  // Makes the petals length only be 1/3, 2/3 or full length.
				isEmotionChart: true,            // If set to true, use the default labels and colors for emotions.
				mouseoverCallback: [null, null], // Array of two functions to modify the mouseover and mouseout
				horizontalPadding: 70,           // Padding to allow for text. Set to 0 if you are hiding the labels.
				verticalPadding: 30,             // Padding to allow for text. Set to 0 if you are hiding the labels.
				text_offset: 5                   // Padding from the tip of the petal to the label.
			};
		return Object.getPrototypeOf(flower)._initDefaultOptions.call(this, defaults);
	};

	// Called if the autoResize option is set to true.
	flower._onAutoResize = function() {
		this._render();
	};

	// Just call render. Resizing is all handled in the render call.
	flower.resize = function() {
		this._render();
	};

	/**
	 * Resets the chart instance.  Called on both render and destroy.
	 **/
	flower.reset = function() {
		Object.getPrototypeOf(flower).reset.apply(this, arguments);
	};

	flower._preRender = function() {
		Object.getPrototypeOf(flower)._preRender.apply(this);
	};

	// Set up layers to keep the svg elements in the proper order.
	flower._setUpLayer = function(svg, key){
		this['layer' + key] = svg.selectAll('.flower-cv-svg-group-layer' + key).data([0]);
		this['layer' + key].enter().append('g').classed('flower-cv-svg-group-layer' + key, true);
	};

	flower.sprintf = function(s, d) {
		return s.replace(/\{([\w]+)\}/ig, function(a, b){
			return d[b];
		});
	};

	flower._render = function() {
		Object.getPrototypeOf(flower)._render.apply(this);
		var that = this;

		this._parent = d3.select(this._options.parent);

		var cv_wrapper = this._parent.selectAll('.cv-wrapper.cv-flower').data([0]);
		cv_wrapper.enter()
			.append('div')
			.classed('cv-wrapper cv-flower', true);

		var svg = cv_wrapper.selectAll('.flower-cv-svg').data([0]);
		svg.enter().append('svg').classed('flower-cv-svg', true);

		this._svg_group = svg.selectAll('.flower-cv-svg-group').data([0]);
		this._svg_group.enter().append('g').classed('flower-cv-svg-group', true);

		this._setUpLayer(this._svg_group, 1);
		this._setUpLayer(this._svg_group, 2);
		this._setUpLayer(this._svg_group, 3);
		this._setUpLayer(this._svg_group, 4);
		this._setUpLayer(this._svg_group, 5);
		this._setUpLayer(this._svg_group, 6);

		var width = this._options.width || parseInt(this._parent.style('width'), 10);
		var height = this._options.height || parseInt(this._parent.style('height'), 10);

		cv_wrapper
			.style('width', width + 'px')
			.style('height', height + 'px');

		var half_width = width / 2;
		var half_height = height / 2;

		this._svg_group.attr("transform", this.sprintf("translate({width},{height})",{width: half_width, height: half_height}));

		var data = that._dataAdapter.data();
		var possible_width = half_width - this._options.horizontalPadding;
		var possible_height = half_height - this._options.verticalPadding;
		var labelFormatter = this._options.labelFormatter || function(labels){
			labels.append('tspan')
					.attr('class','flower-cv-petal-label')
					.text(function(d){return d.label + ' ';});
			labels.append('tspan')
					.attr('class','flower-cv-petal-label-value')
					.text(function(d){return that._formatNumber('percent', d.value / that._total, 0);});
		};
		var mouseoverCallback = this._options.mouseoverCallback[0] || function() {d3.select(this).attr('opacity', 1); };
		var mouseoutCallback = this._options.mouseoverCallback[1] || function(d) {d3.select(this).attr('opacity', d.petal_opacity).attr('fill', d.petal_color);};

		this._is_single_mode = this._options.onlyUseThreePetalLengths;
		this._petal_size = Math.min(possible_width, possible_height);
		this._circle_size = this._petal_size * 0.676 / 2;
		this._arc_thickness = this._petal_size * 0.027;
		this._arc_half_angle = 360 / data.length / 2 + 0.5;
		this._petal_count = data.length;

		var getTextSizeScale = d3.scale.linear()
			.domain([55, 185])
			.range([9, 12])
			.clamp(true);

		this._font_size = getTextSizeScale(this._petal_size);

		var text_offsets = [
			{offset_y: 1,    fixed_offset_y: 0,    offset_x: 0,    location: 'middle'}, // top
			{offset_y: 1,    fixed_offset_y: 0,    offset_x: -1.5, location: 'middle'}, // tr
			{offset_y: 0,    fixed_offset_y: -2.5, offset_x: -0.8, location: 'start'}, // r
			{offset_y: -1,   fixed_offset_y: -9,   offset_x: -1.5, location: 'middle'}, // br
			{offset_y: -1,   fixed_offset_y: -9,   offset_x: 0,    location: 'middle'}, // b
			{offset_y: -1,   fixed_offset_y: -9,   offset_x: 1.5,  location: 'middle'}, // bl
			{offset_y: 0,    fixed_offset_y: -2.5, offset_x: 0.8,  location: 'end'}, // l
			{offset_y: 1,    fixed_offset_y: 0,    offset_x: 1.5,  location: 'middle'} // tl
		];

		this._total = d3.sum(data, function(d){return d.value;});

		var getAngleScale = d3.scale.linear()
			.domain([0, data.length])
			.range([0, 360]);

		this._getTextOffsetIndex = d3.scale.linear()
			.domain([0, 360])
			.rangeRound([0, 8])
			.clamp(true);

		this._getSizeZeroToThree = d3.scale.linear()
			.domain([0, d3.max(data, function (d) {
				return d.value;
			})])
			.rangeRound([0, 3]);

		this._getPetalSize = d3.scale.linear()
			.domain([d3.min(data, function (d) {
				return d.value;
			}), d3.max(data, function (d) {
				return d.value;
			})])
			.rangeRound([this._circle_size + this._arc_thickness + 10, this._petal_size]);


			dv.util.each(data, function (o, k) {
				o.angle = getAngleScale(k);
				that._addPetalSizes(o);
			});

		this._getTextOffsetScale = function(angle) {
			var index = this._getTextOffsetIndex(angle);
			if(index == 8) {index = 0;} // if it is all the way around, set it back to the top position.
			return text_offsets[index];
		};

		// Full Gray Petal
		var gray_bg_petals = this.layer1.selectAll('.flower-cv-gray-petals').data(data);

		gray_bg_petals.enter().append("path")
		.attr('class', 'flower-cv-gray-petals')
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; })
		.attr("d", that._makePetal(0, 0, 0, 0))
		.attr('opacity', 0);

		gray_bg_petals.transition().duration(that._options.animationDuration)
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; })
		.attr("d", function(d){return that._makePetal(0, 0, 0, d.full_petal); })
		.attr('opacity', function(d){return d.petal_size_number == 3 ? 0 : 1;});

		gray_bg_petals.exit().transition().duration(that._options.animationDuration)
		.attr("d", that._makePetal(0, 0, 0, 0))
		.attr('opacity', 0)
		.remove();

		//Color Petals
		var color_petals = this.layer2.selectAll('.flower-cv-color-petals').data(data);

		color_petals.enter().append("path")
		.attr('class', 'flower-cv-color-petals')
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; })
		.attr('opacity', function(d){return d.petal_opacity;})
		.attr("d", that._makePetal(0, 0, 0, 0))
		.attr('fill', function(d){return d.petal_color; })
		.on("mouseover", mouseoverCallback)
		.on("mouseout", mouseoutCallback)
		.on("click", function(d) {
			if (that._options.clickHandler) {
				that._options.clickHandler(d);
			}
		});

		color_petals.transition().duration(that._options.animationDuration)
		.attr("d", function(d){return that._makePetal(0, 0, 0, d.petal_size); })
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; })
		.attr('fill', function(d){return d.petal_color; })
		.attr('opacity', function(d){return d.petal_opacity; });

		color_petals.exit().transition().duration(that._options.animationDuration)
		.attr("d", that._makePetal(0, 0, 0, 0))
		.attr('opacity', 0)
		.remove();

		var white_arcs = this.layer3.selectAll('.flower-cv-white-arcs').data(data);

		// White border
		var arc = d3.svg.arc()
			.innerRadius(0)
			.outerRadius(this._circle_size + this._arc_thickness + 1)
			.startAngle(-that._arc_half_angle * (Math.PI / 180)) //converting from degs to radians
		.endAngle(that._arc_half_angle * (Math.PI / 180)); //just radians

		white_arcs.enter().append("path")
		.attr('class', 'flower-cv-white-arcs')
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; })
		.attr("fill", "white");

		white_arcs.transition().duration(that._options.animationDuration)
		.attr("d", arc)
			.attr("transform", function(d){ return "rotate(" + d.angle + ")"; });

		white_arcs.exit().remove();

		// Color bar
		arc = d3.svg.arc()
			.innerRadius(0)
			.outerRadius(this._circle_size + this._arc_thickness)
			.startAngle(-(that._arc_half_angle - 1) * (Math.PI / 180)) //converting from degs to radians
		.endAngle((that._arc_half_angle -1) * (Math.PI / 180)); //just radians

		var color_arcs = this.layer4.selectAll('.flower-cv-color-arcs').data(data);
		color_arcs.enter().append("path")
		.attr('class', 'flower-cv-color-arcs')
		.attr("d", arc)
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; })
		.attr('fill', function(d){return d.arc_color; });

		color_arcs.transition().duration(that._options.animationDuration)
		.attr("d", arc)
		.attr('fill', function(d){return d.arc_color; })
		.attr("transform", function(d){ return "rotate(" + d.angle + ")"; });

		color_arcs.exit().remove();

		var petal_labels = this.layer5.selectAll('.flower-cv-petal-labels').data(data);
		petal_labels.enter().append("text")
		.attr('class', 'flower-cv-petal-labels')
		.attr("x", 0)
		.attr("y", 0)
		.attr("text-anchor", function(d){return that._getTextOffsetScale(d.angle).location; })
		.attr("dx", function(d){return that._getTextOffsetScale(d.angle).offset_x * -that._options.text_offset; })
		.attr("dy", function(d){return that._getTextOffsetScale(d.angle).offset_y * -that._options.text_offset - that._getTextOffsetScale(d.angle).fixed_offset_y; })
		.style('font-size', that._font_size)
		.attr("transform", function(d){ return "rotate(" + d.angle + ") rotate(" + -d.angle + ", 0, " + 0 + ")"; })
		.attr('opacity', 0);

		petal_labels
		.style('font-size', that._font_size + 'px')
		.attr("text-anchor", function(d){return that._getTextOffsetScale(d.angle).location; })
		.attr("dx", function(d){return that._getTextOffsetScale(d.angle).offset_x * -that._options.text_offset; })
		.attr("dy", function(d){return that._getTextOffsetScale(d.angle).offset_y * -that._options.text_offset - that._getTextOffsetScale(d.angle).fixed_offset_y; })
		.selectAll("*").remove();

		// Since Firefox and Safari cannot have tspans dynamcially inserted via the html() call,
		// we pass the entire object into the formatter so that the tspans can be appended.
		// This allows for greater customization of the labels that just a string of text.
		labelFormatter(petal_labels);

		petal_labels.transition().duration(that._options.animationDuration)
		.attr("y", function(d){return d.petal_size; })
		.attr("transform", function(d){ return "rotate(" + d.angle + ") rotate(" + -d.angle + ", 0, " + d.petal_size + ")"; })
		.attr('opacity', function(d){return d.petal_number_size === 0 ? 0 : 1;});

		petal_labels.exit().remove();

		var main_circle = this.layer6.selectAll('.flower-cv-main-circle').data([1]);
		main_circle.enter().append("circle")
		.attr('class', 'flower-cv-main-circle')
		.attr("cx", 0)
		.attr("cy", 0);

		main_circle.transition().duration(that._options.animationDuration)
			.attr("r", that._circle_size);

	}; // end the renderPreinit

	flower._makePetal = function(x, y, x2, y2) {
		var radius = this._circle_size + this._arc_thickness + 1,
		    half_width = (radius * 2 * Math.PI) / this._petal_count / 2,
		    degrees = half_width / (radius * 2 * Math.PI) * 360,
		    y3 = Math.cos(degrees * Math.PI / 180) * radius,
		    x3 = Math.sin(degrees * Math.PI / 180) * radius;
		y = -y3;
		var start_x = x - x3,
		    end_x = x + x3,
		    bulge_vertical_location = (y2 - y) * -1 * 0.6,
		    height = (y2 - y) * -1,
		    bulge_width = height * 0.2,
		    result = [
		        'M', start_x, y,
		        'C', start_x - bulge_width, y - bulge_vertical_location, x, y2, x2, y2,
		        'C', x2, y2, end_x + bulge_width, y - bulge_vertical_location, end_x, y
		    ];

		return result.join(' ');
	};

	// This function figures out the petal size and opacity for each of the data points.
	flower._addPetalSizes = function(o){
		if(!o.color){
			o.color = this.colorScale(o.label);
		}
		var size = this._getSizeZeroToThree(o.value);

		if (!this._is_single_mode) {
			if (size === 0) {
				size = 1;
			}
		}

		if(o.value === 0){
			size = 0;
		}

		var opacity = 0.9;
		var color = o.color;
		var arc_color = color;
		var petal_size = this._petal_size;
		var full_petal = petal_size * -1;
		switch (size) {
			case 0:
				opacity = 0;
				arc_color = '#e6e6e6';
				petal_size = 0;
				color = color; // you added this so it would always be defined for transitions.
				break;
			case 3:
				opacity = 0.9;
				break;
			case 2:
				opacity = 0.75;
				petal_size = petal_size * 0.795;
				break;
			case 1:
				opacity = 0.5;
				petal_size = petal_size * 0.6;
				break;
		}

		if (!this._is_single_mode) {
			petal_size = this._getPetalSize(o.value);
		}
		if(o.value === 0){
			petal_size = 0;
		}

		petal_size *= -1;
		o.petal_opacity = opacity;
		o.petal_size = petal_size;
		o.petal_color = color;
		o.full_petal = full_petal;
		o.petal_number_size = size;
		o.arc_color = arc_color;
	};

	global.cloudViz.flower = cloudViz.util.createConstructor(flower);
}(this));
/**
 * Funnel Chart
 * A chart shows bar geoms grouped into steps to show conversion and fallout
 * Parameters
 * options: customization parameters for the funnel chart
 * options are defined in the core object, bar specific are below in 'Funnel Options'
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, dvcore = cloudViz.dvcore || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		funnel = Object.create(dvcore);

	funnel.init = function(options) {
		Object.getPrototypeOf(funnel).init.apply(this, arguments);

		this._type = 'funnel';
		this._chart = dv.chart();
		this._avgColor = '#b1b1b1';
		return this;
	};

	funnel._initDefaultOptions = function() {
		var defaults = {
			// Average line will be displayed by default as an average of all series
			// Setting averageSeries will remove that series from the bars and render it as the line
			averageSeries: null,
			// Override the default localized 'Average' or the set averageSeries seriesLabel
			averageSeriesLabel: null,
			// Turn off average completely, regardless of other average options
			disableAverage: false,
			// Turn off normalizing
			normalized: true, // TODO: false is not fully implemented/tested
			formats: { // The format each series should be displayed with.  Options are decimal (default), percent, currency, time.
				x: 'decimal',
				y: 'decimal' // The y format can also be an array of formats for each individual series.
			},
			tooltipContent : null // a function which will be called when a tooltip is shown. Should return an HTML formatted string which will be displayed in the chart.
		};

		return Object.getPrototypeOf(funnel)._initDefaultOptions.call(this, defaults);
	};

	funnel.reset = function() {
		Object.getPrototypeOf(funnel).reset.apply(this, arguments);
	};

	/**
	 * Common draw method for all charts
	 **/
	funnel._setChartTypeOptions = function() {
		var chart = this._chart, options = this._options,
			self = this, adapter = this._dataAdapter,
			seriesMap = this._getPropMapping('series'),
			minBarWidth = 0,
			maxBarWidth = 100,
			yAxisTitleWidth = 28, // hardcoded for now
			padding = this._isNormalized() && !adapter.isSingleSeries() ? yAxisTitleWidth : 30,
			chartWidth = this._getChartWidth() - (padding * 2),
			dodgeSpacing = 0.05, // percentage of the bar width
			numInStep = adapter.getNumBarsPerStep(),
			numOfStep = adapter.getNumSteps(),
			// number of 'bars', including counting space between steps as a bar
			numBars = (numOfStep * (numInStep + 1)) - 1, // add one for spacing between bars
			barWidth = Math.min(Math.max(minBarWidth, chartWidth / numBars), maxBarWidth),
			stepPadding = adapter.isSingleSeries() ? barWidth / 3 : barWidth,
			barTextSize = barWidth >= 36 ? 12 : barWidth >= 28 ? 10 : 0,
			stepWidth = (numInStep * barWidth) + stepPadding,
			stepSpacing = stepPadding / stepWidth, // percentage of the step width
			centerPadding = barWidth === maxBarWidth ?
				// outerPadding used to center bars
				// for better explanation of padding, see
				// https://github.com/mbostock/d3/wiki/Ordinal-Scales#ordinal_rangeBands
				(chartWidth - ((stepWidth * numOfStep) - stepPadding)) / 2 / stepWidth : 0;

		// Store actual step width (bars, not padding) for use laying out labels later
		this._stepWidth = numInStep * barWidth;
		// step spacing
		this._stepPadding = stepPadding;

		var layers = [
				// Conversion
				dv.geom.bar()
					.data(adapter.currentStepData())
					.dodgePadding(dodgeSpacing)
					.each('start', function(d, i) {
						// Data here is the translated DV object, so use fill which will equate to series
						d3.select(this).attr('legend-group', d['fill']);
					}),
				// Falloff faded bars
				dv.geom.bar()
					.data(adapter.previousStepData())
					.dodgePadding(dodgeSpacing)
					.set('alpha', 0.15)
					.each('start', function(d, i) {
						// Data here is the translated DV object, so use fill which will equate to series
						d3.select(this).attr('legend-group', d['fill']);
					}),

				// Percentage conversion text
				dv.geom.text()
					.data(adapter.textStepData())
					.each('start', function(d, i) {
						// Data here is the translated DV object, so use fill which will equate to series
						d3.select(this).attr('legend-group', d['group']).classed('cv-funnel-text');
					})
					.map('label', 'cv_label')
					.map('group', seriesMap)
					.set('fill', '#666')
					.textAnchor('middle')
					.dy(-5)
					.textFormat(function(d) { return self._formatNumber('percent', d); })
					.set('size', barTextSize)
			];

		// remove previous if only a single series
		if (adapter.isSingleSeries()) {
			layers.splice(1, 1);
		}

		// add average series into chart legend
		if (!options.interactive && adapter.averageStepData() && (!adapter.isAvgCalculated() || !adapter.isSingleSeries())) {
			// we have to hack in a fake geom to add the avg series to the default legend
			var fakedata = { x:[0], y:[0], cvfake:['cvfakeline'] };
			layers.push(
				dv.geom.line().data(fakedata)
					.map('stroke', 'cvfake', dv.scale.color().values([this._avgColor]))
			);
			// Calling _buildStandardLegend nulls out the this._legend because its assumed we have one or the other
			// store the legend off and restore it to avoid losing the original _legend
			var l = this._legend;
			chart.guide('stroke', this._buildStandardLegend([adapter.averageDataLabel()]));
			this._legend = l;
		}

		chart.layers(layers)
			.data({}) // remove data for chart, keep it on a per layer basis
			.map('fill', seriesMap, dv.scale.color().values(options.colors))
			.map('x', this._getPropMapping('x'), dv.scale.ordinal().padding(stepSpacing).outerPadding(centerPadding).reverse(options.flip))
			.guide('fill', this._legend)
			.position('dodge')
			.padding(this._isNormalized() && !adapter.isSingleSeries() ?
				{ left: padding - yAxisTitleWidth, right: padding } : { left: padding, right: padding });

		// handle clicks if a callback is passed in
		chart._layers[0].on('click', this._eventMap['click'] ? this._eventMap['click'] : null);

		this._addBehaviors(chart.layers()[adapter.isSingleSeries() ? 0 : 1], options);
		this._mapPositionScales(chart, options);
	};

	funnel._mapPositionScales = function(chart, options) {
		var self = this, rangePadding = [0, 25],
			scale = this._applyForceZero(this._constructScale('y')).rangePadding(rangePadding),
			fillMapping = this._getPropMapping('series'),
			yMapping = this._getPropMapping('y'),
			adapter = self._dataAdapter;

		// update scale to include upper limit for average step data for non-normalized
		if (adapter.useAvgMaxValue()) {
			var avg = adapter.averageStepData(),
				amax = d3.extent(avg[self._getPropMapping('y')])[1];
			scale.upperLimit(function(min, max) {
				// update upperlimit to include max of average step data, including forcing 0
				var m = max > 0 ? max : 0;
				return amax > m ? amax : m;
			});
		}

		if (options.normalized) {
			var uniqueGroups = self._dataAdapter.uniqueFillValues();
			// create a includeInDomain for each series
			uniqueGroups.forEach(function(g, index) {
				var fillScale = (0 === index) ? scale : scale.copy();
				fillScale.includeInDomain(function(d, i) {
					return d.data[fillMapping] === self._dataAdapter.uniqueFillValues()[index];
				});
				if (index > 0) { chart.map('y', yMapping, fillScale, index); }
			});
		}
		chart.map('y', yMapping, scale, 0);
	};

	/**
	 * Adds custom interactive behaviors to the chart.
	 */
	funnel._addBehaviors = function(geom, options) {
		var d3Parent = d3.select(options.parent),
			timer, adapter = this._dataAdapter,
			self = this, l10n = adapter.l10n.labels.funnel;

		// The chart must not be small and must be interactive in order to receive an inspector.
		if (!this._isSmallChart() && options.interactive) {
			geom.behaviors([
				dv.behavior.rollover()
					.orientation(options.flip ? 'top' : 'right')
					.content(function(d, i, j) {
						if (options.tooltipContent) {
							return options.tooltipContent.call(this, d, i, j);
						}
						var seriesGroup = this.__geom.getExplicitScale('group'),
							y = d.panel.yScale(d),
							valueFormat = self._yLabelFormat(y.scaleIndex()),
							value = d.data['cv_tt_val'], pValue = d.data['cv_tt_pval'],
							xLabel = adapter.getStepName(d.x),
							avg = adapter.isSingleSeries() && adapter.isAvgCalculated() ? null : adapter.averageStepData(), // don't show avg info on single series calculated
							stepDataIndex, stepValue, stepPrevValue, stepAvgTitle;
						if (avg) {
							stepAvgTitle = adapter.averageDataLabel();
							stepDataIndex = avg[self._getPropMapping('x')].indexOf(d.x);
							stepValue = avg[self._getPropMapping('y')][stepDataIndex];
							stepPrevValue = avg[self._getPropMapping('y')][stepDataIndex > 0 ? stepDataIndex - 1 : 0 ];
						}
							// STEP
						var content = '<span class="cv-tooltip-content">' +
								'<span class="cv-funnel-title">' + l10n.step +
								'</span><span class="cv-funnel-series-name">' + xLabel +
							// SEGMENT
								'</span><span class="cv-funnel-title">' + l10n.segment +
								'</span><span class="cv-funnel-metric-name">' + d.data[self._getPropMapping('seriesLabel')] +
							// CONVERSION
								'</span><span class="cv-funnel-title">' + l10n.conversion +
								'</span><span class="cv-funnel-percent-value">' + self._formatYValue(pValue ? value / pValue : 0, 'percent') +
								'</span><span class="cv-funnel-metric-value">' + valueFormat(value) + '</span>';
							if (avg) {
								content += '<span class="cv-funnel-sub-title">' + stepAvgTitle +
								'</span><span class="cv-funnel-percent-value">' + self._formatYValue(stepPrevValue ? stepValue / stepPrevValue : 0, 'percent') +
								'</span><span class="cv-funnel-metric-value">' + valueFormat(stepValue) + '</span>';

							}
							// FALLOUT
							content += '<span class="cv-funnel-title">' + l10n.fallout +
								'</span><span class="cv-funnel-percent-value">' + self._formatYValue(pValue ? 1 - (value / pValue) : 0, 'percent') +
								'</span><span class="cv-funnel-metric-value">' + valueFormat(pValue - value) + '</span>';
							if (avg) {
								content += '<span class="cv-funnel-sub-title">' + stepAvgTitle +
								'</span><span class="cv-funnel-percent-value">' + self._formatYValue(stepPrevValue ? 1 - (stepValue / stepPrevValue) : 0, 'percent') +
								'</span><span class="cv-funnel-metric-value">' + valueFormat(stepPrevValue - stepValue) + '</span>';

							}

						return content + '</span>';
					})
					.showTooltip(function(d, i, j, ev, behavior) {
						var el = d3.select(this);

						// Only active bars can show a tooltip.
						if (!el.classed('path-inactive')) {
							behavior._showTip.call(this, d, i, j, behavior);
							clearTimeout(timer);
							d3Parent.selectAll('.bar-geom')
								.classed('cv-medium-duration', false)
								.classed('cv-unselected', function(pointD) {
									return d.x !== pointD.x || d.fill !== pointD.fill;
								});
							d3Parent.selectAll('.text-geom')
								.classed('cv-medium-duration', false)
								.classed('cv-unselected', function(pointD) {
									return d.x !== pointD.x || d.fill !== pointD.group;
								});
							d3Parent.selectAll('.cv-legend-marker')
								.classed('cv-unselected', function(legendD) {
									return legendD.id !== d.fill;
								})
								.classed('cv-medium-duration', false);
							d3Parent.selectAll('.avg-geom')
								.classed('cv-unselected', true)
								.classed('cv-medium-duration', false);

							if (self._eventMap['mouseover']) {
								self._eventMap['mouseover'].call(this, d, i, j, ev);
							}
						}
					})
					.hideTooltip(function(d, i, j, ev, behavior) {
						var el = d3.select(this);

						// Only active bars can hide the tooltip.
						if (!el.classed('path-inactive')) {
							behavior._removeTip.call(this, d, i, j, behavior);
							timer = setTimeout(function() { // Don't use d3 transitions here.  They can override transitions that occur when moving/sizing a bar which makes them freeze in place.
								d3Parent.selectAll('.bar-geom, .text-geom, .cv-legend-marker, .avg-geom')
									.classed('cv-unselected', false)
									.classed('cv-medium-duration', true);

								if (self._eventMap['mouseout']) {
									self._eventMap['mouseout'].call(this, d, i, j, ev);
								}
							}, 400);
						}
					})
			]);
		}
	};

	funnel._getStepLabel = function(d, i) {
		var adapter = this._dataAdapter,
			value = adapter.getSingleSeriesStepValue(d, i),
			text = adapter.getStepName(d),
			html = '<div class="cv-funnel-step-label" style="width: ' + Math.floor(this._stepWidth) + 'px">';
		if (typeof value !== 'undefined') { html += '<span class="cv-funnel-step-label-value">' + this._yLabelFormat(0)(value) + '</span>'; }
		html += '<span class="cv-funnel-step-label-name">' + text + '</span>';
		return html + '</div>';
	};

	funnel._drawSmall = function() {
		this._drawLarge();
	};

	funnel._drawLarge = function() {
		var chart = this._chart, options = this._options, self = this,
			adapter = this._dataAdapter, xAxis = dv.guide.axis();

		xAxis
			.htmlLabels(true)
			.tickSize(0)
			.tickAnchor('middle')
			.tickFormat(function(d, i){ return self._getStepLabel(d,i); })
			.title(this._dataAdapter.xAxisTitle());

		chart.guide('x', xAxis)
			.guide('y', 'none');

		// Attaches the normalized y axis title if multiple series
		if (!adapter.isSingleSeries()) {
			var p = chart.padding();
			this._checkNormalized();
			chart.padding(p); // Restoring padding, TODO: need to check why _checkNormalized clears padding
		}

	};

	funnel._renderChart = function() {
		Object.getPrototypeOf(funnel)._renderChart.call(this);
		this._drawAllLine();
	};

	funnel._drawAllLine = function() {
		var chart = this._chart, self = this,
			options = this._options,
			adapter = this._dataAdapter,
			normalized = this._isNormalized(),
			xscale = chart.getTrainedScale('x'),
			yscale = chart.getTrainedScale('y'),
			avgData = adapter.averageStepData(),
			mappings = adapter.mappings(),
			series = this._getPropMapping('series'), // segment
			seriesLabel = this._getPropMapping('seriesLabel'), // segment name
			x = this._getPropMapping('x'), // step
			value = this._getPropMapping('y'),
			xAdjust = Math.min(this._stepPadding / 2, 5), // padding around the bar geom
			data = [];

		// Generate the data object to create the D3 lines/points
		if (avgData) {
			var maxDataValue = adapter.getUniqueFillExtent(0)[1],
				maxAvgValue = d3.extent(avgData[value])[1],
				// use avg value if no max value exists on normalized
				// otherwise use the greater of the two
				topRange = normalized ? maxDataValue || maxAvgValue : Math.max(maxDataValue, maxAvgValue),
				convert = d3.scale.linear().domain([0, maxAvgValue]).range([0, topRange]);
			avgData[x].forEach(function(cat, i) {
				var v = avgData[value][i],
					y = yscale.mapValue(normalized ? convert(v) : v);
				// Create start and end data points for group line
				data.push({
					x: xscale.mapValue(cat) - xAdjust,
					y: y
				});
				data.push({
					x: xscale.mapValue(cat) + xscale.rangeBand() + xAdjust,
					y: y
				});
			});
		}

		// Add group
		var group = d3.select(chart.parent()).selectAll('svg').selectAll('.cv-funnel-avg-group').data([0]);
		group.enter().insert('g', '.group').classed('cv-funnel-avg-group', true);
		var lineGroup = group.selectAll('.avg-group-line').data([0]);
		lineGroup.enter().append('g').classed('avg-group-line series', true);
		var pointGroup = group.selectAll('.avg-group-point').data([0]);
		pointGroup.enter().append('g').classed('avg-group-point series', true);

		// Create line chart
		var line = d3.svg.line()
		    .x(function(d) { return d.x; })
		    .y(function(d) { return d.y; }),
			duration = chart.duration(),
			ease = chart.ease();

		var lineGeom = lineGroup.selectAll('.avg-line').data([data]);
		lineGeom.enter().append('path').classed('avg-line avg-geom', true);
		lineGeom
			.attr('legend-group', adapter.averageSeries())
			.transition()
			.duration(duration)
			.ease(ease)
			.attr('d', line)
			.style('stroke', this._avgColor);
		lineGeom.exit().remove();

		var pointGeoms = pointGroup.selectAll('.avg-dot').data(data);
		pointGeoms.enter().append('circle').classed('avg-dot avg-geom', true);
		pointGeoms
			.attr('legend-group', adapter.averageSeries())
			.style('stroke', this._avgColor)
			.transition()
			.duration(duration)
			.ease(ease)
			.attr('cx', line.x())
			.attr('cy', line.y())
			.attr('r', 3);
		pointGeoms.exit().remove();

	};

	funnel._createSeriesStates = function() {
		Object.getPrototypeOf(funnel)._createSeriesStates.call(this);

		if ('data' in this._changedOptions && this._changedOptions.data) {
			// Remove previously added average state
			var adapter = this._dataAdapter;
			this._seriesState.removeStatesByType('funnel-average');
			if (adapter.averageStepData()) {
				// If the targetLabel is undefined, set it to the localized target default label.
				this._seriesState.insertState(adapter.averageDataLabel(), adapter.averageSeries(), 'funnel-average');
			}
		}
	};

	funnel._updatePathStates = function() {
		Object.getPrototypeOf(funnel)._updatePathStates.call(this);

		var self = this, options = this._options,
			adapter = this._dataAdapter, avgSeries = adapter.averageSeries();
		// Determine if the average line should be inactive or not.  We handled the bars already in dvcore.
		d3.select(options.parent).selectAll('.cv-funnel-avg-group .series [legend-group]')
			.classed('path-inactive', function() {
				if (!options.interactive) { return false; }
				var el = d3.select(this),
					seriesId = el.attr('legend-group');
				if (seriesId === avgSeries && self._seriesState.doesSeriesStateExist(seriesId, 'funnel-average')) {
					return !self._seriesState.isSeriesEnabled(seriesId, 'funnel-average');
				}
				return el.classed('path-inactive'); // Return whatever it already was.
			});
	};


	funnel._isNormalized = function() {
		return this._options.normalized;
	};

	global.cloudViz.funnel = cloudViz.util.createConstructor(funnel);
}(this));
/**
 * Gauge Chart
 *
 * A gauge chart is useful for showing a single value in dashboards, real-time monitors, and reports. They can
 * also give contextual information such as whether than value falls in an acceptable range or not.
 */
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {},
		core = cloudViz.core || {},
		dv = global.dv || {},
		d3 = global.d3 || {},
		gauge = Object.create(core);

	var outerPadding = 0.05, // percent padding outside the arc based on radius
		needleThickness = 0.09, // percent thickness of the needle based on radius
		needleLengthRatio = 1 + outerPadding, // percent length of the needle based on radius
		tickThickness = 0.05, // percent thickness of the axis major ticks based on radius
		minorTickThickness = 0.025, // percent thickness of the axis minor ticks based on radius

		tickPadding = 2, // Pixels between the inside lip of the arc and the ticks
		tickLabelGap = 14, // Pixels between the major tick and the major tick label

		minPercentOpen = 0.1, // The largest dial that can be drawn
		maxPercentOpen = 0.75, // The smallest dial that can be drawn

		// DOM elements
		cvWrapper = null,
		d3Container = null;

	gauge.init = function(options) {
		this._type = 'gauge';
		options = options || {};
		this._initDefaultOptions();
		this.setOptions(options);
		return this;
	};

	gauge._initDefaultOptions = function(options) {
		var defaults = {
			duration: 750, // The time it will take for the animation to finish
			percentOpen: minPercentOpen, // Defines the opening at the bottom of the gauge in percentage. The higher the percent, the smaller the arc. Accepts values from 0.1 to 0.75.
			showNeedle: true, // If true, a needle is shown and animates to the selected value. Otherwise, a fill arc will be drawn like a progress bar to the selected value.
			showAxis: true, // If true, draws an axis, otherwise the axis is hidden.
			ticks: 5, // The number of major ticks that will be drawn on the axis. Could be more or less than specified depending on how readable the increments are.
			tickSubdivisions: 0, // The number of minor ticks that will be drawn between major ticks

			ringThickness: 0.15, // percent thickness of the arc based on radius
			format: "decimal", // formats the axis values and value label (values include: currency, percent, decimal)
			fillColor: "#3284d4", // Specifies the colors of the filled arc when showNeedle is false
			minValue: 0, // The minimum value of the gauge drawn on the left side
			maxValue: 10, // The maximum value of the gauge drawn on the right side
			colors: [ // An array of color objects which defines the range bands along the axis. There can be an unlimited amount of colors.
				{
					color: "#ff3400", // The color of the range band
					alpha: 1, // The opacity of the range band
					from: "0%", // A starting value that the arc will be drawn from. Can be a decimal or percent string.  If decimal, it calculates the percent from min and max values to draw the arc.
					to: "33%" // The final value that the arc will be drawn to.
				},
				{
					color: "#faca00",
					alpha: 1,
					from: "33%",
					to: "66%"
				},
				{
					color: "#68b672",
					alpha: 1,
					from: "66%",
					to: "100%"
				}
			],
			metric: "", // A label which will be drawn on the gauge to denote which metric the value represents.
			value: 0 // The selected value where the needle or filled arc will be drawn to.
		};

		this._margins = { top: 0, left: 0, right: 0, bottom: 0 };

		return Object.getPrototypeOf(gauge)._initDefaultOptions.call(this, defaults);
	};

	/**
	 * Called when the chart is ready for rendering.
	 */
	gauge.render = function() {
		Object.getPrototypeOf(gauge).render.call(this, arguments);

		this._determineSize();
		this._initScales();
		this._draw();
		return this;
	};

	/**
	 * Called when the chart is automatically resized. This will only fire if the autoResize option is true and the browser
	 * window size changes.
	 */
	gauge._onAutoResize = function() {
		this.render();
	};

	/**
	 * Calculate the radius of the gauge, the margins, and overall size based on width/height options or the size of the
	 * parent if no size options were specified.
	 */
	gauge._determineSize = function(options) {
		var opts = this._options,
			parent = opts.parent,
			width = opts.width ? opts.width : parent.offsetWidth, // Grab the parent's width if we don't have width set
			height = opts.height ? opts.height : parent.offsetHeight, // Grab the parent's height if we don't have height set
			percentOpen = Math.max(minPercentOpen, Math.min(maxPercentOpen, opts.percentOpen));

		if (opts.showNeedle) {
			this._margins.bottom = height * 0.05;
		}
		this._maxAngle = (1 - percentOpen) * 180;
		this._minAngle = (1 - percentOpen) * -180;

		width -= this._margins.left + this._margins.right;

		this._size = [width, height];
		this._radius = Math.min(width - this._margins.left - this._margins.right, height - this._margins.top - this._margins.bottom) / 2;
	};

	/**
	 * Initializes the scales used to position arcs, axis ticks, and the selected value indicator.
	 */
	gauge._initScales = function() {
		var opts = this._options;

		if (opts.minValue > opts.maxValue) {
			throw new Error("The minimum value is greater than the maximum value.");
		}
		this._scale = d3.scale.linear().domain([opts.minValue, opts.maxValue]).range([0, 1]); // Map domain to percent values
	};

	/**
	 * Queues up the drawing process for gauge.
	 */
	gauge._draw = function() {
		this._initSVG();
		this._drawTrack();
		this._drawAxis();
		this._drawSelectedIndicator();
		this._drawLabels();
	};

	/**
	 * Ensures the DOM elements and SVG container exist in the DOM tree or creates them if they don't.
	 */
	gauge._initSVG = function() {
		var opts = this._options,
			d3Parent = d3.select(opts.parent);

		cvWrapper = d3Parent.selectAll('.cv-wrapper.cv-gauge').data([0]);
		cvWrapper.enter()
			.append('div')
			.classed('cv-wrapper cv-gauge', true);
		cvWrapper
			.style('width', this._size[0] + 'px')
			.style('height', this._size[1] + 'px');

		var chartContainer = cvWrapper.selectAll('.chart-wrapper').data([0]);
		chartContainer.enter()
			.append('div')
			.classed('chart-wrapper', true);

		var svg = chartContainer.selectAll('svg').data([0]);
		svg.enter()
			.append('svg');

		d3Container = svg.selectAll('g').data([0]);
		d3Container.enter()
			.append('g');
		d3Container
			.attr('transform', 'translate(' + (this._size[0] - this._margins.left - this._margins.right) / 2 + ',' + (this._size[1] - this._margins.top - this._margins.bottom) / 2 + ')');
	};

	/**
	 * Draws the arcs that comprise the gauge.  The drawing logic uses the color objects in the colors array to determine
	 * the angles that each arc is drawn from and the color/alpha to be used on the arc.
	 */
	gauge._drawTrack = function() {
		var self = this,
			opts = this._options;

		var arc = d3.svg.arc()
			.innerRadius(this._radius * (1 - outerPadding - opts.ringThickness))
			.outerRadius(this._radius * (1 - outerPadding))
			.startAngle(function(d, i) {
				var percentVal = dv.util.isPercentString(d.from) ? parseInt(d.from, 10) / 100 : self._scale(d.from),
					angle = (self._maxAngle - self._minAngle) * percentVal + self._minAngle;
				return deg2rad(angle);
			})
			.endAngle(function(d, i) {
				var percentVal = dv.util.isPercentString(d.to) ? parseInt(d.to, 10) / 100 : self._scale(d.to),
					angle = (self._maxAngle - self._minAngle) * percentVal + self._minAngle;
				return deg2rad(angle);
			});

		var arcContainer = d3Container.selectAll('.arc').data([0]);
		arcContainer.enter()
			.append('g')
				.classed('arc', true);

		var arcs = arcContainer.selectAll('path').data(opts.colors);
		arcs.enter()
			.append('path');
		arcs.exit()
			.remove();
		arcs
			.attr('fill', function(d, i) { return d.color; })
			.attr('opacity', function(d, i) { return d.hasOwnProperty('alpha') ? d.alpha : 1; })
			.attr('d', arc);
	};

	/**
	 * Draws the axis, or removes an already existing axis, depending on whether the showAxis option is true or false.
	 */
	gauge._drawAxis = function() {
		var self = this,
			opts = this._options,
			tickData = this._scale.ticks(opts.ticks),
			tickDraw = function(scale, minAngle, maxAngle, thickness) {
				return function(selection) {
					selection.attr('x1', 0)
						.attr('y1', tickPadding)
						.attr('x2', 0)
						.attr('y2', self._radius * thickness + tickPadding)
						.attr('transform', function(d) {
							var angle = val2deg(scale, d, minAngle, maxAngle);
							return 'rotate(' + val2deg(scale, d, minAngle, maxAngle) + ') translate(0,' + (self._radius * (opts.ringThickness + outerPadding) - self._radius) + ')';
						});
				};
			};

		var axisContainer = d3Container.selectAll('.axis').data(opts.showAxis ? [0] : []);
		axisContainer.enter()
			.append('g')
				.classed('axis', true);
		axisContainer.exit()
			.remove();

		var ticks = axisContainer.selectAll('.tick').data(tickData);
		ticks.enter()
			.append('line')
				.classed('tick', true);
		ticks.exit()
			.remove();
		ticks.call(tickDraw(this._scale, this._minAngle, this._maxAngle, tickThickness));

		var tickSubdivisionData = axisSubdivide(this._scale, tickData, opts.tickSubdivisions);
		var tickSubdivisions = axisContainer.selectAll('.minor-tick').data(tickSubdivisionData);
		tickSubdivisions.enter()
			.append('line')
				.classed('minor-tick', true);
		tickSubdivisions.exit()
			.remove();
		tickSubdivisions.call(tickDraw(this._scale, self._minAngle, self._maxAngle, minorTickThickness));

		var labels = axisContainer.selectAll('.tick-label').data(tickData);
		labels.enter()
			.append('text')
				.classed('tick-label', true);
		labels.exit()
			.remove();
		labels
			.attr('transform', function(d) {
				var angle = val2deg(self._scale, d, self._minAngle, self._maxAngle),
					rads = val2rad(self._scale, d, self._minAngle, self._maxAngle),
					r = (self._radius - tickLabelGap) * (1 - opts.ringThickness - outerPadding - tickThickness),
					x = Math.cos(rads) * r,
					y = Math.sin(rads) * r;

				if (angle < -10 && angle > -170) {
					x -= 3; // Nudge these axis labels a little closer to their ticks
				}
				if (angle > 10 && angle < 170) {
					x += 3; /// Nudge these axis labels a little closer to their ticks
				}

				return 'translate(' + x + ',' + y + ')';
			})
			.attr('text-anchor', function(d) {
				var angle = val2deg(self._scale, d, self._minAngle, self._maxAngle);
				if (angle > -10 && angle < 10) {
					return 'middle';
				}
				if (angle < 0) {
					return null;
				}
				return 'end';
			})
			.attr('dy', '.35em')
			.style('font-size', clamp(self._radius * 0.05, 8, 14) + 'px')
			.text(function(d) {
				return self._formatNumber(opts.format, d);
			});
	};

	/**
	 * Draws or tears down the needle or filled arc depending on whether the showNeedle option is true or false.
	 */
	gauge._drawSelectedIndicator = function() {
		var opts = this._options;
		this._drawNeedle(opts.showNeedle ? [opts.value] : []);
		this._drawProgressFill(opts.showNeedle ? [] : [opts.value]);
	};

	/**
	 * Draws or tears down the needle.
	 */
	gauge._drawNeedle = function(values) {
		var self = this,
			opts = this._options,
			cr = this._radius * needleThickness / 2, // radius of the inner needle circle
			needleLength = this._radius * needleLengthRatio;

		var needle = d3Container.selectAll('.needle').data(values);
		needle.enter()
			.append('path')
				.classed('needle', true)
				.attr('transform', 'rotate(' + self._minAngle + ')');
		needle.exit()
			.remove();
		needle // SVG for the needle
			.attr('d', 'M' + (cr / 2) + '-' + cr +
				'L0-' + needleLength +
				'L-' + (cr / 2) + '-' + cr +
				'C-' + (cr * 0.8257) + '-' + (cr * 0.8212) + '-' + (cr * 1.035) + '-' + (cr / 2 * 0.9448) + '-' + (cr * 1.035) + '-1' +
				'C-' + (cr * 1.035) + ',' + (cr / 2 * 0.9078) + '-' + (cr * 0.5796) + ',' + (cr * 0.9314) + ',0,' + (cr * 0.9314) +
				'S' + (cr * 1.035) + ',' + (cr / 2 * 0.9078) + ',' + (cr * 1.035) + '-1' +
				'C' + (cr * 1.035) + '-' + (cr / 2 * 0.9448) + ',' + (cr * 0.8257) + '-' + (cr * 0.8212) + ',' + (cr / 2) + '-' + cr + 'z')
			.transition()
			.duration(opts.duration)
			.ease('cubic-in-out')
				.attrTween('transform', function(d) {
					var el = this,
						val = Math.min(opts.maxValue, Math.max(opts.minValue, d)),
						angle = val2deg(self._scale, val, self._minAngle, self._maxAngle),
						previousAngle = this.__previousD__ === undefined ? self._minAngle : this.__previousD__,
						interpolate = d3.interpolate(previousAngle, angle);

					return function(t) {
						el.__previousD__ = interpolate(t);
						return 'rotate(' + el.__previousD__ + ')';
					};
				});
	};

	/**
	 * Draws or tears down the progress fill.
	 */
	gauge._drawProgressFill = function(values) {
		var self = this,
			opts = this._options,
			arc = d3.svg.arc()
				.innerRadius(this._radius * (1 - outerPadding - opts.ringThickness))
				.outerRadius(this._radius * (1 - outerPadding))
				.startAngle(deg2rad(self._minAngle))
				.endAngle(function(d) {
					return deg2rad(val2deg(self._scale, d, self._minAngle, self._maxAngle));
				});

		var progress = d3Container.selectAll('.progress').data(values);
		progress.enter()
			.append('path')
				.classed('progress', true);
		progress.exit()
			.remove();
		progress
			.attr('fill', opts.fillColor)
			.transition()
			.duration(opts.duration)
				.attrTween('d', function(d) {
					var el = this,
						val = Math.min(opts.maxValue, Math.max(opts.minValue, d)),
						previousVal = this.__previousD__ === undefined ? opts.minValue : this.__previousD__,
						interpolate = d3.interpolate(previousVal, val);

					return function(t) {
						el.__previousD__ = interpolate(t);
						return arc(el.__previousD__);
					};
				});
	};

	/**
	 * Draws the value and metric labels
	 */
	gauge._drawLabels = function() {
		var self = this,
			opts = this._options,
			valueData = opts.value === undefined ? [] : [opts.value],
			metricData = opts.metric === undefined ? [] : [opts.metric],
			minRads = val2rad(this._scale, opts.minValue, this._minAngle, this._maxAngle),
			maxRads = val2rad(this._scale, opts.maxValue, this._minAngle, this._maxAngle),
			radiusToInnerArc = (this._radius) * (1 - opts.ringThickness - outerPadding),
			radiusToInsideArc = (this._radius - tickLabelGap) * (1 - opts.ringThickness - outerPadding - tickThickness),
			xLeftOpening = Math.cos(minRads) * radiusToInsideArc + this._radius,
			xRightOpening = Math.cos(maxRads) * radiusToInsideArc + this._radius,
			yInnerOpening = Math.sin(minRads) * radiusToInnerArc + this._radius;

		var labelContainer = cvWrapper.selectAll('.label-container').data([0]);
		labelContainer.enter()
			.append('div')
				.classed('label-container', true);
		labelContainer
			.style('left', this._size[0] / 2 - this._radius + "px");

		var metricLabel = labelContainer.selectAll('.label-title').data(metricData);
		metricLabel.enter()
			.append('span')
				.classed('label-title', true);
		metricLabel.exit()
			.remove();
		metricLabel
			.style('font-size', clamp(this._radius * 0.1, 11, 18) + 'px')
			.classed('multiline-ellipsis', !opts.showNeedle)
			.text(String);

		var valueLabel = labelContainer.selectAll('.label-number').data(valueData),
			valueLabelYPos = Math.max(yInnerOpening, this._radius * 1.1);
		valueLabel.enter()
			.append('span')
				.classed('label-number', true)
				.style('line-height', this._radius * opts.ringThickness + 'px');
		valueLabel.exit()
			.remove();
		valueLabel
			.style('left', xLeftOpening + 'px')
			.style('width', xRightOpening - xLeftOpening + 'px')
			.style('font-size', this._radius * opts.ringThickness + 'px')
			.text(function(d) {
				return self._formatNumber(opts.format, d);
			});

		if (opts.showNeedle) {
			// Metric label shows under the chart if there is a needle.
			metricLabel
				.style('top', valueLabelYPos + this._radius * 0.2 + 'px')
				.style('left', 0)
				.style('width', this._radius * 2 + 'px');

			valueLabel
				.style('top', valueLabelYPos + 'px');
		} else {
			// Metric label shows in the center of the gauge if the filled arc is used.
			var metricLblHeight = clamp(this._radius * 0.1, 11, 20) * 2.3,
				metricLblYPos = this._radius * (1 - outerPadding);

			metricLabel
				.style('top', metricLblYPos + 'px')
				.style('left', this._radius * (opts.ringThickness + outerPadding + tickThickness + 0.3) + 'px')
				.style('width', this._radius * (1 - opts.ringThickness - outerPadding - tickThickness - 0.3) * 2 + 'px')
				.style('height', metricLblHeight + 'px');

			valueLabel
				.style('top', Math.max(metricLblYPos + metricLblHeight, valueLabelYPos) + 'px');
		}
	};

	/**
	 * Converts a raw value into radians
	 */
	function val2rad(scale, val, minAngle, maxAngle) {
		return deg2rad(val2deg(scale, val, minAngle, maxAngle)) - deg2rad(minAngle) - deg2rad(maxAngle) - Math.PI / 2;
	}

	/**
	 * Converts a raw value into an angle in degrees
	 */
	function val2deg(scale, val, minAngle, maxAngle) {
		return minAngle + (scale(val) * (maxAngle - minAngle));
	}

	/**
	 * Converts a angle into radians
	 */
	function deg2rad(deg) {
		return deg * Math.PI / 180;
	}

	/**
	 * Enforces a min/max on an arbitrary value
	 */
	function clamp(val, min, max) {
		return Math.max(min, Math.min(max, val));
	}

	/**
	 * Returns an array of axis minor tick raw values used in the axis
	 *
	 * @param scale The D3 scale used to generate minor ticks
	 * @param ticks An array of major ticks that will already be drawn
	 * @param m The number of minor ticks that should be drawn between each major tick
	 */
	function axisSubdivide(scale, ticks, m) {
		var subticks = [];
		if (m && ticks.length > 1) {
			var extent = scaleExtent(scale.domain()),
				i = -1,
				n = ticks.length,
				d = (ticks[1] - ticks[0]) / ++m,
				j,
				v;
			while (++i < n) {
				for (j = m; --j > 0;) {
					if ((v = +ticks[i] - j * d) >= extent[0]) {
						subticks.push(v);
					}
				}
			}
			for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
				subticks.push(v);
			}
		}
		return subticks;
	}

	/**
	 * Returns a domain array of two values where the first value is always less than the second value.
	 */
	function scaleExtent(domain) {
		var start = domain[0], stop = domain[domain.length - 1];
		return start < stop ? [start, stop] : [stop, start];
	}

	global.cloudViz.gauge = cloudViz.util.createConstructor(gauge);
}(this));
/**
 * TreeMap
 *
 * A treemap recursively subdivides area into rectangles which reveals the size of any node quickly.  The size is linearly proportional to values contained
 * in a size mapping. The fill mapping can be used to map a continuous sequential color scale as the fill for each generated rectangle.
 */
(function (global) {
	'use strict';

	var cloudViz = global.cloudViz || {},
		core = cloudViz.core || {},
		dv = global.dv || {},
		d3 = global.d3 || {},
		treemap = Object.create(core);

	// Dimension variables
	var width = 0,
		height = 0,
		top = 0,

		headingHeight = 25,
		leftMargin = 0,
		rightMargin = 0,
		bottomMargin = 0,

		rgbaRegex = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?|\.[0-9]+)\s*\)/,
		rgbRegex = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,

	// scales
		x = d3.scale.linear(),
		y = d3.scale.linear(),
		color = d3.scale.ordinal(),

	// DOM elements
		chartContainer,
		nodeContainer,

		firstLaunch = true,
		layout;

	treemap.init = function (options) {
		this._type = 'treemap';
		options = options || {};
		this._initDefaultOptions();
		this.setOptions(options);
		return this;
	};

	treemap._initDefaultOptions = function (options) {
		var defaults = {
			colors: [ // colors to use when displaying charts
				'#8cc350', // green
				'#5a6eaa', // iris
				'#d755a5', // fuchsia
				'#1ebed7', // cyan
				'#f0a01e', // tangerine
				'#9b8ce6', // periwinkle
				'#3cb5a0', // sea foam
				'#3287d2', // blue
				'#f0557d', // magenta
				'#c3d250', // chartreuse
				'#eb782d', // orange
				'#78b4f5', // sky blue
				'#5faf69', // kelly green
				'#aa5fa5', // plum
				'#fa5a50', // red
				'#f5c841' // yellow
			],
			layout: 'squarify', // The treemap layout style. 'squarify' is the default treemap style, 'slice' is a single row with multiple columns, 'dice' is a single
			duration: 750, // The length of each transition

			tooltipContent: defaultTooltipContent
		};

		return Object.getPrototypeOf(treemap)._initDefaultOptions.call(this, defaults);
	};

	treemap.reset = function () {

	};

	treemap._preRender = function () {
		this._determineSize(this._options.data);
		this._configureScales(this._options.data);
		this._configureLayout();
	};

	/**
	 * Called by core's render function after preRender and before postRender.
	 */
	treemap._render = function () {
		this._initContainer();
		this._draw(this._options.data);
		firstLaunch = false;
		return this;
	};

	treemap._postRender = function () {

	};

	treemap._determineSize = function (data) {
		var opts = this._options,
			parent = opts.parent;

		width = dv.util.getPercentValue(opts.width, parent.offsetWidth);
		height = dv.util.getPercentValue(opts.height, parent.offsetHeight);
	};

	treemap._configureScales = function (data) {
		var opts = this._options;

		color
			.domain(data.map(function (d) {
				return d.name;
			}))
			.range(opts.colors);

		var xDomain = data.hasOwnProperty('dx') ? [data.x, data.x + data.dx] : [0, width],
			yDomain = data.hasOwnProperty('dy') ? [data.y, data.y + data.dy] : [0, height];

		x.domain(xDomain).range([1, width - 2]);
		y.domain(yDomain).range([1, height - 2]);
	};

	treemap._configureLayout = function () {
		layout = d3.layout.treemap()
			.sticky(true)
			.value(function (d) {
				return d.value || 0;
			})
			.sort(function (a, b) {
				return a.value - b.value;
			})
			.mode(this._options.layout)
			.round(false);
	};

	treemap._initContainer = function () {
		var opts = this._options;

		var container = d3.select(opts.parent).selectAll('.cv-wrapper.cv-treemap').data([0]);
		container.enter()
			.append('div')
			.classed('cv-wrapper cv-treemap', true);

		chartContainer = container.selectAll('.chart-wrapper').data([0]);
		chartContainer.enter()
			.append('div')
			.classed('chart-wrapper', true)
			.style('position', 'relative');
		chartContainer
			.style('width', width + 'px')
			.style('height', height + 'px');

		nodeContainer = chartContainer.selectAll('.node-container').data([0]);
		nodeContainer.enter()
			.append('div')
			.classed('node-container', true)
			.style('overflow', 'hidden');
		nodeContainer
			.style('width', width + 'px')
			.style('height', (height) + 'px');
	};

	treemap._draw = function (data) {
		var self = this,
			opts = this._options,
			layoutData = {children: this._options.data},
			nodes = layout
				// When we give padding in d3's treemap layout, it applies the padding to each node,
				// including the root node which contains all parent and child nodes. In our treemap
				// we don't ever want to display this node even though d3's treemap layout allocates
				// width and height to it.
				//
				// To work around this, we pretend like the layout is taller than usual to
				// incorporate the padding our invisible node will occupy.  Then we'll shift every
				// node up by headingHeight number of pixels.  So we're essentially tricking d3's
				// treemap layout and then adjusting afterwards.
				.size([width, height + headingHeight])
				.padding([headingHeight, leftMargin, bottomMargin, rightMargin])
				.nodes(layoutData),
			children = nodes.filter(function (d) {
				return !d.children;
			}),
			parents = nodes.filter(function (d) {
				return d.parent && d.children;
			}),
			childrenSelected;

		var node = nodeContainer.selectAll('.cv-node').data(nodes);
		var newNodes = node.enter()
			.append('div')
			.classed('cv-node', true)
			.on('click', function (d, i) {
				// Add click events to items within the treemap main chart area (dept > 0)
				if (d.depth > 0) {
					var el = d3.select(this),
						selectedNodes = [];
					if (d.children) {// If click was on a container select all of its children
						selectedNodes = nodeContainer.selectAll('.second-level').filter(function (cn) {
							return (d.children.indexOf(cn) >= 0);
						});
						selectedNodes[0].push(this); // Add the parent header to the selection
						var previouslySelectedNodes = nodeContainer.selectAll('.cv-node.selected');
						var newSelectedNodes = [];
						if (previouslySelectedNodes[0].indexOf(this) >= 0 ){
							newSelectedNodes = previouslySelectedNodes[0].filter(function (prevNode){
								var found = (selectedNodes[0].indexOf(prevNode) >= 0);
								return !found;
							});
						} else {
							newSelectedNodes = selectedNodes[0].concat(previouslySelectedNodes[0]);
						}
						selectedNodes[0] = newSelectedNodes;

						self._selectNodes(selectedNodes);
					} else {
						selectedNodes = nodeContainer.selectAll('.cv-node.selected');
						var thisIdx = selectedNodes[0].indexOf(this),
							parent;

						// if it was alredy selected unselect it
						if (thisIdx >= 0) {
							selectedNodes[0].splice(thisIdx, 1);
							// when the parent and all its children are selected and we unselect
							// any of the children we need to unselect the parent too
							parent = self._getParentNode(this);
							var parentSelectedIdx = selectedNodes[0].indexOf(parent);
							if (parentSelectedIdx >= 0){
								childrenSelected = 0;
								parent.__data__.children.forEach(function (child){
									selectedNodes.each(function (selectedChild) {
										if (selectedChild == child){
											childrenSelected++;
										}
									});
								});
								if (parent.__data__.children.length-1 === childrenSelected){
									selectedNodes[0].splice(parentSelectedIdx, 1);
								}
							}
						} else {
							// if it is not selected add it
							selectedNodes[0].push(this);
							// If all the children in a group have been selected we need
							// to select also the parent
							parent = self._getParentNode(this);
							childrenSelected = 0;
							parent.__data__.children.forEach(function (child){
								selectedNodes.each(function (selectedChild) {
									if (selectedChild == child){
										childrenSelected++;
									}
								});
							});
							if (parent.__data__.children.length === childrenSelected){
								selectedNodes[0].push(parent);
							}

						}
						self._selectNodes(selectedNodes);
					}
					if (self._eventMap['click']) {
						self._eventMap['click'].call(this, d, i, d3.event);
					}
				}
			})
			.on('mouseover', function (d, i) {
				if (!d.children) {
					var el = d3.select(this),
						bounds = {
							x: d.x + d.dx / 4,
							y: d.y + d.dy / 2 - headingHeight,
							width: d.dx / 2,
							height: d.dy / 2
						},
						container = {
							x: 0,
							y: 0,
							width: chartContainer.node().getBoundingClientRect().width,
							height: chartContainer.node().getBoundingClientRect().height
						},
						content = null;
					el.classed('hovered', true);
					// Prepare content
					content = opts.tooltipContent.call(this, d, i);
					// show tooltip
					dv.showTooltip(
						bounds,
						container,
						content,
						'top',
						5,
						chartContainer
					);
					// Fire events
					if (self._eventMap['mouseover']) {
						self._eventMap['mouseover'].call(this, d, i, d3.event);
					}
				}
			})
			.on('mouseout', function (d, i) {
				if (!d.children) {
					var el = d3.select(this);
					el.classed('hovered', false);
					dv.removeTooltip(chartContainer);
					if (self._eventMap['mouseout']) {
						self._eventMap['mouseout'].call(this, d, i, d3.event);
					}
				}
			});
		newNodes.append('div');
		newNodes
			.call(position)
			.call(paint);
		node.exit().remove();
		node.classed('root-level', function (d) {
			return d.depth === layoutData.depth;
		})
		.classed('first-level', function (d) {
			return d.depth === layoutData.depth + 1;
		})
		.classed('second-level', function (d) {
			return d.depth === layoutData.depth + 2;
		})
		.call(paint)
		.call(position);
		node.select('div')
			.text(function (d) {
				var defaultLabel = d.hasOwnProperty('name') && d.parent === layoutData ? d.name : null;
				var label = d.hasOwnProperty('label') && d.parent === layoutData ? d.label : null;
				return label || defaultLabel;
			})
			.style('opacity', function (d) {
				return (d.dx < 50 || d.dy < 25) ? 0 : 1;
			});
	};


	treemap._selectNodes = function (nodes) {
		var selectedNodes = nodeContainer.selectAll('.cv-node.selected');
		selectedNodes.classed('selected', false);
		nodes.classed('selected', true);
	};

	treemap._getParentNode = function(node){
		var parentNode;
		var selectedNodes = d3.select(this._options.parent).selectAll('.first-level');
		selectedNodes[0].forEach(function(aParent){
			if (aParent.__data__.children.indexOf(node.__data__) >= 0){
				parentNode = aParent;
			}
		});
		return parentNode;
	};

	/**
	 * highlights the nodes matching the given selector function
	 *
	 * @param selector expression
	 * @param selectorFn
	 * @returns {treemap}
	 */
	treemap.setSelected = function (selectorFn) {
		var self = this;
		// set current selection
		var selectedNodes = d3.select(this._options.parent).selectAll('.second-level').filter(selectorFn);

		// For each node in the selection check if the parent node needs to be selected too
		selectedNodes[0].forEach(function (node){
			var parent = self._getParentNode(node),
				childrenSelected = 0;
			if (parent){
				parent.__data__.children.forEach(function (child){
					selectedNodes.each(function (selectedChild) {
						if (selectedChild == child){
							childrenSelected++;
						}
					});
				});
				if (parent.__data__.children.length === childrenSelected){
					selectedNodes[0].push(parent);
				}
			}
		});


		self._selectNodes(selectedNodes);
		return self;
	};

	/**
	 * Returns the selected nodes
	 *
	 * @returns {Array}
	 */
	treemap.getSelected = function () {
		var selectedNodes = [];
		var selected = nodeContainer.selectAll('.second-level.cv-node.selected');
		if (selected) {
			selected[0].forEach(function (node) {
				selectedNodes.push(node.__data__);
			});
		}
		return selectedNodes;
	};

	/**
	 * Creates the default content for the tooltip
	 *
	 * @param d
	 * @returns {string}
	 */
	function defaultTooltipContent(d) {
		return "<span class='series-name'>" + d.parent.name + "</span>" +
			"<span class='metric-value'>" + d.value + "</span>" +
			"<span class='metric-name'>" + d.name + "</span>";
	}


	/**
	 * Places the given selected node in position with in the treemap
	 *
	 * @param selection
	 */
	function position(selection) {
		var padding = function (d) {
			if (d.depth === 1) {
				return 3;
			}
			if (d.depth === 2) {
				return 1;
			}
			return 0;
		};

		selection
			.style('left', function (d) {
				return (x(d.x) + 1) + 'px';
			})
			.style('top', function (d) {
				// If this is our invisible root node, just set its top position to zero.
				if (d.children && !d.parent) {
					return 0;
				}
				// subtract the headingHeight because we are removing the root node's height from TreeMap
				// and are altering it's layout to move each child node up the distance of the root node's
				// root node height.
				return (y(d.y) + 1) - headingHeight + 'px';
			})
			.style('width', function (d) {
				return (x(d.x + d.dx) - x(d.x) - 2) + 'px';
			})
			.style('height', function (d) {
				// The default css height style for section titles will be used.
				if (d.children) {
					return null;
				}
				return (y(d.y + d.dy) - y(d.y) - 2) + 'px';
			});
	}

	/**
	 * Colors the given node with the correct color
	 *
	 * @param selection
	 */
	function paint(selection) {
		selection
			.style('background-color', function (d) {
				if (d.children || !d.parent) {
					return null;
				}
				return color(d.parent.name);
			});
	}

	global.cloudViz.treemap = cloudViz.util.createConstructor(treemap);
}(this));

// Copyright (c) 2013, Jason Davies.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//
//   * Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name Jason Davies may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

(function(global){
	"use strict";
	d3.wordcloud = function() {
		var wordcloud = {},
			data,
			size = [256, 256],
			p,
			$p,
			$wrapper,
			$container,
			svg,
			zoomContainer,

			options,
         spiral,
			padding,
         rotateRange = [0,90],
         timeInterval = Infinity,
         event = d3.dispatch("word", "end"),
         timer = null,
         fill = d3.scale.category20();

      wordcloud.draw = function() {
         $container = wordcloud.createSVGContainer();
         var wc = svg.append("g")
        .attr("transform", "translate(" + [size[0]/2, size[1]/2] + ")").selectAll("text").data(data);

         wc.enter()
				.append("text")
            .attr("transform", function(d) {
               return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
            })
            .style("fill", function(d, i) { return fill(i); })
            .attr("text-anchor", "middle")
            .style("font-size", function(d){ return d.size + "px"; })
            .style("font-family", function(d){ return d.font; })
            .text(function(d){ return d.text; });

      };

      wordcloud.start = function() {

			function step() {
            var start = +new Date(),
            d;
            while (+new Date() - start < timeInterval && ++i < n && timer) {
               d = data[i];
               d.x = (size[0] * (Math.random() + 0.5)) >> 1;
               d.y = (size[1] * (Math.random() + 0.5)) >> 1;
               cloudSprite(d, data, i);
               if (d.hasText && place(board, d, bounds)) {
                  tags.push(d);
                  event.word(d);
                  if (bounds){
							cloudBounds(bounds, d);
						}
                  else {
							bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];
						}
                  // Temporary hack
                  d.x -= size[0] >> 1;
                  d.y -= size[1] >> 1;
               }
            }
            if (i >= n) {
               wordcloud.stop();
               event.end(tags, bounds);
            }
         }

         var board = zeroArray((size[0] >> 5) * size[1]),
         bounds = null,
         n = data.length,
         i = -1,
         tags = [];
         data.forEach(function(d, i) {
            //d.text = text.call(this, d, i);
            d.font = options["fontFamily"];
            d.style = "normal"; //fontStyle.call(this, d, i);
            d.weight = "normal"; // fontWeight.call(this, d, i);
				if (options["allowIntermediateAngles"]){
					d.rotate = Math.random() * (rotateRange[1] - rotateRange[0]) + rotateRange[0];
				} else {
					d.rotate = ~~(Math.random()*2) * (rotateRange[1] - rotateRange[0]) - rotateRange[0];
				}
				//d.size = ~~fontSize.call(this, d, i);
            d.padding = options["padding"];// padding.call(this, d, i);
         });
         data.sort(function(a, b) { return b.size - a.size; });

         if (timer) {
				clearInterval(timer);
			}
         timer = setInterval(step, 0);
         step();

         return wordcloud;
      };

      wordcloud.stop = function() {
         if (timer) {
            clearInterval(timer);
            timer = null;
         }
         return wordcloud;
      };

      wordcloud.timeInterval = function(x) {
         if (!arguments.length) {
				return timeInterval;
			}
         timeInterval = x == null ? Infinity : x;
         return wordcloud;
      };

      function place(board, tag, bounds) {
         var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
         startX = tag.x,
         startY = tag.y,
         maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
         s = spiral(size),
         dt = Math.random() < 0.5 ? 1 : -1,
         t = -dt,
         dxdy,
         dx,
         dy;

         while (dxdy = s(t += dt)) {
            dx = ~~dxdy[0];
            dy = ~~dxdy[1];

            if (Math.min(dx, dy) > maxDelta) {
					break;
				}

            tag.x = startX + dx;
            tag.y = startY + dy;

            if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
               tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) {
						continue;
					}
            // TODO only check for collisions within current bounds.
            if (!bounds || !cloudCollide(tag, board, size[0])) {
               if (!bounds || collideRects(tag, bounds)) {


                  var sprite = tag.sprite,
                  w = tag.width >> 5,
                  sw = size[0] >> 5,
                  lx = tag.x - (w << 4),
                  sx = lx & 0x7f,
                  msx = 32 - sx,
                  h = tag.y1 - tag.y0,
                  x = (tag.y + tag.y0) * sw + (lx >> 5),
                  last;
                  for (var j = 0; j < h; j++) {
                     last = 0;
                     for (var i = 0; i <= w; i++) {
                        board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                     }
                     x += sw;
                  }
                  delete tag.sprite;
                  return true;
               }
            }
         }
         return false;
      }

      wordcloud.createSVGContainer = function() {
			$p = d3.select(p);

			$wrapper = $p.selectAll(".cv-wordcloud").data([data]);
			$wrapper.enter().append("div").classed("cv-wordcloud", true);
			$wrapper.style("width", size[0] + "px")
				.style("height", size[1] + "px");

			svg = $wrapper.selectAll("svg").data([data]);
			svg.enter().append("svg")
				.attr("width", "100%")
				.attr("height", "100%");
			svg.exit().remove();

			return svg;
		};

      wordcloud.data = function(_) {
			if (!arguments.length) { return data; }
			data = _;
			return wordcloud;
		};

      wordcloud.parent = function(_) {
			if (!arguments.length) { return p; }
			p = _;
			return wordcloud;
		};

      wordcloud.size = function(x) {
         if (!arguments.length) {
				return size;
			}
         size = [+x[0], +x[1]];
         return wordcloud;
      };

      wordcloud.options = function(_) {
			if (!arguments.length) { return options; }
			options = _;
         spiral = spirals[options["spiral"] + ""] || options["spiral"];
			return wordcloud;
		};

      wordcloud.rotateRange = function(_) {
			if (!arguments.length) { return rotateRange; }
			rotateRange = _;
         return wordcloud;
		};

		function EmptyDataException() {
			this.type = "EmptyDataException";
			this.message = "The data is empty or null";
			this.toString = function() { return this.type + " - " + this.message; };
		}

		function ParentNotSpecifiedException() {
			this.type = "ParentNotSpecifiedException";
			this.message = "A parent was not specified for this visualization";
			this.toString = function() { return this.type + " - " + this.message; };
		}

      wordcloud.setCallback = function(e, callback) {
         wordcloud.on(e, callback);
         return wordcloud;
      };

      //d3.rebind(wordcloud, event, "on");

		return d3.rebind(wordcloud, event, "on");
	};

   // Fetches a monochrome sprite bitmap for the specified text.
   // Load in batches for speed.
   function cloudSprite(d, data, di) {
      if (d.sprite) {
			return;
		}
      c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
      var x = 0,
      y = 0,
      w = 0,
      h = 0,
      maxh = 0,
      n = data.length;
      --di;
      while (++di < n) {
         d = data[di];
         c.save();
         c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
         w = c.measureText(d.text + "m").width * ratio;
         h = d.size << 1;
         if (d.rotate) {
            var sr = Math.sin(d.rotate * cloudRadians),
            cr = Math.cos(d.rotate * cloudRadians),
            wcr = w * cr,
            wsr = w * sr,
            hcr = h * cr,
            hsr = h * sr;
            w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
            h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
         } else {
            w = (w + 0x1f) >> 5 << 5;
         }
         if (h > maxh) {
				maxh = h;
			}
         if (x + w >= (cw << 5)) {
            x = 0;
            y += maxh;
            maxh = 0;
         }
         if (y + h >= ch) { break; }
         c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
         if (d.rotate) {
				c.rotate(d.rotate * cloudRadians);
			}
         c.fillText(d.text, 0, 0);
         if (d.padding) {
				c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);
			}
         c.restore();
         d.width = w;
         d.height = h;
         d.xoff = x;
         d.yoff = y;
         d.x1 = w >> 1;
         d.y1 = h >> 1;
         d.x0 = -d.x1;
         d.y0 = -d.y1;
         d.hasText = true;
         x += w;
      }
      var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      i = 0,
      sprite = [];
      while (--di >= 0) {
         d = data[di];
         if (!d.hasText) {
				continue;
			}
         w = d.width;
         var w32 = w >> 5;
         h = d.y1 - d.y0;
         // Zero the buffer
         for (i = 0; i < h * w32; i++) {
				sprite[i] = 0;
			}
         x = d.xoff;
         if (x == null) {
				return;
			}
         y = d.yoff;
         var seen = 0,
         seenRow = -1;
         for (var j = 0; j < h; j++) {
            for (i = 0; i < w; i++) {
               var k = w32 * j + (i >> 5),
               m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
               sprite[k] |= m;
               seen |= m;
            }
            if (seen) { seenRow = j; }
            else {
               d.y0++;
               h--;
               j--;
               y++;
            }
         }
         d.y1 = d.y0 + seenRow;
         d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
      }
   }

   // Use mask-based collision detection.
   function cloudCollide(tag, board, sw) {
      sw >>= 5;
      var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0,
      x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;
      for (var j = 0; j < h; j++) {
         last = 0;
         for (var i = 0; i <= w; i++) {
            if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
            & board[x + i]) { return true; }
         }
         x += sw;
      }
      return false;
   }

   function cloudBounds(bounds, d) {
      var b0 = bounds[0],
      b1 = bounds[1];
      if (d.x + d.x0 < b0.x) {
			b0.x = d.x + d.x0;
		}
      if (d.y + d.y0 < b0.y) {
			b0.y = d.y + d.y0;
		}
      if (d.x + d.x1 > b1.x) {
			b1.x = d.x + d.x1;
		}
      if (d.y + d.y1 > b1.y) {
			b1.y = d.y + d.y1;
		}
   }

   function collideRects(a, b) {
      return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
   }

   function archimedeanSpiral(size) {
     var e = size[0] / size[1];
     return function(t) {
       return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
     };
   }

   function rectangularSpiral(size) {
     var dy = 4,
         dx = dy * size[0] / size[1],
         x = 0,
         y = 0;
     return function(t) {
       var sign = t < 0 ? -1 : 1;
       // See triangular numbers: T_n = n * (n + 1) / 2.
       switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
         case 0:  x += dx; break;
         case 1:  y += dy; break;
         case 2:  x -= dx; break;
         default: y -= dy; break;
       }
       return [x, y];
     };
   }

   function zeroArray(n) {
      var a = [],
      i = -1;
      while (++i < n) {
			a[i] = 0;
		}
      return a;
   }



   var cloudRadians = Math.PI / 180,
   cw = 1 << 11 >> 5,
   ch = 1 << 11,
   canvas,
   ratio = 1;

   canvas = document.createElement("canvas");
   canvas.width = 1;
   canvas.height = 1;
   ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
   canvas.width = (cw << 5) / ratio;
   canvas.height = ch / ratio;
   var c = canvas.getContext("2d");
   c.fillStyle = c.strokeStyle = "red";
   c.textAlign = "center";
   var spirals = {
        archimedean: archimedeanSpiral,
        rectangular: rectangularSpiral
      };

   d3.wordcloud.gradIdCounter = 0; // This needs to be static so instances will share
}(this));

/**
 * Word Cloud
 * A word cloud shows words and their frequencies of occuring in a text
 * Parameters
 * options: customization parameters for the bar chart
 * options are defined in the core object, bar specific are below in 'Bar Options'
 **/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz || {}, dvcore = cloudViz.dvcore || {},
		dv = global.dv || {}, d3 = global.d3 || {},
		wordcloud = Object.create(dvcore),
		timeoutId = -1;

	wordcloud.init = function(options) {
      Object.getPrototypeOf(wordcloud).init.apply(this, arguments);

		this._type = 'wordcloud';
		this._chart = dv.chart();
      options = options || {};
      this._initDefaultOptions();
      this.setOptions(options);
      this._initWordcloud();
		return this;
   };

   wordcloud._initDefaultOptions = function() {
		var defaults = {
         fontFamily: "Impact",
         spiral: "archimedean",
         size: [800, 400],
         rotateRange: [0, 0],
         allowIntermediateAngles: false,
         padding: 1
		};
		return Object.getPrototypeOf(wordcloud)._initDefaultOptions.call(this, defaults);
	};

   wordcloud._initWordcloud = function() {
      this._wordcloud = d3.wordcloud();
   };

   wordcloud._render = function(){
      this._configure();
      //this._wordcloud.draw();
   };

   wordcloud._configure = function() {
      var options = this._options;
      options.data = this._dataAdapter.data();
      this._wordcloud
         .data(options.data)
         .parent(options.parent)
         .options(options)
         .size(options.size)
         .rotateRange(options.rotateRange)
         .setCallback("end", this._wordcloud.draw)
         .start();
   };

   global.cloudViz.wordcloud = cloudViz.util.createConstructor(wordcloud);
}(this));

/**
 * Data adapters are intended to process and interpret data in a way that is specific to a particular data format.
 * They then expose translated information to be used during the render process. Data adapters are created
 * as a convenience to consumers of CloudViz so that multiple consumers aren't forced to code the same translation
 * layer between their data format and the format that CloudViz expects.
 *
 * The "standard" data adapter does very little since it assumes the data is already in a format consumable by
 * CloudViz.
 */

(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		dv = global.dv,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard');

	var adapter = {};
	adapter._isDataValid = null;

	/**
	 * Intended to be called prior to rendering a chart. This function processes and interprets options in a way
	 * that is specific to a particular data format and exposes translated information to be used during the render
	 * process.
	 *
	 * @param {object} options All user-defined + default options. The keys are the option names while the values
	 * are the option values.
	 * @param {object} changedOptions All user-defined + default options that have been changed since the previous
	 * render. The keys are the option names while the values are the option values.
	 */
	adapter.process = function(options, changedOptions) {
		this._options = options;

		// We deep extend the definition to a new object so that when the consumer sets specific
		// l10n options to override portions of the locale definition it doesn't modify the original
		// definition object which would affect other charts rendered later.
		this.l10n = cloudViz.util.deepExtend({}, cloudViz.localeDefinition(options.locale), options.l10n || {});

		// only process if data and/or mappings is changed
		if (!('data' in changedOptions) && !('mappings' in changedOptions)) { return; }
		// and the data/mappings are valid
		if (!this._validateData(options.data, options.mappings)) { return; }

		this._processOptions(options, changedOptions);
	};


	/**
	 * Called by process after common setup is done. Intended to be overwritten by subclasses.
	 *
	 * @param {object} options All user-defined + default options. The keys are the option names while the values
	 * are the option values.
	 * @param {object} changedOptions All user-defined + default options that have been changed since the previous
	 * render. The keys are the option names while the values are the option values.
	 * @returns {boolean} true to allow processing to occur
	 */
	adapter._processOptions = function(options, changedOptions) {};

	/**
	 * Determines if the x data is overtime or not. X data is overtime if it consists of javascript Date objects
	 * @param  {x:[]} data A data object of tuples with at least an x property with an array.
	 * @return {boolean} True if overtime, false otherwise
	 */
	adapter._determineOvertime = function(data) {
		var mappings = this.mappings(),
			dates = data[mappings['x']];

		if (!dates || !dates.length) { return false; }
		return dv.util.isDate(dates[0]) || // is an actual date obj
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.test(dates[0]); // matches common date formats
	};

	/**
	 * Looks at the data points time range and determines the time granularity
	 * Will return '*' if its unable to determine a granularity
	 * @param {x:[]} data A data object of tuples with at least an x property with an array.
	 * @returns {string} - 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year', '*'
	 */
	adapter._calculateDateGranularity = function(data) {
		var mappings = this.mappings(),
			dates = data[mappings['x']];
		if (!dates || !dates.length) { return '*'; }
		// cast as dates
		dates = dates.map(function(d) { return new Date(d); });
		// Simple algorithm will be to determine the min/max and number of points to determine an avg range
		var min = Math.min.apply(Math, dates), max = Math.max.apply(Math, dates),
			range = (max - min) / 1000, step = range / dates.length;
		return this.getTimeGranularity(step).gran;
	};

	/**
	 * Passed a step value in seconds will determine the correct granularity
	 * If total is true, step is the total so determine it differently
	 * @returns {string} - 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year', '*'
	 */
	adapter.getTimeGranularity = function(step, total) {
		var gran = 'second', divisor = 1;
		if (!step) { return { gran : gran, divisor : divisor }; }
		if (total) {
			// Total means that we are displaying the entire value rather than in steps
			// So we go from largest to smallest
			if (step >= (divisor = 60 * 60 * 24 * 365)) { gran = 'year'; }
			else if (step >= (divisor = 60 * 60 * 24 * 31)) { gran = 'month'; }
			else if (step >= (divisor = 60 * 60 * 24 * 7)) { gran = 'week'; }
			else if (step >= (divisor = 60 * 60 * 24)) { gran = 'day'; }
			else if (step >= (divisor = 60 * 60)) { gran = 'hour'; }
			else if (step >= (divisor = 60)) { gran = 'minute'; }
			else {
				gran = 'second';
				divisor = 1;
			}
		} else {
			// Step means the time has been divided into units and we want to show the number
			// of those units for the total amount of time
			if (step <= (divisor = 1)) { gran = 'second'; } // second
			else if (step <= (divisor = 60)) { gran = 'minute'; } // minute
			else if (step <= (divisor = 60 * 60)) { gran = 'hour'; } // hour
			else if (step <= (divisor = 60 * 60 * 24)) { gran = 'day'; } // day
			else if (step <= (divisor = 60 * 60 * 24 * 7)) { gran = 'week'; } // weekly
			else if (step <= (divisor = 60 * 60 * 24 * 31)) { gran = 'month'; } // monthly
			else { // yearly
				gran = 'year';
				divisor = 60 * 60 * 24 * 365;
			}
		}
		return { gran : gran, divisor : divisor };
	};

	adapter._getYTitleFromLabels = function(labels) {
		// If we only have 1 type of label, we should label the y axis.  This is particularly
		// important in the case of interactive legends which don't show the metrics within tabs
		// because there is only one metric.  In this case there would be no way to know what
		// metric is represented by the y axis.  The y axis title is the only way to get that
		// info.
		var uniqLabels = dv.util.uniq(labels);
		if (uniqLabels && uniqLabels.length === 1) {
			return uniqLabels[0];
		}
		return null;
	};

	/**
	 * An object of data tuples. The properties on the data object are used to map visual properties on the chart.
	 *
	 * <pre><code>
	 *     {
	 *         foo: [1, 2, 3, 4, 5],
     *         bar: [10, 8, 7, 15, 20]
	 *     }
	 * </code></pre>
	 *
	 * @returns {object}
	 */
	adapter.data = function() {
		return this._options.data;
	};

	/**
	 * An object mapping tuples from the data object to visual aesthetics on the chart.
	 *
	 * <pre><code>
	 *     {
	 *         x: 'foo'
     *         y: 'bar'
	 *     }
	 * </code></pre>
	 *
	 * @returns {object}
	 */
	adapter.mappings = function() {
		return this._options.mappings;
	};

	/**
-    * An object defining how number values should be formatted for each axis. Possible values include currency, percent,
-    * decimal, and time. Since y supports multiple axes, an array can be used instead of a string.  If a string is provided,
	 * that y format is applied to all series.  If an array is provided for y, each format maps to each series.
-    *
-    * <pre><code>
-    *     {
-    *         x: 'percent',
-    *         y: [ 'currency', 'decimal' ],
	 *         size: 'time'
-    *     }
-    * </code></pre>
-    *
-    * @returns {array}
-    */
	adapter.formats = function() {
		return this._options.formats;
	};

	/**
	 * The user-friendly name of the metric mapped to the x aesthetic.
	 * @returns {string}
	 */
	adapter.xAxisTitle = function() {
		return this._options.xAxisTitle || null;
	};

	/**
	 * The user-friendly name of the metric mapped to the y aesthetic.
	 * @returns {string}
	 */
	adapter.yAxisTitle = function() {
		return this._options.yAxisTitle || null;
	};

	/**
	 * The date granularity if the x data is time-based. Possible values are year, quarter, month, week, day, hour, minute and second.
	 * @return {string}
	 */
	adapter.dateGranularity = function() {
		return this._processedOptions.dateGranularity;
	};

	/**
	 * Array of colors to use for fill/stroke based on visualization
	 * @returns {array}
	 */
	adapter.colors = function() {
		return this._processedOptions.colors;
	};

	/**
	 * Whether the data is sufficiently valid to be properly rendered.
	 * @returns {boolean}
	 */
	adapter.isDataValid = function() {
		return this._validateData(this._options.data, this._options.mappings);
	};

	/**
	 * Determines if the data object exists and that it has at least one non-empty array of data.
	 * @param {object} data
	 * @param {object} mappings
	 * @returns {boolean}
	 * @private
	 */
	adapter._validateData = function(data, mappings) {
		if (!data) { return false; }
		for (var key in data) {
			if (data[key].length) { return true; }
		}
		return false;
	};

	/**
	 * The "blueprint" of the adapter. This can be used as a prototype object that other adapters can extend. This
	 * is neither intended to be used directly nor instantiated using the "new" keyword.
	 * @type {object}
	 */
	standardAdapters.baseObj = adapter;

	/**
	 * The constructor of the adapter. This is intended to be called in order to instantiate a new adapter object.
	 * Any arguments passed to the function will be passed to the adapter's init() function if one exists.
	 * @type {function}
	 */
	standardAdapters.base = cloudViz.util.createConstructor(adapter);
}(this));
/*global dv*/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj);

	/**
	 * @see base#_processOptions
	 */
	adapter._processOptions = function(options, changedOptions) {
		var processedOptions = this._processedOptions = Object.create(options);
		// We can't simple get the options.data or options.mappings here
		// We need to call to get it in case this class is extended and the data/mappings were changed
		var data = this.data(), mappings = this.mappings();

		// If isOvertime has been set, it was done by a more specific data adapter and doesn't need to be
		// done again.
		if (processedOptions.isOvertime == null) {
			processedOptions.isOvertime = this._determineOvertime(data);

			if (processedOptions.isOvertime) {
				processedOptions.dateGranularity = processedOptions.dateGranularity || this._calculateDateGranularity(data);
			}
		}

		this._uniqueFillValues = this._processUniqueFillValues(data, mappings);
		this._uniqueFillExtents = this._processUniqueFillExtents(data, mappings, this._uniqueFillValues);
		this._uniqueXValues = this._processUniqueXValues(data, mappings, processedOptions.isOvertime);

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	/**
	 * Whether the data is time-based.
	 * @returns {boolean}
	 */
	adapter.isOvertime = function() {
		return this._processedOptions.isOvertime;
	};

	adapter.uniqueFillValues = function() {
		return this._uniqueFillValues || [];
	};

	adapter.uniqueFillExtents = function() {
		return this._uniqueFillExtents;
	};

	adapter.uniqueXValues = function() {
		return this._uniqueXValues || [];
	};

	// Should only be used when dual y axis is set and the first and second series are different scales
	adapter.getUniqueFillExtent = function(scaleIndex) {
		var uniqueFillValue = this._uniqueFillValues[scaleIndex];
		if (uniqueFillValue) {
			return this._uniqueFillExtents[uniqueFillValue];
		}
		return null;
	};

	// Returns the extent of all the y data within a given series specified by fill.
	adapter.getUniqueFillExtentByFill = function(fill) {
		return this._uniqueFillExtents[fill];
	};

	/**
	 * Retrieves unique values from the tuple mapped to the fill aesthetic.
	 * @param {object} data
	 * @param {object} mappings
	 * @returns {array}
	 * @private
	 */
	adapter._processUniqueFillValues = function(data, mappings) {
		var tuple = data[mappings['series']];
		return tuple ? dv.util.uniq(tuple) : [];
	};

	/**
	 * Processes all the min/max y values of each series.
	 * @param {object} data
	 * @param {object} mappings
	 * @returns {object}
	 */
	adapter._processUniqueFillExtents = function(data, mappings, uniqueFillValues) {
		var fillTuple = data[mappings['series']],
			yTuple = data[mappings['y']],
			extents = {};

		yTuple.map(function(d, i) {
			var fillValue = fillTuple[i];
			if (!isFinite(d) || d === null) { return; } // ignore undefined/null
			if (!extents[fillValue]) {
				extents[fillValue] = [d, d];
			}
			extents[fillValue][0] = Math.min(d, extents[fillValue][0]);
			extents[fillValue][1] = Math.max(d, extents[fillValue][1]);
		});

		return extents;
	};

	adapter._processUniqueXValues = function(data, mappings, isOvertime) {
		// If the dataset is overtime, don't worry about this.  We're mostly looking for the number of range bands
		// that we can use for ordinal bars to see how much space should exist between them.  With overtime bars,
		// there are no bands, and the space between bars is fixed to a very small number to make the bars very
		// close together like a histogram should look.
		if (isOvertime) {
			return [];
		}
		else {
			var tuple = data[mappings['x']];
			return tuple ? dv.util.uniq(tuple) : [];
		}
	};

	standardAdapters.barObj = adapter;
	standardAdapters.bar = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj),
		d3 = global.d3 || {};

	adapter._processOptions = function(options, changedOptions) {
		Object.getPrototypeOf(adapter)._processOptions.apply(this, arguments);
	};

	adapter._validateData = function(data, mappings) {
		if (!data) { return false; }
		return true;
	};

	adapter.data = function() {
		return this._options.data;
	};

	adapter.metric = function() {
		return this._options.metric;
	};

	adapter.format = function() {
		return this._options.format;
	};

	standardAdapters.choroplethObj = adapter;
	standardAdapters.choropleth = cloudViz.util.createConstructor(adapter);
}(this));
/*global dv*/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		// Donut inherits from standard bar so we get the unique fill methods
		// Since its basically a polar bar chart, this works nicely
		adapter = Object.create(standardAdapters.barObj),
		// Maximum number of facets (individual donuts) that we will render
		maxFacets = 3;

	/**
	 * @see base#_processOptions
	 */
	adapter._processOptions = function(options, changedOptions) {
		this._processCategories(options);
		Object.getPrototypeOf(adapter)._processOptions.call(this, this._processedOptions, changedOptions);
	};

	/**
	 * Manipulates the data in order to:
	 * 1: Sort the data per facet in descending value
	 * 2: Limit the number of slices in a facet to maxSlices
	 * 3: Limit the number of facets to maxFacets
	 * This is done by converting the parallel arrays to a single array of objects, sorting
	 * and then converting back to parallel arrays
	 * For #3:
	 * If the number of facets > maxSlices, collapse (maxSlices-1)+ into single 'other' category
	 * @private
	 **/
	adapter._processCategories = function(options) {
		var processedOptions = Object.create(options),
			data = Object.create(options.data), mappings = options.mappings,
			valKey = mappings['y'], catKey = mappings['x'],
			facetKey = mappings['series'],
			facetLabelKey = mappings['seriesLabel'] || facetKey,
			collection = [], i, ii = data[valKey].length, k,
			facets = [], facetLabels = [], facetsOrder = {}, value,
			categoryOrder = [], colorOrder = [],
			colors = processedOptions.colors;

		// Compile the parallel arrays into a single array
		// Also populates the labelOrder for use in sorting later
		// Also populates the original category order to update color order
		for (i=0; i<ii; ++i) {
			collection[i] = {};
			for (k in data) {
				value = data[k][i];
				if (k === facetKey) {
					if (facets.length) {
						if (value !== facets[facets.length-1]) {
							if (facets.length === this.maxFacets) {
								// total facets already
								ii--;
								i--;
								collection.pop();
								break; // exit the k for loop
							}
							facets[facets.length] = value;
							facetLabels[facetLabels.length] = data[facetLabelKey][i];
							facetsOrder[value] = facets.length;
						}
					} else {
						facets = [value];
						facetLabels = [data[facetLabelKey][i]];
						facetsOrder[value] = facets.length;
					}
				}
				if (k === catKey) {
					// store original ordering of categories with colors
					if (categoryOrder.indexOf(value) === -1) {
						colorOrder.push(colors[categoryOrder.length % colors.length]);
						categoryOrder.push(value);
					}
				}
				collection[i][k] = value;
			}
		}
		// Sort the array by the key
		this.numFacets = facets.length;
		var sort = processedOptions.sort;
		collection.sort(function(a, b) {
			// if values are the same facet (same donut viz), sort by value
			if (a[facetKey] === b[facetKey]) {
				if (sort === 'none') {
					return 0; // don't sort
				}
				if (sort === 'ascending') {
					return a[valKey] - b[valKey];
				}
				return b[valKey] - a[valKey];
			}
			// otherwise sort by facets order
			return facetsOrder[a[facetKey]] - facetsOrder[b[facetKey]];
		});
		// reset data arrays
		for (k in data) {
			data[k] = [];
		}
		data['cvdonutorder'] = [];
		// reset colors
		colors = [];

		// Break out again into parallel arrays and compile extra slices into 'other'
		var facetCount = 0, lastFacet, facet, max = this._options.maxSlices,
			newCategoryOrder = [], category;
		this.otherIncluded = false;
		for (i=0, ii=collection.length; i<ii; ++i) {
			// Count along a facet and collapse if we get above maxSlices
			facet = collection[i][facetKey];
			category = collection[i][catKey];
			if (facet !== lastFacet) {
				facetCount = 0;
				lastFacet = facet;
			}
			if (facetCount == max - 1 && i+1 < ii && collection[i+1][facetKey] === facet) {
				// look ahead and see if the next item is the same facet
				// if so, we need to start combining, so create the Other category
				for (k in data) {
					if (!data[k]) { data[k] = []; }
					data[k][i] = collection[i][k];
				}
				this.otherIncluded = true;
				data[catKey][i] = this.l10n.labels.core.other;
				++facetCount;
				data['cvdonutorder'][i] = i;
				continue;
			}
			if (facetCount >= max) { // 'other' is previous, append
				// update value
				data[valKey][i-1] += collection[i][valKey];
				// remove and set i back
				collection.splice(i, 1);
				ii = collection.length;
				--i;
				++facetCount;
				continue;
			}
			++facetCount;

			for (k in data) {
				data[k][i] = collection[i][k];
			}
			// update colors option array with new ordering of categories
			if (newCategoryOrder.indexOf(category) === -1) {
				colors.push(colorOrder[categoryOrder.indexOf(category)]);
				newCategoryOrder.push(category);
			}

			// this is needed to set the grouping so DV correctly orders the sorted values
			data['cvdonutorder'][i] = i;
		}

		// Update the yAxisTitle
		// Get the array values string names of the facet groups
		processedOptions.yAxisTitle = options.yAxisTitle || facetLabels;

		processedOptions.data = data;
		processedOptions.colors = colors;
		this._processedOptions = processedOptions;
	};

	/**
	 * Create y values for each text percentage to position correctly around graph
	 * converting the values to between 0 and 100 and also saving off as labels and positioning
	 * This should all go away once we can use DV labels for donuts
	 * @param {object} each category's state (active/inactive) - null if all active or not interactive
	 * @public
	 */
	adapter.processLabelData = function(legend) {
		var d = this.data(), mappings = this.mappings(),
			data = this._labelData = Object.create(d),
			numTotals = {}, visTotals = {}, self = this,
			facets = data[mappings['series']],
			values = data[mappings['y']],
			slices = data[mappings['x']];

		// Store totals for each facet
		facets.forEach(function(v, i) {
			if (numTotals[v] === undefined) { numTotals[v] = 0; }
			if (visTotals[v] === undefined) { visTotals[v] = 0; }
			numTotals[v] += values[i];
			if (!legend.isSeriesEnabled || legend.isSeriesEnabled(slices[i])) {
				visTotals[v] += values[i];
			}
		});

		var	textValue = ( data.cvtextvalue = [] ),
			textPercentLabel = ( data.cvtextperclabel = [] ),
			textValueLabel = (data.cvtextvallabel = [] ),
			preValue = {}, facet, percent, visPercent, visible;
		values.forEach(function(v, i) {
			facet = facets[i];
			percent = (parseFloat(v) / numTotals[facet]) * 100;
			textValueLabel[i] = v;
			textPercentLabel[i] = ((percent % 1 !== 0) ? percent.toFixed(1) : percent ) + '%'; // TODO: Localized
			// handle visible separate
			visible = !legend.isSeriesEnabled || legend.isSeriesEnabled(slices[i]);
			visPercent = (parseFloat(v) / visTotals[facet]) * 100;
			if (preValue[facet] === undefined) { preValue[facet] = 0; }
			textValue[i] = (visible) ? preValue[facet] + (visPercent/2) : 0; // center on the data it represents
			preValue[facet] += (visible) ? visPercent : 0;
		});
	};

	/**
	 * Returns the processed data
	 * @returns {number}
	 */
	adapter.data = function() {
		return this._processedOptions.data;
	};

	/**
	 * Returns the data with labels data
	 * @returns {number}
	 */
	adapter.labelData = function() {
		return this._labelData;
	};

	/**
	 * Determines the correct yAxisTitle aka individual chart title
	 * @returns {number}
	 */
	adapter.yAxisTitle = function(facetIndex) {
		var title = this._processedOptions.yAxisTitle;
		if (title instanceof Array && title.length > facetIndex) { title = title[facetIndex]; }
		return title;
	};

	/**
	 * Whether the chart will inclue an 'Other' category
	 * This category usually represents a number of smaller categories
	 * that couldn't visually fit on the cart
	 * @returns {boolean}
	 */
	adapter.showOtherCategory = function() {
		return this.otherIncluded;
	};

	/**
	 * Returns the number of facets or individual donuts rendered in the chart
	 * @returns {number}
	 */
	adapter.numberOfFacets = function() {
		return this.numFacets;
	};

	standardAdapters.donutObj = adapter;
	standardAdapters.donut = cloudViz.util.createConstructor(adapter);
}(this));
/*global dv*/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj);

	/**
	 * @see base#_processOptions
	 */
	adapter._processOptions = function(options, changedOptions) {
		var processedOptions = this._processedOptions = Object.create(options);

		// We can't simple get the options.data or options.mappings here
		// We need to call to get it in case this class is extended and the data/mappings were changed
		var data = this.data(), mappings = this.mappings();
		this._forceZero = options.forceZero;
		this._uniqueStrokeValues = this._processUniqueStrokeValues(data, mappings);
		this._uniqueStrokeExtents = this._processUniqueStrokeExtents(data, mappings);

		// If isOvertime has been set, it was done by a more specific data adapter and doesn't need to be
		// done again.
		if (processedOptions.isOvertime == null) {
			processedOptions.isOvertime = this._determineOvertime(data);

			if (processedOptions.isOvertime) {
				processedOptions.dateGranularity = processedOptions.dateGranularity || this._calculateDateGranularity(data);
			}
		}

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	/**
	 * Whether the data is time-based.
	 * @returns {boolean}
	 */
	adapter.isOvertime = function() {
		return this._processedOptions.isOvertime;
	};

	/**
	 * An array of distinct values from the tuple mapped to the stroke aesthetic.
	 * Stroke is visually the grouping of series, as oppose to group which is different geoms (but possibly the same stroke)
	 * @returns {array}
	 */
	adapter.uniqueStrokeValues = function() {
		return this._uniqueStrokeValues || [];
	};

	adapter.uniqueStrokeExtents = function() {
		return this._uniqueStrokeExtents;
	};

	adapter.getUniqueStrokeExtent = function(scaleIndex) {
		var uniqueStrokeValue = this._uniqueStrokeValues[scaleIndex];
		if (uniqueStrokeValue) {
			return this._uniqueStrokeExtents[uniqueStrokeValue];
		}
		return null;
	};

	adapter.getUniqueStrokeExtentByStroke = function(stroke) {
		return this._uniqueStrokeExtents[stroke];
	};

	/**
	 * Retrieves unique values from the tuple mapped to the stroke aesthetic.
	 * @param {object} data
	 * @param {object} mappings
	 * @returns {array}
	 * @private
	 */
	adapter._processUniqueStrokeValues = function(data, mappings) {
		var tuple = data[mappings['series']];
		return tuple ? dv.util.uniq(tuple) : [];
	};

	/**
	 * Processes all the min/max y values of each series.
	 * @param {object} data
	 * @param {object} mappings
	 * @returns {object}
	 * @private
	 */
	adapter._processUniqueStrokeExtents = function(data, mappings) {
		var strokeTuple = data[mappings['series']],
			yTuple = data[mappings['y']],
			extents = {};

		yTuple.map(function(d, i) {
			var strokeValue = strokeTuple[i];
			if (!isFinite(d) || d === null) { return; } // ignore undefined/null
			if (!extents[strokeValue]) {
				extents[strokeValue] = [d, d];
			}
			extents[strokeValue][0] = Math.min(d, extents[strokeValue][0]);
			extents[strokeValue][1] = Math.max(d, extents[strokeValue][1]);
		});
		return extents;
	};

	standardAdapters.lineObj = adapter;
	standardAdapters.line = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj);

	/**
	 * The user-friendly name of the metric mapped to the size aesthetic.
	 * @returns {null}
	 */
	adapter.sizeMetricName = function() {
		return this._options && this._options.sizeTitle || null;
	};

	/**
	 * Checks the size mapping for data.
	 * @returns {boolean}
	 */
	adapter.isBubble = function() {
		var size = this.mappings()['size'];
		return size && size.length;
	};

	standardAdapters.pointObj = adapter;
	standardAdapters.point = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj);

	/**
	 * @see base#_processOptions
	 */
	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = this._processedOptions = Object.create(options),
			data = JSON.parse(JSON.stringify(options.data)); // make a deep copy of the data

		// Map the nodes to an internal id to track them, using index
		data.nodesById = [];
		data.nodes.map(function(n, i) {
			n._pid = i;
			data.nodesById[i] = n;
			return n;
		});

		// Convert the paths into individual links
		data.links = [];
		data.linksById = [];
		var src, target, val, id, link, adap = this;

		// munge the paths first
		data.paths = data.paths.filter(function(p) {
			// Convert single value in values into array
			if (!(p.values instanceof Array)) {
				p.values = Array.apply(null, new Array(p.nodes.length - 1)).map(function(){ return p.values; });
			}

			// remove all paths that have 0 or negative values
			if (p.values.some(function(v) { return v <= 0; })) { return false; }

			// Convert p.nodes to use _pid rather than index (so we can change the order later)
			p.nodes.map(function(n) { return (n !== null) ? data.nodes[n]._pid : null; });
			return true;
		});

		// create links
		data.paths.forEach(function(p, i) {
			p.nodes.forEach(function(n, ni) {
				if (!ni) {
					src = p.nodes[ni];
					if (src !== null) {
						data.nodesById[src].isPathStart = true;
						if (data.nodesById[src].isPathEnd) {
							data.nodesById[src].isPivot = true;
						}
					}
					return; // ignore first
				}
				src = p.nodes[ni-1];
				target = n;
				if (ni === p.nodes.length -1) {
					if (target !== null) {
						data.nodesById[target].isPathEnd = true;
						if (data.nodesById[target].isPathStart) {
							data.nodesById[target].isPivot = true;
						}
					}
				}
				val = p.values[ni-1];
				id = adap._generateLinkId(src, target);
				// If we already have a link, add the value and store reference to the path
				if (link = data.linksById[id]) {
					link.value += val;
					link.paths.push(i);
				} else {
					// Otherwise create a new link
					link = {
						source : src,
						target : target,
						value : val,
						paths : [i]
					};
					data.linksById[id] = link;
					data.links.push(link);
				}
			});
		});

		processedOptions.data = data;
		Object.getPrototypeOf(adapter)._processOptions.apply(this, arguments);
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	/**
	 * Returns a function that will determine how D3 pairs SVG elements with node data objects
	 * @returns {func}
	 * @private
	 */
	adapter.nodeKey = function() {
		return function(d, i) {
			return d.column + ':' + d.row;
		};
	};

	/**
	 * Returns a function that will determine how D3 pairs SVG elements with link objects
	 * @returns {func}
	 * @private
	 */
	adapter.linkKey = function() {
		return function(d, i) {
			var t = d.target, s = d.source,
				tid = t ? t.column + ':' + t.row : 'null',
				sid = s ? s.column + ':' + s.row : 'null';
			return sid + '-' + tid;
		};
	};

	/**
	 * The user-friendly name of the metric that we are pathing on
	 * @returns {string}
	 */
	adapter.pathingTitle = function() {
		return '';
	};

	/**
	 * Determines the end of the path and returns the value of the node
	 * @param {object} path obj with nodes and values array
	 * @returns {obj} node obj
	 */
	adapter.getPathEnd = function(path) {
		return null; // TODO: Implement for base pathing chart...we don't know which of the ends we should return
	};

	/**
	 * Returns the direction of the path, 1 origin of the path is the start, -1 origin is at the end
	 * @param {object} path obj with nodes and values array
	 * @returns {number} 1 from, -1 to, 0 no direction found
	 */
	adapter.getPathDirection = function(path) {
		return 0;
	};

	/**
	 * Returns title for paths
	 * @param {arra} array of pathing objects
	 * @returns {string} title
	 */
	adapter.activePathsTitle = function(paths) {
		return (paths && paths.length) ? this.l10n.labels.pathing['path2+'] : '';
	};

	/**
	 * Verify that pathing data is valid
	 * @param {object} data
	 * @returns {boolean}
	 * @private
	 */
	adapter.isValidPathingData = function() {
		var data = this.data();
		if (!data) { return false; }
		if (!data.nodes || !data.paths) { return false; }
		if (!data.nodes.length) { return false; }

		return true;
	};

	/**
	 * Generate a unique id for a link based on the nodes it connects to
	 * @param {num} source node index
	 * @param {num} target node index
	 * @returns {string}
	 * @private
	 */
	adapter._generateLinkId = function(s, t) {
		return s + '-' + t;
	};

	/**
	 * Pass the src node and the direction that has first priority on the sort
	 * @param {object} data node
	 * @param {num} direction (1 or -1)
	 * @returns {func}
	 * @private
	 */
	adapter._sortPaths = function(node, dir) {
		var data = this.data();
		return function sort(a, b) {
			// given two indexes:
			// -1 if aIndex < bIndex or bIndex does not exist
			// 1 if bIndex < aIndex or aIndex does not exist
			// 0 if paths match all the way down or aIndex and bIndex don't exist
			function checkNodes(aIndex, bIndex, mod) {
				var aMod = aIndex + mod,
					bMod = bIndex + mod;
				// Now go to nodes
				var aValue = (aMod < a.nodes.length && aMod >= 0) ? a.nodes[aMod] : -1,
					bValue = (bMod < b.nodes.length && bMod >= 0) ? b.nodes[bMod] : -1;

				// get index of node
				if (aValue !== -1 && aValue !== null) { aValue = data.nodes.indexOf(data.nodesById[aValue]); }
				if (bValue !== -1 && bValue !== null) { bValue = data.nodes.indexOf(data.nodesById[bValue]); }

				// Handle entrance/exit
				if (null === aValue && null === bValue) { return 0; }
				if (null === aValue) { return (mod > 0) ? 1 : -1; } // enter first, exit last
				if (null === bValue) { return (mod > 0) ? -1 : 1; }
				// Now handle one path being longer
				if (-1 === aValue && -1 === bValue) { return 0; }
				if (-1 === aValue) { return 1; }
				if (-1 === bValue) { return -1; }
				// Now look at which node is before (above vertically)
				var dif = aValue - bValue;
				if (dif !== 0) { return dif; }
				// Same node, go deeper on the path
				return checkNodes(aMod, bMod, mod);
			}
			var aIndex = a.nodes.indexOf(node._pid),
				bIndex = b.nodes.indexOf(node._pid),
				value = checkNodes(aIndex, bIndex, dir);
			if (0 === value) {
				// try other side of nodes
				value = checkNodes(aIndex, bIndex, -dir);
			}
			if (0 !== value) { return value; }
			return b.nodes.length - a.nodes.length;
		};

	};

	/**
	 * Parses the passed path object and creates link objects
	 * The offset for the links is assumed to be reset before calling this method
	 * as it is used across multiple paths
	 * @returns {array}
	 */
	adapter._generatePathLinks = function(path, index, activeNode) {
		var data = this.data(), adap = this,
			src, target, srcNode, targetNode,
			val, prevCombined, combined, height,
			links = [];

		if (!path || !path.nodes) { return links; }
		path.nodes.forEach(function(n, i, arr) {
			if (!i) { return; }
			src = path.nodes[i-1];
			target = n;
			srcNode = data.nodesById[src] || null;
			targetNode = data.nodesById[target] || null;
			val = path.values[i-1];
			// get combined link information
			// to allow us to place the links correctly spacially
			prevCombined = null;
			if (i > 1) { // there is another path to link to
				prevCombined = data.linksById[
					adap._generateLinkId(path.nodes[i-2], src)
				];
			}
			combined = data.linksById[adap._generateLinkId(src, target)];
			height = (val / combined.value) * combined.dy;
			// push previous node
			if (srcNode) {
				links.push({
					dy : height,
					// handle first node in path by just having it stay straight (using combined)
					// handle drawing from previous combined link, negating previous height offset value
					// TODO: handle multiple values in a path aka we can't assume the same height
					sy : (prevCombined) ? prevCombined.ty + prevCombined.offset - height: combined.sy + combined.offset,
					// for exits, always have them end at the bottom
					ty : (!targetNode) ? srcNode.dy - height : combined.sy + combined.offset,
					source : {
						x : srcNode.x,
						y : srcNode.y,
						dx : 0
					},
					target : {
						x : srcNode.x + srcNode.dx,
						y : srcNode.y
					},
					value : val,
					path : index,
					pivotStart : srcNode.isPivot
				});
			}

			// push link
			links.push({
				dy : height,
				sy : combined.sy + combined.offset,
				ty : combined.ty + combined.offset,
				source : srcNode,
				target : targetNode,
				value : val,
				path : index
			});

			// push next node if last path and not an exit
			if (i + 1 === arr.length && targetNode) {
				links.push({
					dy : height,
					sy : combined.ty + combined.offset,
					ty : combined.ty + combined.offset,
					source : {
						x : targetNode.x,
						y : targetNode.y,
						dx : 0
					},
					target : {
						x : targetNode.x + targetNode.dx,
						y : targetNode.y
					},
					value : val,
					path : index,
					pivotEnd : targetNode.isPivot
				});
			}
			combined.offset += height;
		});
		return links;
	};

	/**
	 * Parses the passed node object and returns the paths
	 * @param {object} node data object
	 * @returns {array}
	 */
	adapter.nodePaths = function(node) {
		var data = this.data(),
			paths = data.paths.filter(function(p) {
				return p.nodes.indexOf(node._pid) !== -1;
			});
		return  paths;
	};

	/**
	 * Sorts passed paths and returns those as link objects that can be rendered as overlays
	 * @param {array} array of path objects
	 * @param {object} node data object
	 * @returns {array}
	 */
	adapter.nodePathData = function(paths, node) {
		var data = this.data(), adap = this,
			links = [], dlinks = data.links;

		// clear/set offsets
		dlinks.forEach(function(l) { l.offset = 0; });
		// sort paths by node and then by length
		// this gives the end result of it looking like its sorted by y value
		paths.sort(adap._sortPaths(node, -1));
		// loop over each path and its nodes to create individual links
		paths.forEach(function(p, i) {
			links = links.concat(adap._generatePathLinks(p, i, node));
		});
		return links;
	};

	/**
	 * Parses the passed link object, filters and sorts the paths and returns them
	 * @returns {array}
	 */
	adapter.linkSortActivePaths = function(link) {
		var data = this.data(),
			paths = data.paths, linkPaths,
			node = (link.source) ? link.source : link.target;
		// clear/set offsets
		data.links.forEach(function(l) { l.offset = 0; });
		linkPaths = link.paths.map(function(l) { return paths[l]; });
		linkPaths.sort(this._sortPaths(node, -1));
		return linkPaths;
	};

	/**
	 * Return link objects that can be rendered as overlays for paths
	 * @returns {array}
	 */
	adapter.linkPathData = function(paths) {
		var links = [], adap = this;
		// loop over each path and its nodes to create individual links
		paths.forEach(function(p, i) {
			links = links.concat(adap._generatePathLinks(p, i));
		});
		return links;
	};

	adapter.canExpandNode = function(nodeData) { return true; };
	adapter.canCollapseNode = function(nodeData) { return true; };
	adapter.canPivotNode = function(nodeData) { return true; };

	standardAdapters.pathingObj = adapter;
	standardAdapters.pathing = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj),
		d3 = global.d3 || {};

	adapter._processOptions = function(options, changedOptions, prevOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var oldOptions = prevOptions || this._processedOptions || {},
			processedOptions = this._processedOptions = Object.create(options);

		// Data partition format
		/*
			[{
				"categories": [
					{
						"name": "Phone"
					},
					{
						"name": "Carrier"
					}
				]
				"metrics": [
					{
						"name": "Users",
						"format": "int",
						"value": "10000" // total
					}
				]
				"children": [
					{
						"name": "iPhone 7",
						"metrics": [ {"value" : 8000} ],
						"children": [
							{
								"name": "Verizon",
								"metrics": [ {"value" : 3400} ]
							},
							{
								"name": "AT&T",
								"metrics": [ {"value" : 3908} ]
							}
						]
					},
				]
			}]
		*/

		// The size of the sunburst visualization (width or angle) will be determined by
		// either the metric 1st index value or the summation of its children metric 1st index values
		var data = JSON.parse(JSON.stringify(processedOptions.data)),
			sizeMetric = data.metrics[0] || { name : '', format : 'int' };

		// Sort the data by size (first metric value) so that the unique keys are displayed correctly
		function getNodeSize(n) {
			if (n.metrics && n.metrics.length && n.metrics[0] &&
				'undefined' !== typeof n.metrics[0].value) { return n.metrics[0].value; }
			if (!n.children || !n.children.length) { return 0; }
			return n.children.reduce(function(a, b) {
				return a + getNodeSize(b);
			}, 0);
		}
		function sortChildren(a, b) {
			return getNodeSize(b) - getNodeSize(a);
		}
		// Sort the data into descending order by size
		// Add the 'size' attribute for easy layout
		// Add 'other' data when a parent has a size
		// and it has children to equal the difference
		var otherLabel = this.l10n.labels.core.other;
		function processDataSort(node,level) {
			// Set size if not set yet
			node.size = ('undefined' === typeof node.size) ? getNodeSize(node) : node.size;
			if (!node.children || !node.children.length) { return; }
			// Get top before other is created
			if (level < data.categories.length) {
				var c = data.categories[level], num = node.children.length;
				c.top = ('undefined' !== typeof c.top) ? Math.max(c.top, num) : num;
			}
			// Create other if needed
			if ('undefined' !== typeof node.size && sizeMetric.format !== 'percent') {
				var sum = node.children.reduce(function(a, b) {
					return a + getNodeSize(b);
				}, 0);
				if (node.size > sum) {
					node.children.push({
						id : 'cv-sb-other',
						name : otherLabel,
						size : node.size - sum
					});
				}
			}
			// sort descending by size
			node.children.sort(sortChildren);
			node.children.forEach(function(d) {
				processDataSort(d, level + 1);
			});
		}
		processDataSort(data, 0);

		// Get the unique names to set color for
		// and create unique ID per node
		var names = [];
		function processDataKeys(children, level, step) {
			var ring = names[level] || ( names[level] = [] ),
				i, ii = children.length, item;
			for (i=0; i<ii; ++i) {
				item = children[i];
				item._sid = step + 's' + i;
				// Assign name
				if (otherLabel === item.name) { continue; }
				if (item.name) { ring[ring.length] = item.name; }
				// Dive in further
				if (item.children && item.children.length) {
					processDataKeys(item.children, level + 1, item._sid);
				}
			}
		}
		processDataKeys([data], 0, '');

		// Add the metric name on at the end so it won't take up an initial color
		data.name = sizeMetric.name;
		names.push([sizeMetric.name]);

		// Index the categories
		data.categories.forEach(function(c, i) { c.index = i; });

		// Merge the multidimensional arrays and only take uniques
		processedOptions.uniques = names.reduce(function(a, b) {
			var uniqs = b.reduce(function(x, y) {
				return (x.indexOf(y) < 0) ? x.push(y) && x : x;
			}, []);
			return a.concat(uniqs);
		}, []);

		processedOptions.data = data;
		processedOptions.categories = data.categories;
		// TODO: this will break if the user changes their metrics and/or order
		// as it will point to the wrong index
		// will need to somehow create a meaningful identifier for metrics more
		// than index
		processedOptions.colorMetricIndex = oldOptions.colorMetricIndex;
		processedOptions.stackedMetricIndex = oldOptions.stackedMetricIndex;
		processedOptions.secondaryMetricIndex = oldOptions.secondaryMetricIndex;
		processedOptions.secondaryMetricType = oldOptions.secondaryMetricType;
		processedOptions.seqColors = processedOptions.seqColors;

		Object.getPrototypeOf(adapter)._processOptions.apply(this, arguments);
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.categories = function() {
		return this._processedOptions.categories;
	};

	adapter.uniques = function() {
		return this._processedOptions.uniques;
	};

	adapter.colors = function() {
		return this._processedOptions.colors;
	};

	adapter.seqColors = function() {
		return this._processedOptions.seqColors;
	};

	adapter.metricColor = function(d) {
		return this._processedOptions.metricColor;
	};

	adapter.otherColor = function(d) {
		return this._processedOptions.otherColor;
	};

	adapter.otherGrayColor = function(d) {
		return this._processedOptions.otherGrayColor;
	};

	adapter.outRangeColor = function(d) {
		return this._processedOptions.outRangeColor;
	};

	adapter.isOther = function(d) {
		return d.name === this.l10n.labels.core.other;
	};

	adapter.isRoot = function(d) {
		return !d.parent;
	};

	adapter.isDataEmpty = function() {
		var d = this.data();
			// TODO: Min/max should be calculated in standard not in RS so we can check for it
			/*empty = d.metrics.every(function(m) {
				return !(m.min || m.max);
			});*/
		return !(d && d.children && d.children.length);
	};

	adapter.isSizeEmpty = function() {
		return !this.data().size;
	};

	adapter._validateData = function(data) {
		if (!data || !data.children || !data.children.length) { return false; }
		return true;
	};

	adapter.getPathKey = function(d, i) {
		return d && d._sid || i;
	};

	adapter.getDataByPathKey = function() {
		var data = this.data(), self = this,
			keys = {}, key;
		function getKey(child) {
			if (!child) { return; }
			key = self.getPathKey(child, null);
			if (key) { keys[key] = child; }
			if (child.children) {
				child.children.forEach(getKey);
			}
		}
		getKey(data);
		return keys;
	};

	/**
	 * Get metric object being used for coloring the chart
	 * @returns {object} metric object
	 */
	adapter.getColorMetric = function() {
		var m = this._processedOptions.colorMetricIndex;
		return (m) ? this.data().metrics[m] : null;
	};

	/**
	 * Get metric object index being used for coloring the chart
	 * @returns {number} metric object index
	 */
	adapter.getColorMetricIndex = function() {
		return this._processedOptions.colorMetricIndex;
	};

	/**
	 * Set metric object index to be used for coloring the chart
	 * @param {number} metric object index
	 */
	adapter.setColorMetricIndex = function(m) {
		if (this._processedOptions.colorMetricIndex === m) { m = null; }
		this._processedOptions.secondaryMetricIndex = m;
		this.setSecondaryMetricType('color');
	};

	/**
	 * Get metric object being used for the height of the chart
	 * @returns {object} metric object
	 */
	adapter.getStackedMetric = function() {
		var m = this._processedOptions.stackedMetricIndex;
		return (m) ? this.data().metrics[m] : null;
	};

	/**
	 * Get metric object index being used for the height of the chart
	 * @returns {number} metric object index
	 */
	adapter.getStackedMetricIndex = function() {
		return this._processedOptions.stackedMetricIndex;
	};

	/**
	 * Set metric object index to be used for the height of the chart
	 * @param {number} metric object index
	 */
	adapter.setStackedMetricIndex = function(m) {
		if (this._processedOptions.stackedMetricIndex === m) { m = null; }
		this._processedOptions.secondaryMetricIndex = m;
		this.setSecondaryMetricType('height');
	};

	/**
	 * Get the secondary metric to be visualized as type
	 * @returns {string} 'color', 'height' 'both' or null
	 */
	adapter.getSecondaryMetricType = function() {
		return this._processedOptions.secondaryMetricType;
	};

	/**
	 * Update the secondary metric to be visualized as type
	 * @param {string} 'color', 'height' 'both' or null to clear
	 */
	adapter.setSecondaryMetricType = function(type) {
		var mIndex = this.getSecondaryMetricIndex() || 1,
			pOptions = this._processedOptions, self = this;
		// update secondary
		pOptions.secondaryMetricIndex = mIndex;
		pOptions.secondaryMetricType = type;
		switch(type) {
			case 'color':
				pOptions.colorMetricIndex = mIndex;
				pOptions.stackedMetricIndex = null;
				break;
			case 'height':
				pOptions.colorMetricIndex = null;
				pOptions.stackedMetricIndex = mIndex;
				break;
			case 'both':
				pOptions.colorMetricIndex = mIndex;
				pOptions.stackedMetricIndex = mIndex;
				break;
			default:
				pOptions.colorMetricIndex = null;
				pOptions.stackedMetricIndex = null;
				pOptions.secondaryMetricIndex = null;
				pOptions.secondaryMetricType = null;
		}
	};

	/**
	 * Get metric object being used for secondary visualization
	 * @returns {object} metric object
	 */
	adapter.getSecondaryMetric = function() {
		var m = this._processedOptions.secondaryMetricIndex;
		return (m) ? this.data().metrics[m] : null;
	};

	/**
	 * Get metric object index being used for secondary visualization
	 * @returns {number} metric object index
	 */
	adapter.getSecondaryMetricIndex = function() {
		return this._processedOptions.secondaryMetricIndex;
	};

	/**
	 * Set metric object index being used for secondary visualization
	 * @param {number} metric object index
	 */
	adapter.setSecondaryMetricIndex = function(index) {
		if (this._processedOptions.secondaryMetricIndex === index) { index = null; } // toggle
		this._processedOptions.secondaryMetricIndex = index;
		this.setSecondaryMetricType(index ? this.getSecondaryMetricType() || 'height' : null); // default to height
	};

	standardAdapters.sunburstObj = adapter;
	standardAdapters.sunburst = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj),
		d3 = global.d3 || {};

	adapter._processOptions = function(options, changedOptions) {
		// Make a copy of the options.
		var processedOptions = this._processedOptions = Object.create(options);
		var data = options.data;

		if(options.isEmotionChart){
			data = this._getEmotionData(options.data);
		}

		processedOptions.data = data;
		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	adapter._getEmotionData = function(data){
		var l10n =  this.l10n.labels.flower;

		var emotionTemplate = [
				{index: 'joy',          label: l10n.joy,          color:'#e6b43c'},
				{index: 'admiration',   label: l10n.admiration,   color:'#7daf4b'},
				{index: 'fear',         label: l10n.fear,         color:'#50965a'},
				{index: 'surprise',     label: l10n.surprise,     color:'#00a0be'},
				{index: 'sadness',      label: l10n.sadness,      color:'#286eaf'},
				{index: 'disgust',      label: l10n.disgust,      color:'#964196'},
				{index: 'anger',        label: l10n.anger,        color:'#f04641'},
				{index: 'anticipation', label: l10n.anticipation, color:'#dc5f00'}
			];

			var map = {};
			dv.util.each(data, function(o){
				map[o.index] = o;
			});

			dv.util.each(emotionTemplate, function(o){
				if(!map[o.index]){
					o.value = 0;
				}else{
					o.value = map[o.index].value || 0;
				}
			});

		return emotionTemplate;
	};

	adapter._validateData = function(data, mappings) {
		if (!data) { return false; }
		return true;
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	standardAdapters.flowerObj = adapter;
	standardAdapters.flower = cloudViz.util.createConstructor(adapter);
}(this));
/*global dv*/
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.barObj); // Just use the standard bar adapter

	adapter._processOptions = function(options, changedOptions) {
		var processedOptions = this._processedOptions = Object.create(options);

		this._processStepData(processedOptions);

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	// create a custom series label key to handle average series label to be different from series
	adapter.seriesLabelKey = function() {
		return 'cv:fnl:seriesLabel';
	};

	adapter.averageStepData = function() {
		return this._processedOptions.avgStepData;
	};

	adapter.averageDataLabel = function() {
		return this._processedOptions.avgStepLabel;
	};

	adapter.averageSeries = function() {
		return this._processedOptions.averageSeries;
	};

	adapter.previousStepData = function() {
		return this._processedOptions.prevStepData;
	};

	adapter.currentStepData = function() {
		return this._processedOptions.curStepData;
	};

	adapter.textStepData = function() {
		return this._processedOptions.txtStepData;
	};

	adapter.getNumSteps = function() {
		return this._processedOptions.numSteps;
	};

	adapter.getNumBarsPerStep = function() {
		return this._processedOptions.numBarsPerStep;
	};

	adapter.useAvgMaxValue = function() {
		if (!this.averageStepData()) { return false; } // no average data
		var extents = this.uniqueFillExtents();
		// check if all other data sets are empty
		// if so, we need to set the max so the range will be set in DV
		var empty = !Object.keys(extents).some(function(c, i, a) {
			return extents[c][0] !== 0 || extents[c][1] !== 0;
		});
		return empty || !this._processedOptions.normalized;
	};

	adapter._stepDelimiter = ':::';
	adapter.getStepName = function(d) {
		return d && d.slice(0, d.indexOf(this._stepDelimiter)) || '';
	};

	adapter.isSingleSeries = function() {
		return this.getNumBarsPerStep() === 1;
	};

	adapter.isAvgCalculated = function() {
		return this._processedOptions.avgStepDataCalc;
	};

	adapter.getSingleSeriesStepValue = function(d, i) {
		if (!this.isSingleSeries()) { return; } // no value for multiple series
		return this.currentStepData()[this.mappings()['y']][i];
	};

	adapter._processStepData = function(processedOptions) {
		// Requires that passed dataset is in linear step order
		var mappings = this.mappings(), self = this,
			data = processedOptions.data,
			series = mappings['series'], // segment
			seriesLabel = mappings['seriesLabel'], // segment name
			fnSeriesLabel = this.seriesLabelKey(),
			x = mappings['x'], // step
			value = mappings['y'],
			// average
			avgSeries = processedOptions.averageSeries,
			validAvgSeries = avgSeries && data[series].indexOf(avgSeries) >= 0,
			calcAvg = processedOptions.avgStepDataCalc = !validAvgSeries,
			avg = processedOptions.avgStepData = !processedOptions.disableAverage && (validAvgSeries || calcAvg) ?
				{ cv_tt_val: [], cv_tt_pval: [] } : null,
			prev = processedOptions.prevStepData = { cv_tt_val: [], cv_tt_pval: [] },
			cur = processedOptions.data = processedOptions.curStepData = { cv_tt_val: [], cv_tt_pval: [] },
			txt = processedOptions.txtStepData = { cv_label: [] },
			old = {}, // holds last segment value
			sum = {}; // sum for avg

		if (avg) {
			avg[value] = []; avg[x] = []; avg[series] = []; avg[fnSeriesLabel] = [];
		}
		prev[value] = []; prev[x] = []; prev[series] = []; prev[fnSeriesLabel] = [];
		cur[value] = []; cur[x] = []; cur[series] = []; cur[fnSeriesLabel] = [];
		txt[value] = []; txt[x] = []; txt[series] = []; txt[fnSeriesLabel] = [];

		// Determine number of series aka bars per step
		// Assumption is that each series would have a value for each step
		// We may need to modify the data to ensure this is the case
		processedOptions.numBarsPerStep = data[series].reduce(function(p, c, i) {
			if (p.indexOf(c) < 0 && (processedOptions.disableAverage || c !== avgSeries)) { p.push(c); }
			return p;
		}, []).length;

		// Create step data sets
		data[value].forEach(function(v, i) {
			// Get the current series and determine its
			var seg = data[series][i], prevValue,
				prevValueArray = old[seg];
			if (typeof prevValueArray === 'undefined') {
				old[seg] = prevValueArray = []; // initialize, first value for this series
				prevValue = v;
			} else {
				prevValue = prevValueArray[prevValueArray.length - 1];
			}

			// Unique id steps per series
			var stepId = data[x][i] + self._stepDelimiter + prevValueArray.length;
			sum[stepId] = sum[stepId] ? sum[stepId] + v : v;

			// Splice out avg series from bar geoms to render separately
			if (validAvgSeries && avg && seg === avgSeries) {
				avg[value].push(v);
				avg[x].push(stepId);
				avg[series].push(data[series][i]);
				avg[fnSeriesLabel].push( processedOptions.avgStepLabel = processedOptions.averageSeriesLabel ? processedOptions.averageSeriesLabel : data[seriesLabel][i]);
				avg['cv_tt_val'].push(v);
				avg['cv_tt_pval'].push(prevValue);
				prevValueArray.push(v);
				return;
			}

			// Current geoms array index, can't use i in case we are removing avg series
			var g = cur[value].length;

			// assign values
			prev[value].push(prevValue);
			cur[value].push(v);
			txt[value].push(v);
			txt['cv_label'].push(prevValue ? v / prevValue : 0);

			// Tooltips - attach to every data set so more flexible in handling display
			cur['cv_tt_val'][g] = prev['cv_tt_val'][g] = v;
			cur['cv_tt_pval'][g] = prev['cv_tt_pval'][g] = prevValue;

			// set step
			prev[x][g] = cur[x][g] = txt[x][g] = stepId;
			// set series
			prev[series][g] = cur[series][g] = txt[series][g] = data[series][i];
			// set series label
			prev[fnSeriesLabel][g] = cur[fnSeriesLabel][g] = txt[fnSeriesLabel][g] = data[seriesLabel][i];
			// update prev
			prevValueArray.push(v);
		});

		// Determine number of steps aka unique values for x
		// calculate average series as well if needed
		var oldSum = null;
		if (avg && calcAvg) {
			processedOptions.averageSeries = 'cv:fnl:avg';
		}
		processedOptions.numSteps = cur[x].reduce(function(p, c, i) {
			if (p.indexOf(c) < 0) {
				p.push(c);
				if (avg && calcAvg) {
					var v = sum[c] / processedOptions.numBarsPerStep;
					if (oldSum === null) { oldSum = v; }
					avg[value].push(v);
					avg[x].push(c);
					avg[series].push(processedOptions.averageSeries);
					avg[fnSeriesLabel].push( processedOptions.avgStepLabel = processedOptions.averageSeriesLabel ? processedOptions.averageSeriesLabel : self.l10n.labels.funnel.average );
					avg['cv_tt_val'].push(v);
					avg['cv_tt_pval'].push(oldSum);
					oldSum = v;
				}
			}
			return p;
		}, []).length;

		// Update mapping to use our own series label key
		var m = Object.create(processedOptions.mappings);
		m.seriesLabel = fnSeriesLabel;
		processedOptions.mappings = m;
	};

	standardAdapters.funnelObj = adapter;
	standardAdapters.funnel = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		standardAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.standard'),
		adapter = Object.create(standardAdapters.baseObj),
		d3 = global.d3 || {};

	adapter._processOptions = function(options, changedOptions) {
		Object.getPrototypeOf(adapter)._processOptions.apply(this, arguments);
	};

	adapter._validateData = function(data, mappings) {
		if (!data) { return false; }
		return true;
	};

	adapter.data = function() {
		return this._options.data;
	};

	standardAdapters.wordcloudObj = adapter;
	standardAdapters.wordcloud = cloudViz.util.createConstructor(adapter);
}(this));

(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.baseObj);

	/**
	 * Loop over every metric in the data array and determine its unique series index
	 * Using that index, save the metric type to the y format array
	 * @param {object} chart data
	 * @param {object} chart mappings
	 * @param {array} unique values array
	 * @returns {array} array with formats : [ 'int', 'percent' ]
	 * @private
	 */
	adapter._getYFormats = function(data, mappings, values) {
		var y = [];
		if (!data || !data.metric || !mappings || !mappings['series'] || !values) { return y; }
		var len = data.metric.length;
		for (var i = 0; i < len; i++) {
			var metric = data.metric[i],
				group = data[mappings['series']],
				formatIndex = values.indexOf(group[i]);
			y[formatIndex] = metric.type;
		}
		return y;
	};

	/**
	 * An object mapping tuples from the data object to visual aesthetics on the chart.
	 *
	 * <pre><code>
	 *     {
	 *         x: 'foo'
     *         y: 'bar'
	 *     }
	 * </code></pre>
	 *
	 * @returns {object}
	 */
	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	/**
-    * An object defining how number values should be formatted for each axis. Possible values include currency, percent,
-    * decimal, and time. Since y supports multiple axes, an array can be used instead of a string.  If a string is provided,
	 * that y format is applied to all series.  If an array is provided for y, each format maps to each series.
-    *
-    * <pre><code>
-    *     {
-    *         x: 'percent',
-    *         y: [ 'currency', 'decimal' ],
	 *         size: 'time'
-    *     }
-    * </code></pre>
-    *
-    * @returns {array}
-    */
	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	// this adapter should not be extended but rather its methods directly used
	rsAdapters.baseObj = adapter;
	// it can be used but really shouldn't
	rsAdapters.base = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.barObj);

	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = this._processedOptions = Object.create(options);

		// Determine if the bar chart is categorical or over time (histogram)
		processedOptions.isOvertime = this._determineOvertime(processedOptions.data);
		// Get the yAxisTitle based on the metric labels in the data
		processedOptions.yAxisTitle = options.yAxisTitle || this._getYAxisTitle(processedOptions.data);
		// Determine time granularity (this will only matter if the chart is a histogram)
		processedOptions.dateGranularity = this._getTimeGranularity(processedOptions.data);

		// Update data/mappings to match a rs bar chart data set
		this._processData(processedOptions);
		this._updateMappings(processedOptions);

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);

		// Determine the correct y formats based on the metric types
		// Must be after mappings and after the fill values have populated in the standard/bar adapter
		processedOptions.formats = {
			x : options.formats.x,
			y : this._getYFormats(processedOptions.data, processedOptions.mappings, this.uniqueFillValues())
		};
	};

	adapter.isOvertime = function() {
		return this._processedOptions.isOvertime;
	};

	adapter.xAxisTitle = function() {
		return null;
	};

	adapter.yAxisTitle = function() {
		return this._processedOptions.yAxisTitle;
	};

	adapter.dateGranularity = function() {
		return this._processedOptions.dateGranularity;
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	adapter._determineOvertime = function(data) {
		var date = data.date,
			histogram = data.metric && data.metric.some(function(m) {
				return m && m.date_range && m.date_range.gran !== '*';
			});

		return date && date.length && histogram;
	};

	adapter._getYAxisTitle = function(data) {
		return this._getYTitleFromLabels(data.label);
	};

	adapter._processData = function(processedOptions) {
		if (processedOptions.isOvertime) { return; } // no need to process for categorical

		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var d = Object.create(processedOptions.data), i, ii = d.cell.length,
			cell = null, prev = null;
		// create a group array that mirrors except it includes ::incomplete::
		d.group = [];
		for (i=0; i<ii; ++i) {
			prev = cell;
			cell = d.cell[i];
			d.group[i] = d.series[i];

			// when encountering an identical incomplete, create another point to draw the dotted line from
			if (prev && 'incomplete' === cell.status && 'incomplete' !== prev.status) {
				d.group[i] += '::incomplete::'; // mark as a separate type
			}
		}
		processedOptions.data = d;
	};

	adapter._updateMappings = function(processedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var mappings = Object.create(processedOptions.mappings);
		if (processedOptions.isOvertime) {
			// Overtime we need to break up the data in groups by filter/metric/datastore
			mappings.x = 'date';
			mappings.y = 'value';
			mappings.group = 'group'; // Not currently used because we don't show incomplete yet
			mappings.series = 'series';
			mappings.seriesLabel = 'series_name';
		} else {
			// Filter is our x axis, so we only need to break up by metric/datastore
			mappings.x = 'category';
			mappings.y = 'value';
			mappings.series = 'metric_series';
			mappings.seriesLabel = 'metric_series_name';
		}
		processedOptions.mappings = mappings;
	};

	adapter._getTimeGranularity = function(data) {
		return data.metric[0]['date_range'].gran;
	};

	// Base adapter methods
	var base = rsAdapters.baseObj;
	adapter._getYFormats = base._getYFormats;

	rsAdapters.bar = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.choroplethObj),
		d3 = global.d3 || {};

	adapter._processOptions = function(options, changedOptions) {
		// Make a copy of the options.
		var processedOptions = this._processedOptions = Object.create(options);
		this._processData(processedOptions, options);
		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	adapter._processData = function(processedOptions, options) {
		var rsdata = options.data, // raw Reporting Services object
			data = rsdata.data, metrics = rsdata.metrics, filters = rsdata.filters, dates = rsdata.dates,
			filter_ref, date_ref,
			metric, filter,
			result = { values: {} };

		for (var m = 0, mm = metrics.length; m < mm; ++m) {
			metric = metrics[m];
			filter_ref = metric.filter_ref;
			date_ref = metric.date_ref;
			for (var f = 0, ff = filter_ref.length; f < ff; ++f) {
				filter = filters[filter_ref[f]];
				for (var d = 0, dd = date_ref.length; d < dd; ++d) {
					result.values[(filter.info || {}).geo_id] = data[filter_ref[f]][date_ref[d]][m].val;
				}
			}
		}

		processedOptions.data = result; // Choropleth expected data object
		processedOptions.metric = metric.name;
		processedOptions.format = metric.type;
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.metric = function() {
		return this._processedOptions.metric;
	};

	adapter.format = function() {
		return this._processedOptions.format;
	};

	adapter._validateData = function(data, mappings) {
		if (!data) { return false; }
		return true;
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	rsAdapters.choropleth = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.donutObj);

	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = this._processedOptions = Object.create(options);

		// Update mappings to match a rs donut chart data set
		this._updateMappings(processedOptions);

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);

		// Determine the correct y formats based on the metric types
		// Must be after mappings and after the fill values have populated in the standard/bar adapter
		processedOptions.formats = {
			x: options.formats.x,
			y: this._getYFormats(processedOptions.data, processedOptions.mappings, this.uniqueFillValues())
		};
	};

	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	adapter._updateMappings = function(processedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var mappings = Object.create(processedOptions.mappings);
		mappings.x = 'category';
		mappings.y = 'value';
		mappings.series = 'metric_series';
		mappings.seriesLabel = 'metric_series_name';
		processedOptions.mappings = mappings;
	};

	// Base adapter methods
	var base = rsAdapters.baseObj;
	adapter._getYFormats = base._getYFormats;

	rsAdapters.donut = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.lineObj);

	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = this._processedOptions = Object.create(options);

		// Determine if the bar chart is categorical or over time (histogram)
		processedOptions.isOvertime = this._determineOvertime(processedOptions.data);
		// Get the yAxisTitle based on the metric labels in the data
		processedOptions.yAxisTitle = options.yAxisTitle || this._getYAxisTitle(processedOptions.data);
		// Determine time granularity (this will only matter if the chart is a histogram)
		processedOptions.dateGranularity = this._getTimeGranularity(processedOptions.data);

		// Update data/mappings to match a rs bar chart data set
		this._updateMappings(processedOptions);
		// Process data for multi-metric
		// This will overwrite the default trend mappings
		this._processMultiMetric(processedOptions);
		// Add incomplete data to groups if necessary
		this._processIncompleteData(processedOptions);

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);

		// Determine the correct y formats based on the metric types
		// Must be after mappings and after the stroke values have populated in the standard/bar adapter
		// Only needed if overtime (multi-metric will have its own formats)
		processedOptions.formats = {
			x: options.formats.x,
			y: processedOptions.isOvertime ? this._getYFormats(processedOptions.data, processedOptions.mappings, this.uniqueStrokeValues()): options.formats.y
		};
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	adapter.xAxisTitle = function() {
		return this._processedOptions.xAxisTitle;
	};

	adapter.yAxisTitle = function() {
		return this._processedOptions.yAxisTitle;
	};

	adapter.isOvertime = function() {
		return this._processedOptions.isOvertime;
	};

	adapter.dateGranularity = function() {
		return this._processedOptions.dateGranularity;
	};

	adapter._determineOvertime = function(data) {
		var date = data.date,
			timeSeries = data.metric && data.metric.some(function(m) {
				return m && m.date_range && m.date_range.gran !== '*';
			});

		return date && date.length && timeSeries;
	};

	adapter._getYAxisTitle = function(data) {
		return this._getYTitleFromLabels(data.label);
	};

	adapter._getTimeGranularity = function(data) {
		// Assuming all metrics have the same time/date range and granularity
		// TODO: Handle multiple metrics with multiple granularities...
		return this.isOvertime() ? data.metric[0].date_range.gran : '*';
	};

	// Nearly identical to point to handle multiple metrics except for some syntax issues
	// And the need to set up support for dual-y-axis and no default mapping settings needed
	adapter._processMultiMetric = function(processedOptions) {
		if (processedOptions.isOvertime) { return; } // no need to process for trend data

		// Create the data structure for the point chart based on the metric information from RS
		// This will support 2-3 metrics. 2 metrics = scatterplot, 3 metrics = bubble
		var data = processedOptions.data, pData = { series: [] },
			metrics = [], formats = [], i, ii, metric;

		// Iterate over the labels (metric names), we need to create new parallel arrays
		// Metric 0 will be the new x axis, its values need to go into the x mapping
		// Metric 1 will be the new y axis, its values need to go into the y mapping
		// The series should be each individual point as it relates to metric 0 and 1
		// If there is metric 2, it should add its value as the size mapping
		// Record the formats for each metric so the numbers can be formatted accordingly
		for (i=0, ii=data.label.length; i<ii; ++i) {
			metric = data.label[i];
			if (!pData[metric]) {
				metrics.push(metric);
				if (data.metric && data.metric.length) {
					formats.push(data.metric[i].type);
				}
				else {
					formats.push(null);
				}
				pData[metric] = [];
			}
			// Assign value for metric
			pData[metric].push(data.value[i]);
			// Convert the category into series
			pData.series[pData[metric].length-1] = data.category[i];
		}

		var m = {
			x: metrics[0],
			y: metrics[1]
		};
		var f = {
			x: formats[0],
			y: {
				0: formats[1] // This is a nested object because we can have multiple y formats for multiple y axes.
			}
		};
		if (data.groups && data.groups.length && data.groups[0].length) {
			// Add a group data set from groups
			var g, gg = data.groups.length, item, group = [];
			for (g = 0; g<gg; ++g) {
				item = data.groups[g];
				group[g] = item.join('-');
			}
			pData.facet_group = group;
			m.series = 'facet_group';
		}

		if (metrics.length > 2) {
			m.size = metrics[2];
			f.size = formats[2];
			processedOptions.sizeMetricName = processedOptions.sizeTitle || metrics[2];
		}

		processedOptions.data = pData;
		processedOptions.mappings = m;
		processedOptions.formats = f;
		processedOptions.xAxisTitle = processedOptions.xAxisTitle || metrics[0];
		processedOptions.yAxisTitle = processedOptions.yAxisTitle || metrics[1];
	};

	adapter._updateMappings = function(processedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var mappings = Object.create(processedOptions.mappings);

		// Overtime we need to break up the data in groups by filter/metric/datastore
		mappings.x = 'date';
		mappings.y = 'value';
		mappings.group = 'series';
		mappings.series = 'series';
		mappings.seriesLabel = 'series_name';
		processedOptions.mappings = mappings;
	};

	adapter._processIncompleteData = function(processedOptions) {
		if (!processedOptions.isOvertime || !processedOptions.data.cell) { return; } // no support for incomplete on multimetric
		// Currently we cannot show incomplete or invalid data when position is fill or stack
		// because D3's stacking function can't use it (which DV uses).
		// See issue #101 for details on why (https://git.corp.adobe.com/Coral/CloudViz/issues/101).
		if (processedOptions.position === 'stack' || processedOptions.position === 'fill') { return; }

		var data = processedOptions.data, mappings = processedOptions.mappings,
			i, ii = data.cell.length, cell = null, prev = null, k, incompleteSeriesExists = false;

		// create a incomplete array that mirrors series except it includes ::incomplete::
		data.cv_rs_group = data.cv_rs_group || [];
		for (i=0; i<ii; ++i) {
			prev = cell;
			cell = data.cell[i];
			data.cv_rs_group[i] = data.cv_rs_group[i] || data.series[i];

			// Let's make sure an incomplete series doesn't already exist.
			// We don't want to create extra incomplete data points if we've already done so previously.
			if(data.cv_rs_group[i].indexOf('::incomplete::') >= 0) { continue; }

			// when encountering an identical incomplete, create another point to draw the dotted line from
			if (prev && 'incomplete' === cell.status && 'incomplete' !== prev.status) {
				for (k in data) { data[k].splice(i, 0, data[k][i - 1]); }
				data.cv_rs_group[i] += '::incomplete::'; // mark as a separate type
				++ii; // update length
				++i; // go back to the original incomplete cell
			}

			data.cv_rs_group[i] += 'incomplete' === cell.status ? '::incomplete::' : '';
		}
		mappings.group = 'cv_rs_group';
	};

	// Base adapter methods
	var base = rsAdapters.baseObj;
	adapter._getYFormats = base._getYFormats;

	rsAdapters.line = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.pointObj);

	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = this._processedOptions = Object.create(options);

		// Create the data structure for the point chart based on the metric information from RS
		// This will support 2-3 metrics. 2 metrics = scatterplot, 3 metrics = bubble
		var data = options.data, pData = { series: [] },
			metrics = [], formats = [], i, ii, metric;

		// Iterate over the labels (metric names), we need to create new parallel arrays
		// Metric 0 will be the new x axis, its values need to go into the x mapping
		// Metric 1 will be the new y axis, its values need to go into the y mapping
		// The series should be each individual point as it relates to metric 0 and 1
		// If there is metric 2, it should add its value as the size mapping
		// Record the formats for each metric so the numbers can be formatted accordingly
		for (i=0, ii=data.label.length; i<ii; ++i) {
			metric = data.label[i];
			if (!pData[metric]) {
				metrics.push(metric);
				if (data.metric && data.metric.length) {
					formats.push(data.metric[i].type);
				}
				else {
					formats.push(null);
				}
				pData[metric] = [];
			}
			// Assign value for metric
			pData[metric].push(data.value[i]);
			// Convert the category into series
			pData.series[pData[metric].length-1] = data.category[i];
		}

		var m = {
			x: metrics[0],
			y: metrics[1]
		};
		var f = {
			x: formats[0],
			y: formats[1]
		};
		if (data.groups && data.groups.length && data.groups[0].length) {
			// Add a group data set from groups
			var g, gg = data.groups.length, item, group = [];
			for (g = 0; g<gg; ++g) {
				item = data.groups[g];
				group[g] = item.join('-');
			}
			pData.group = group;
			m.series = 'group';
		} else {
			m.series = 'series';
		}

		if (metrics.length > 2) {
			m.size = metrics[2];
			f.size = formats[2];
			processedOptions.sizeMetricName = options.sizeTitle || metrics[2];
		}

		processedOptions.data = pData;
		processedOptions.mappings = m;
		processedOptions.formats = f;
		processedOptions.xAxisTitle = options.xAxisTitle || metrics[0];
		processedOptions.yAxisTitle = options.yAxisTitle || metrics[1];

		Object.getPrototypeOf(adapter)._processOptions.apply(this, arguments);
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	adapter.xAxisTitle = function() {
		return this._processedOptions.xAxisTitle;
	};

	adapter.yAxisTitle = function() {
		return this._processedOptions.yAxisTitle;
	};

	adapter.sizeMetricName = function() {
		return this._processedOptions.sizeMetricName;
	};

	rsAdapters.point = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.pathingObj),
		maxDepth = 4; // maximum depth that we can request from RS

	// convert the rs data structure to pathing data structure with nodes/paths
	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = Object.create(options),
			rsdata = processedOptions.data, pathdata = {},
			dnodes = (pathdata.nodes = []), dpaths = (pathdata.paths = []),
			nodesById = {}, l10n = this.l10n.labels.pathing;

		function detectEntry(f) { return 'E' === f; }
		function detectExit(f) { return 'X' === f; }

		// Loop over and create nodes based on unique ids for filters and their column position
		// Column position is based on the filter definitions children values
		var filter, filterIndex, filterId, filterName, filterChild, filterOp, filterValue,
			node, nodeId, nodeColumn, isBounce, minimumColumn = 0;
		for (filterIndex in rsdata.filters) {
			filter = rsdata.filters[filterIndex];
			filterId = this._getFilterId(filter);
			if (filterId) {
				// get filter information
				filterName = filter.info && filter.info.name || '';
				filterChild = this._getFilterChild(filter);
				filterOp = filterChild && filterChild.op || null;
				// for now ignore additional filters
				if (filterOp && filterOp !== 'previous' && filterOp !== 'next') {
					filterChild = filterOp = null;
				}
				// get the values for the filter aka the path
				filterValue = (filterChild && filterChild.val) ? [].concat(filterChild.val) : [];
				// determine column and id
				nodeColumn = 0;
				if ('previous' === filterOp) {

					// Create an entry node if this path includes entry (since we won't have an entry filter)
					if (filterValue.some(detectEntry)) {
						var entryId = 'E_0';
						if (!nodesById[entryId]) {
							node = {
								label : l10n.entry,
								id : entryId,
								column : nodeColumn,
								index : dnodes.length,
								filters : [] // TODO: Figure this out
							};
							dnodes[dnodes.length] = node;
							nodesById[entryId] = node;
						}
					}

					nodeColumn = filterValue.length;

				}
				if ('next' === filterOp) {

					// Create an exit node if this path includes exit (since we won't have an entry filter)
					if (filterValue.some(detectExit)) {
						var exitId = 'X_0';
						if (!nodesById[exitId]) {
							node = {
								label : l10n.exit,
								id : exitId,
								column : nodeColumn,
								index : dnodes.length,
								filters : [] // TODO: Figure this out
							};
							dnodes[dnodes.length] = node;
							nodesById[exitId] = node;
						}
					}

					nodeColumn = 0 - filterValue.length;
				}
				nodeId = filterId + '_' + nodeColumn;
				if (nodesById[nodeId]) { // collapse duplicate nodes in the same column
					nodesById[nodeId].filters.push(filter);
					continue;
				}
				isBounce = ('0' === String(filterId) && (l10n.exit === String(filterName) || l10n.entry === String(filterName)) );
				if (isBounce) { continue; } // ignore exit/entry nodes (for now)
				else if ('0' === String(filterId)) { continue; } // ignore nodes that aren't valid
				node = {
					label : filterName,
					id : nodeId,
					column : nodeColumn,
					index : dnodes.length,
					filters : [filter]
				};
				dnodes[dnodes.length] = node;
				minimumColumn = Math.min(minimumColumn, nodeColumn);
				nodesById[nodeId] = node;
			}
		}

		// Slide columns so that the minimum column value is 0
		if (0 !== minimumColumn) {
			for (var n in dnodes) {
				node = dnodes[n];
				node.column -= minimumColumn;
			}
		}

		// Loop over every unique filter and create a path
		var metric, filterRef, dateRef, dateIndex,
			m, mm, f, ff, d, dd,
			date, cell, nodes;
		for (m = 0, mm = rsdata.metrics.length; m < mm; ++m) {
			metric = rsdata.metrics[m];
			filterRef = metric.filter_ref; // get the filter(s) associated with the metric
			dateRef = metric.date_ref; // get the date range(s) associated with the metric
			for (f = 0, ff = filterRef.length; f < ff; ++f) {
				filterIndex = filterRef[f];
				filter = rsdata.filters[filterIndex];
				for (d = 0, dd = dateRef.length; d < dd; ++d) {
					dateIndex = dateRef[d];
					date = rsdata.dates[dateIndex];
					cell = rsdata.data[filterIndex][dateIndex][m]; // three dimensional hash filter:date:metric
					if ('invalid' === cell.status) { continue; } // ignore invalid paths
					// handle a select/equals that sets the total
					if (node = this._getSingleNode(filter, nodesById)) {
						node.total = +cell.val;
						continue;
					}
					nodes = this._createPath(filter, nodesById);
					if (!nodes || !nodes.length) { continue; } // ignore empty paths
					// create path
					dpaths[dpaths.length] = {
						nodes : nodes,
						values : +cell.val || 0
					};
				}
			}
		}

		// Sort the paths by length and then adjust values for subsets
		// Sort longest first
		dpaths.sort(function(a, b) {
			return b.nodes.length - a.nodes.length;
		});
		var i, ii, j, jj, path, otherPath;
		// Loop over from shortest to longest
		// If the outer path finds a path that it is a subset for
		// subtract the superset value from the subset path's value
		for (i=0, ii=dpaths.length; i<ii; ++i) {
			path = dpaths[i];
			for (j=0, jj=dpaths.length; j<jj; ++j) {
				if (i === j) { continue; } // ignore self
				otherPath = dpaths[j];
				if (otherPath.nodes.length === path.nodes.length) { continue; } // no need to check path with same length
				if (-1 !== this._getPathString(path.nodes).indexOf(this._getPathString(otherPath.nodes))) {
					otherPath.values -= path.values;
				}
			}
		}

		// Remove no value paths
		pathdata.paths = dpaths = dpaths.filter(function(p) { return p.values; });

		// Update our processed data
		processedOptions.data = pathdata;

		// Get pathing title
		var metrics = options.data.metrics;
		processedOptions.pathingTitle =  metrics && metrics.length && metrics[0].name;

		// apply normal pathing processing
		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	/**
	 * Returns a function that will determine how D3 pairs SVG elements with node data objects
	 * @returns {func}
	 * @private
	 */
	adapter.nodeKey = function() {
		return function(d, i) {
			return d.id;
		};
	};

	/**
	 * Returns a function that will determine how D3 pairs SVG elements with link objects
	 * @returns {func}
	 * @private
	 */
	adapter.linkKey = function() {
		return function(d, i) {
			return ((d.source) ? d.source.id : 'null') + '-' + ((d.target) ? d.target.id : 'null');
		};
	};

	/**
	 * The user-friendly name of the metric that we are pathing on
	 * @returns {string}
	 */
	adapter.pathingTitle = function() {
		return this._processedOptions.pathingTitle;
	};

	/**
	 * Determines the end of the path and returns the value of the node
	 * @param {object} path obj with nodes and values array
	 * @returns {obj} node obj
	 */
	adapter.getPathEnd = function(path) {
		// Check the ends of the path and find a pivot/entry/exit node
		if (!path || !path.nodes || !path.nodes.length) { return null; }
		if (path.nodes.length === 1) { return path.nodes[0]; } // shouldn't happen
		var nodes = path.nodes, data = this._processedOptions.data,
			byId = data.nodesById, start = byId[nodes[0]],
			end = byId[nodes[nodes.length-1]];
		function isEnd(n) {
			return n && (n.isPivot || n.id === 'E_0' || n.id === 'X_0');
		}
		if (isEnd(start)) { return start; }
		if (isEnd(end)) { return end; }
		return null;
	};

	/**
	 * Returns the direction of the path, 1 origin of the path is the start, -1 origin is at the end
	 * @param {object} path obj with nodes and values array
	 * @returns {number} 1 from, -1 to, 0 no direction found
	 */
	adapter.getPathDirection = function(path) {
		var end = this.getPathEnd(path);
		if (!end) { return 0; }
		return end._pid === path.nodes[0] ? 1 : -1;
	};

	/**
	 * Returns title for paths
	 * @param {array} array of pathing objects
	 * @returns {string} title
	 */
	adapter.activePathsTitle = function(paths) {
		if (!paths || !paths.length) { return ''; }
		// Since all paths in this list will have the same end, just grab the first one
		var end = this.getPathEnd(paths[0]),
			l10n = this.l10n.labels.pathing;
		if (!end) { return l10n['path2+']; }
		var pattern = this.getPathDirection(paths[0]) === 1 ? l10n.pathFromNode : l10n.pathToNode;
		return pattern
			.replace(/\{path\}/i, ((paths.length > 1) ? l10n['path2+'] : l10n['path']))
			.replace(/\{label\}/i, end.label);
	};

	/**
	 * Takes a filter, determines if its a standalone (no previous/next with a select/equals op)
	 * If so, finds the node in the array and returns it
	 * @param {object} filter object
	 * @param {array} all nodes by id
	 * @returns {object}
	 * @private
	 */
	adapter._getSingleNode = function(filter, byId) {
		var id = this._getFilterId(filter),
			def = filter.filter_def && filter.filter_def.length && filter.filter_def[0] || null,
			op = def && def.op || null,
			child = this._getFilterChild(filter),
			childOp = child && child.op || null;
		if (('select' !== op && 'equals' !== op && 'id' !== op) || 'previous' === childOp || 'next' === childOp) { return false; }
		return byId[id + '_0']; // all selects should be in zero column
	};

	/**
	 * Takes an array and converts it to a string
	 * Normally a toString would be enough but the null values need to be accounted for
	 * rather than just being an empty entry
	 * @param {array} path array
	 * @returns {string}
	 * @private
	 */
	adapter._getPathString = function(path) {
		return path.map(function(p){ return (null === p) ? 'null' : p; }).toString();
	};

	/**
	 * Creates the node array needed for a path
	 * @param {object} filter object
	 *
	 * <pre><code>
	 *     {
	 *         data_store: 'dms/adobescmobiledev',
	 *         info: {
	 *             id: '0',
	 *             name: 'Entry'
	 *         }
     *         filter_def: [
     *          {
     *             op: 'select',
	 *             val: {
	 *                 limit: [1, 6],
	 *                 order: [0]
	 *             },
     *             var: 'viewstate',
	 *             child: [
	 *              {
	 *                 op: 'next',
	 *                 val: ['2005543073'],
	 *                 var: 'viewstate'
	 *              }
	 *             ]
     *          }
     *         ]
	 *     }
	 * </code></pre>
	 * @param {array} all nodes by id
	 * @returns {array}
	 * @private
	 */
	adapter._createPath = function(f, byId) {
		var id = this._getFilterId(f), child = this._getFilterChild(f),
			op = child && child.op || null;
		// for now ignore additional filters
		if (op && op !== 'previous' && op !== 'next') { return []; }

		// get the values for the filter aka the path
		var values = (child && child.val) ? [].concat(child.val) : [];
		if (!values.length) { return values; }
		var prev = ('previous' === child.op),
			bounce = ('0' === id),
			c = (prev) ? 0 : (bounce) ? 0 - values.length + 1 : 0 - values.length, // starting column position
			nodes = [];
		if (prev) { values.push(id); }
		else { values.unshift(id); }
		return this._mapNodeIds(c, values, byId);
	};

	/**
	 * Takes an array of node ids and maps them to their indexes within byId
	 * @param {number} starting column index
	 * @param {array} array of node ids
	 * @param {object} lookup of all nodes by their unique id of node id plus column index
	 * @returns {array} mapping of nodes by unique id to index in node array
	 * @private
	 */
	adapter._mapNodeIds = function(c, ids, byId) {
		// handle invalid parameters
		if (!isFinite(c) || !byId) { return []; }
		c = +c;
		// Need to construct a valid path where we have a validValue
		// and there are no missing values aka nodes
		var validValue = false, missingValue = false, nodeId,
			mapped = ids && ids.map && ids.map(function(n) {
				// 0 is the value for an entry or exit
				if ('0' === n) { return null; }
				nodeId = n + '_' + c;
				if (!byId[nodeId]) {
					// node does not exist, throw the path out
					missingValue = true;
					return null;
				}
				// increment column
				// each node in a valid path is in a successive column
				++c;
				validValue = true;
				return +byId[nodeId].index;
			});
		return (validValue && !missingValue) ? mapped : [];
	};

	/**
	 * Gets the filter id if it exists or null
	 * @param {object} filter object
	 * @returns {string}
	 * @private
	 */
	adapter._getFilterId = function(filter) {
		return (filter.info && (filter.info.id || filter.info.id === 0)) ? filter.info.id + '' : null;
	};

	/**
	 * Gets the first AND value of a filter. For pathing, this will be the next or previous for a node
	 * @param {object} filter object
	 * @returns {object}
	 * @private
	 */
	adapter._getFilterChild = function(filter) {
		var def = filter.filter_def && filter.filter_def.length && filter.filter_def[0] || null;
		return def && def.child && def.child.length && def.child[0] || null;
	};

	adapter.canExpandNode = function(node) {
		var enters = node.entryLinks.length + node.targetLinks.length,
			exits = node.exitLinks.length + node.sourceLinks.length,
			column = Math.abs(parseInt(node.id.split('_')[1], 10));

		// Check path length (hack for now looking at column)
		if (column >= maxDepth) { return false; }

		// Handle entry/exit node
		if (exits && node.id === 'E_0') { return false; }
		if (enters && node.id === 'X_0') { return false; }

		// If the node does not have both enter and exit links
		if (!enters || !exits) { return true; }

		return false;
	};

	adapter.canCollapseNode = function(node) {
		var enters = node.entryLinks.length + node.targetLinks.length,
			exits = node.exitLinks.length + node.sourceLinks.length,
			column = parseInt(node.id.split('_')[1], 10);

		// Handle entry/exit
		// Since these aren't really nodes, we can't collapse them
		if (node.id === 'E_0' || node.id === 'X_0') { return false; }

		// Check that it has exits (positive column) or enters (negative column)
		// or either for center
		return (0 === column && (exits || enters)) ||
			(column > 0 && exits) ||
			(column < 0 && enters);
	};

	adapter.canPivotNode = function(node) {
		var enters = node.entryLinks.length + node.targetLinks.length,
			exits = node.exitLinks.length + node.sourceLinks.length,
			column = Math.abs(parseInt(node.id.split('_')[1], 10));
		// Allow any node outside of the center column
		if (column !== 0) { return true; }
		// Allow any node if multiple nodes in center column aka no pivot
		var data = this.data(), columns = data.nodes.map(function(d) { return parseInt(d.id.split('_')[1], 10); }),
			zeroCount = 0;
		if (columns.some(function(c){
			if (c === 0) { zeroCount++; }
			return (zeroCount > 1) ? true : false;
		})) { return true;}
		return false;
	};

	rsAdapters.pathingObj = adapter;
	rsAdapters.pathing = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.sunburstObj);

	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var prevOptions = this._processedOptions,
			processedOptions = this._processedOptions = Object.create(options);

		// Recursive function to return an array of the ids the filter was ANDed against
		function getPartitionFilters(def) {
			var val = (def && def.op === 'id') ? [def.val] : [];
			if (def && def.child && def.child[0]) {
				return getPartitionFilters(def.child[0]).concat(val);
			}
			return val;
		}

		// Recursive function to count number of children on a filter def
		function filterDefHasChild(def) {
			if (def && def.child && def.child[0]) {
				return filterDefHasChild(def.child[0]) + 1;
			}
			return 0;
		}

		// Get the depth of the filter based on filter_def children
		function getFilterDepth(filter) {
			var def = filter && filter.filter_def && filter.filter_def[0] || null;
			return filterDefHasChild(def);
		}

		// Sort partitions by depth (number of filter_defs) and then by value
		function sortPartitions(a, b) {
			var aDepth = getFilterDepth(a.filter),
				bDepth = getFilterDepth(b.filter);
			if (aDepth === bDepth) {
				return b.cell[0].val - a.cell[0].val;
			}
			return aDepth - bDepth;
		}

		// Convert the metric/filters/date data into stacked categorical data structure
		var rsdata = options.data,
			metric, filterRef, dateRef, dateIndex,
			f, ff, d, dd, partition, partitions,
			date, cell, nodes, filter, filterIndex,
			data = {
				children : [],
				categories : [],
				metrics : rsdata.metrics.map(function(m, i) {
					return {
						id : m.id,
						icon : m.icon,
						name : m.name || m.id,
						format : m.type,
						categories : []
					};
				})
			};

		// Since the first metric will be all the shapes, we only care about its filters
		// All filters should have data with this metric, so the filter_ref should contain the entire filters list
		if (metric = rsdata.metrics[0]) {
			partitions = [];
			filterRef = metric.filter_ref; // get the filter(s) associated with the metric
			dateRef = metric.date_ref; // get the date range(s) associated with the metric
			// create an array of partitions that are composed of a filter and its value
			for (f = 0, ff = filterRef.length; f < ff; ++f) {
				filterIndex = filterRef[f];
				filter = rsdata.filters[filterIndex];
				for (d = 0, dd = dateRef.length; d < dd; ++d) {
					dateIndex = dateRef[d];
					date = rsdata.dates[dateIndex];
					cell = rsdata.data[filterIndex][dateIndex]; // two dimensional hash filter:date
					if (!cell[0] || 'invalid' === cell[0].status) { continue; } // ignore invalid data on first metric
					if (filter.info && filter.info.id === 0) { continue; } // ignore undefined filters
					partitions.push({
						filter : filter,
						cell : cell
					});
				}
			}
			// sort the array of partitions
			partitions.sort(sortPartitions);
			// loop over and create data
			// thanks to the sort, we will have an id by the time we need to insert it
			var partitionById = {}, parent_pid, parent_partition, def, pFilters, level;
			partitions.forEach(function(partition) {
				filter = partition.filter;
				cell = partition.cell;
				def = filter && filter.filter_def && filter.filter_def[0] || null;
				pFilters = getPartitionFilters(def),
				level = pFilters.length,
				parent_pid = pFilters.join('-');
				if (!parent_pid.length && !filter.info) {
					// assign total value data to metrics
					cell.forEach(function(c, i) {
						data.metrics[i].value = +c.val;
					});
					return;
				}
				partition = {
					id : filter.info.id,
					pid : parent_pid ? parent_pid + '-' + filter.info.id : filter.info.id,
					name : filter.info.name,
					metrics : cell.map(function(c) { return { value: +c.val }; }),
					category : filter.info.category || (def && def['var']) || undefined,
					filtervar : def && def['var'] || undefined,
					children : []
				};
				// add original name
				if (filter.info.orig_name) {
					partition.orig_name = filter.info.orig_name;
				}

				// update min/max for metrics
				cell.forEach(function(c, i) {
					var m = data.metrics[i];
					// metric min/max
					m.min = ('undefined' !== typeof m.min) ? Math.min(m.min, +c.val) : +c.val;
					m.max = ('undefined' !== typeof m.max) ? Math.max(m.max, +c.val) : +c.val;
					// metric & level min/max
					var catLevel;
					if (!(catLevel = m.categories[level])) { m.categories[level] = { min: +c.val, max: +c.val }; }
					else {
						catLevel.min = Math.min(catLevel.min, +c.val);
						catLevel.max = Math.max(catLevel.max, +c.val);
					}
				});

				if (parent_pid && (parent_partition = partitionById[parent_pid])) {
					parent_partition.children.push(partition);
				} else if (!pFilters.length){ // right under metric
					data.children.push(partition);
				} else {
					// else its parent was invalid, like a undefined filter that was removed
					// don't add category and don't add the partition to the list
					return;
				}
				// update categories
				partitionById[partition.pid] = partition;
				data.categories[level] = { name: filter.info.category || (def && def['var']) || data.categories[level] };
			});
		}
		processedOptions.data = data;

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions, prevOptions);
	};

	adapter._validateData = function(data) {
		if (!data) { return false; }
		for (var key in data) {
			if (data[key].length) { return true; }
		}
		return false;
	};

	adapter.getPathKey = function(d, i) {
		if (!d || !d._sid) { return 0; } // invalid
		if (!d.pid) { return d._sid; } // fallback for other and center
		return d.pid;
	};

	rsAdapters.sunburst = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.flowerObj);

	adapter._processOptions = function(options, changedOptions) {
		// Make a copy of the options.
		var processedOptions = this._processedOptions = Object.create(options);
		processedOptions.data = this._parseData(options.data);
		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	adapter._parseData = function(data){
		if(!data.metric.length){return [];}
		var result = [],
		    metric_id = data.metric[0].id;

		dv.util.each(data.metric, function(o,k){
			if(o.id != metric_id) {return;}
			var filter_name = data.filter[k].info.name;
			var value = data.value[k];
			result.push({index: filter_name.toLowerCase(), label: filter_name, value:value});
		});
		return result;
	};

	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	rsAdapters.flower = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.funnelObj);

	adapter._processOptions = function(options, changedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var processedOptions = this._processedOptions = Object.create(options);
		// Update data/mappings to match a rs bar chart data set
		this._processData(processedOptions);
		this._updateMappings(processedOptions);

		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter.mappings = function() {
		return this._processedOptions.mappings;
	};

	adapter.formats = function() {
		return this._processedOptions.formats;
	};

	adapter._processData = function(processedOptions) {
		processedOptions.data = Object.create(processedOptions.data);
	};

	adapter._updateMappings = function(processedOptions) {
		// Prototypal inheritance so any attributes we set will merely mask instead of modify the original.
		var mappings = Object.create(processedOptions.mappings);
		// Filter is our x axis, so we only need to break up by metric/datastore
		mappings.x = 'category';
		mappings.y = 'value';
		mappings.series = 'metric_series'; // Each metric will be its own series, even if identical
		mappings.seriesLabel = 'metric_series_name';
		processedOptions.mappings = mappings;
	};
	rsAdapters.funnel = cloudViz.util.createConstructor(adapter);
}(this));
(function(global) {
	'use strict';

	var cloudViz = global.cloudViz,
		rsAdapters = cloudViz.util.namespace('cloudViz.dataAdapter.rs'),
		adapter = Object.create(cloudViz.dataAdapter.standard.wordcloudObj),
		d3 = global.d3 || {};

	adapter._processOptions = function(options, changedOptions) {
		// Make a copy of the options.
		var processedOptions = this._processedOptions = Object.create(options);
		this._processData(processedOptions, options);
		Object.getPrototypeOf(adapter)._processOptions.call(this, processedOptions, changedOptions);
	};

	adapter._processData = function(processedOptions, options) {
		processedOptions.data = options.data;
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	adapter._validateData = function(data, mappings) {
		if (!data) { return false; }
		return true;
	};

	adapter.data = function() {
		return this._processedOptions.data;
	};

	rsAdapters.wordcloud = cloudViz.util.createConstructor(adapter);
}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('de-DE', {
    "monthAbbreviations": [
        "Jan",
        "Feb",
        "März",
        "Apr",
        "Mai",
        "Juni",
        "Juli",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dez"
    ],
    "months": [
        "Januar",
        "Februar",
        "März",
        "April",
        "Mai",
        "Juni",
        "Juli",
        "August",
        "September",
        "Oktober",
        "November",
        "Dezember"
    ],
    "weekdayAbbreviations": [
        "So",
        "Mo",
        "Di",
        "Mi",
        "Do",
        "Fr",
        "Sa"
    ],
    "weekdays": [
        "Sonntag",
        "Montag",
        "Dienstag",
        "Mittwoch",
        "Donnerstag",
        "Freitag",
        "Samstag"
    ],
    "ampm": [
        "AM",
        "PM"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('de-DE', {
    "core": {
        "nodata": "Das Diagramm enthält keine Daten.",
        "erroronrender": "Hoppla! Ein Fehler ist aufgetreten und das Diagramm konnte nicht gerendert werden.",
        "other": "Sonstige",
        "normalized": "Normalisiert"
    },
    "dvcore": {
        "target": "Zielgruppe",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title} (in {time})",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "Größe"
    },
    "pathing": {
        "entry": "Einstieg",
        "exit": "Ausstieg",
        "entry2+": "Einstiege",
        "exit2+": "Ausstiege",
        "path": "Pfad",
        "path2+": "Pfade",
        "expand": "Erweitern",
        "focus": "Fokus",
        "collapse": "Reduzieren",
        "title": "Pfaderstellungs-diagramm",
        "nodeEntries": "Einstiege für {label}",
        "nodeExits": "Ausstiege für {label}",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{perc} von {label}",
        "pathToNode": "{path} zu {label}",
        "pathFromNode": "{path} aus {label}",
        "help1": "Dieses Diagramm stellt Pfade dar, die von einem Status in einen anderen übernommen wurden.",
        "help2": "Jeder Knoten in Form eines Feldes repräsentiert einen Status im Pfad.",
        "help3": "Durch Tippen oder Klicken auf einen Knoten werden zusätzliche Optionen zum Ändern des Diagramms angezeigt:",
        "focusHelp": "Zeigt Pfade an, die am Knoten ein- oder ausgehen.",
        "expandHelp": "Zeigt zusätzliche Pfade an, die am Knoten ein- oder ausgehen.",
        "collapseHelp": "Entfernt Pfade, die am Knoten ein- oder ausgehen."
    },
    "sunburst": {
        "audience": "Zielgruppe",
        "audience2+": "Zielgruppen",
        "category": "Kategorie",
        "category2+": "Kategorien",
        "metric": "Metrik",
        "metric2+": "Metriken",
        "primarymetric": "Primäre Metrik",
        "secondarymetric": "Sekundäre Metrik",
        "secondarymetric2+": "Sekundäre Metriken",
        "secondarymetrichelp": "Klicken Sie auf die Metrik, um die Höhe zu ändern.",
        "secondarymetrichelp2+": "Klicken Sie auf die Metriken, um die Höhe zu ändern.",
        "emptyFirstMetric": "Die erste Metrik enthält keine Werte. Wählen Sie eine andere Metrik.",
        "total": "Gesamt",
        "zoomAction": "Doppelklicken, um zu vergrößern.",
        "moreAction": "Klicken Sie hier für weitere Optionen.",
        "zoomin": "Nahansicht",
        "zoomout": "Weitansicht",
        "hide": "Ausblenden",
        "hideall": "Alles ausblenden",
        "hideother": "Sonstige ausblenden",
        "hidden": "{value} verborgenes Element",
        "hidden2+": "{value} verborgene Elemente",
        "topresults": "Top {value}",
        "color": "Farbe",
        "height": "Höhe",
        "both": "Beide",
        "none": "Keine",
        "mapmetric": "{metric} anzeigen als:",
        "percmetric": "{percent} der {metric}",
        "mobilescroll": "&#x25BC – scrollen Sie, um Details anzuzeigen."
    },
    "flower": {
        "joy": "Freude",
        "admiration": "Bewunderung",
        "fear": "Angst",
        "surprise": "Überraschung",
        "sadness": "Traurigkeit",
        "disgust": "Empörung",
        "anger": "Wut",
        "anticipation": "Vorausschätzung"
    },
    "venn": {
        "definedAudience": "Definierte Zielgruppe"
    },
    "funnel": {
        "step": "Schritt",
        "segment": "Segment",
        "conversion": "Konversion",
        "fallout": "Trichteranalyse",
        "average": "Durchschnitt"
    }
}, 'labels');

global.cloudViz.localeDefinition('de-DE', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%a %e",
        "week": "%a %e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%a %e"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%H Uhr %a %e",
        "day": "%A %e",
        "week": "%A %e",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%H Uhr %a %e"
    },
    "fullFormat": {
        "second": "%H:%M:%S",
        "minute": "%H:%M Uhr %a %e",
        "hour": "%H Uhr %a %e",
        "day": "%A, %e. %B",
        "week": "%A, %e. %B",
        "month": "%B %Y",
        "quarter": "%B %Y",
        "year": "%Y",
        "fallback": "%e %b, %Y",
        "condensed": "%d/%m/%Y",
        "timestamp": "%d %m.%Y %H:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('de-DE', {
    "decimalSeparator": ",",
    "groupSeparator": " ",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    },
    "currency": {
        "symbol": "€",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('de-DE', {
    "singular": {
        "second": "Sekunde",
        "minute": "Minute",
        "hour": "Stunde",
        "day": "Tag",
        "week": "Woche",
        "month": "Monat",
        "year": "Jahr"
    },
    "plural": {
        "second": "Sekunden",
        "minute": "Minuten",
        "hour": "Stunden",
        "day": "Tagen",
        "week": "Wochen",
        "month": "Monate",
        "year": "Jahre"
    },
    "abbreviation": {
        "second": "s",
        "minute": "min",
        "hour": "h",
        "day": "d",
        "week": "w",
        "month": "mon",
        "year": "y"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('en-US', {
	"monthAbbreviations": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	"weekdayAbbreviations": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	"weekdays": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	"ampm": ["AM", "PM"]
}, 'calendar');

global.cloudViz.localeDefinition('en-US', {
	"core": {
		"nodata": "The chart has no data",
		"erroronrender": "Oops! There was an error and the chart could not be rendered.",
		"other": "Other",
		"normalized": "Normalized"
	},
	"dvcore": {
		"target": "Target",
		"yAxisTimeNoTitle": "{time}",
		"yAxisTimeWithTitle": "{title} (in {time})",
		"legendTime": "{value} {time}"
	},
	"point": {
		"xScale": "X",
		"yScale": "Y",
		"sizeScale": "Size"
	},
	"pathing": {
		"entry": "Entry",
		"exit": "Exit",
		"entry2+": "Entries",
		"exit2+": "Exits",
		"path": "Path",
		"path2+": "Paths",
		"expand": "Expand",
		"focus": "Focus",
		"collapse": "Collapse",
		"title": "Pathing Chart",
		"nodeEntries": "{label} Entries",
		"nodeExits": "{label} Exits",
		"nodeToNode": "{source} \u2192 {target}",
		"percOfNode": "{perc} of {label}",
		"pathToNode": "{path} to {label}",
		"pathFromNode": "{path} from {label}",
		"help1": "This chart represents paths taken from one state to another.",
		"help2": "Each node, shaped as a box, represents a state in the path.",
		"help3": "Tapping or clicking a node will provide additional options to modify the chart:",
		"focusHelp": "Shows paths coming into and going out of node",
		"expandHelp": "Shows additional paths coming or going from the node",
		"collapseHelp": "Removes paths coming or going from the node"
	},
	"sunburst": {
		"audience": "Audience",
		"audience2+": "Audiences",
		"category": "Category",
		"category2+": "Categories",
		"metric": "Metric",
		"metric2+": "Metrics",
		"primarymetric": "Primary Metric",
		"secondarymetric": "Secondary Metric",
		"secondarymetric2+": "Secondary Metrics",
		"secondarymetrichelp": "Click metric to toggle height",
		"secondarymetrichelp2+": "Click metrics to toggle height",
		"emptyFirstMetric": "The first metric has no values. Please pick a different metric.",
		"total": "Total",
		"zoomAction": "Double-click to Zoom in.",
		"moreAction": "Click for more options.",
		"zoomin": "Zoom In",
		"zoomout": "Zoom Out",
		"hide": "Hide",
		"hideall": "Hide All",
		"hideother": "Hide Other",
		"hidden": "{value} Hidden Item",
		"hidden2+": "{value} Hidden Items",
		"topresults": "top {value}",
		"color": "Color",
		"height": "Height",
		"both": "Both",
		"none": "None",
		"mapmetric": "Show {metric} as:",
		"percmetric": "{percent} of {metric}",
		"mobilescroll": "&#x25BC scroll for details"
	},
	"flower": {
		"joy": "Joy",
		"admiration": "Admiration",
		"fear": "Fear",
		"surprise": "Surprise",
		"sadness": "Sadness",
		"disgust": "Disgust",
		"anger": "Anger",
		"anticipation": "Anticipation"
	},
	"venn": {
		"definedAudience": "Defined Audience"
	},
	"funnel": {
		"step": "Step",
		"segment": "Segment",
		"conversion": "Conversion",
		"fallout": "Fallout",
		"average": "Average"
	}
}, 'labels');

global.cloudViz.localeDefinition('en-US', {
	"shortFormat" : {
		"second": ":%S",
		"minute": "%I:%M",
		"hour": "%I %p",
		"day": "%e",
		"week": "%e",
		"month": "%b",
		"quarter": "%b",
		"year": "%Y",
		"fallback": "%e"
	},
	"mediumFormat" : {
		"second": "%M:%S",
		"minute": "%I:%M %p",
		"hour": "%I %p",
		"day": "%a %e",
		"week": "%a %e",
		"month": "%b",
		"quarter": "%b",
		"year": "%Y",
		"fallback": "%a %e"
	},
	"longFormat" : {
		"second": "%M:%S",
		"minute": "%I:%M %p",
		"hour": "%I %p %a %e",
		"day": "%A %e",
		"week": "%A %e",
		"month": "%B",
		"quarter": "%B",
		"year": "%Y",
		"fallback": "%I %p %a %e"
	},
	"fullFormat" : {
		"second": "%I:%M:%S %p",
		"minute": "%I:%M %p %a %e",
		"hour": "%I %p %a %e",
		"day": "%A %e %B",
		"week": "%A %e %B",
		"month": "%B %Y",
		"quarter": "%B %Y",
		"year": "%Y",
		"fallback": "%b %e, %Y",
		"condensed": "%m/%d/%Y",
		"timestamp": "%m/%d/%Y %I:%M:%S %p"
	}
}, 'dateFormat');

global.cloudViz.localeDefinition('en-US', {
	"decimalSeparator": ".",
	"groupSeparator": ",",
	"negativePattern": "-{number}",
	"percent": {
		"symbol": "%",
		"positivePattern": "{number}{symbol}",
		"negativePattern": "-{number}{symbol}"
	},
	"currency": {
		"symbol": "$",
		"positivePattern": "{symbol}{number}",
		"negativePattern": "-{symbol}{number}"
	}
}, 'numberFormat');

global.cloudViz.localeDefinition('en-US', {
	"singular" : {
		"second" : "second",
		"minute" : "minute",
		"hour" : "hour",
		"day" : "day",
		"week" : "week",
		"month" : "month",
		"year" : "year"
	},
	"plural" : {
		"second" : "seconds",
		"minute" : "minutes",
		"hour" : "hours",
		"day" : "days",
		"week" : "weeks",
		"month" : "months",
		"year" : "years"
	},
	"abbreviation" : {
		"second" : "s",
		"minute" : "min",
		"hour" : "h",
		"day" : "d",
		"week" : "w",
		"month" : "mon",
		"year" : "y"
	}
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('es-ES', {
    "monthAbbreviations": [
        "en.",
        "febr.",
        "mzo.",
        "abr.",
        "my.",
        "jun.",
        "jul.",
        "ag.",
        "sept.",
        "oct.",
        "nov.",
        "dic."
    ],
    "months": [
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre"
    ],
    "weekdayAbbreviations": [
        "dom.",
        "lun.",
        "mart.",
        "miérc.",
        "juev.",
        "vier.",
        "sáb."
    ],
    "weekdays": [
        "domingo",
        "lunes",
        "martes",
        "miércoles",
        "jueves",
        "viernes",
        "sábado"
    ],
    "ampm": [
        "a. m.",
        "p. m."
    ]
}, 'calendar');

global.cloudViz.localeDefinition('es-ES', {
    "core": {
        "nodata": "El gráfico no contiene datos",
        "erroronrender": "Se ha producido un error y no se ha podido procesar el gráfico.",
        "other": "Otro",
        "normalized": "Normalizado"
    },
    "dvcore": {
        "target": "Destino",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title} (en {time})",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "Tamaño"
    },
    "pathing": {
        "entry": "Entrada",
        "exit": "Salida",
        "entry2+": "Entradas",
        "exit2+": "Salidas",
        "path": "Ruta",
        "path2+": "Rutas",
        "expand": "Expandir",
        "focus": "Enfoque",
        "collapse": "Contraer",
        "title": "Gráfico de ruta",
        "nodeEntries": "Entradas de {label}",
        "nodeExits": "Salidas de {label}",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{perc} de {label}",
        "pathToNode": "{path} a {label}",
        "pathFromNode": "{path} de {label}",
        "help1": "Este gráfico representa las rutas que se pueden tomar para ir de un estado a otro.",
        "help2": "Los nodos, con forma de caja, representan un estado en la ruta.",
        "help3": "Al hacer clic o tocar un nodo, se mostrarán opciones adicionales para modificar el gráfico:",
        "focusHelp": "Muestra las rutas de ida al nodo o de vuelta",
        "expandHelp": "Muestra rutas adicionales de ida al nodo o de vuelta",
        "collapseHelp": "Suprime las rutas de ida al nodo o de vuelta"
    },
    "sunburst": {
        "audience": "Audiencia",
        "audience2+": "Audiencias",
        "category": "Categoría",
        "category2+": "Categorías",
        "metric": "Métrica",
        "metric2+": "Métrica",
        "primarymetric": "Métrica principal",
        "secondarymetric": "Métrica secundaria",
        "secondarymetric2+": "Métricas secundarias",
        "secondarymetrichelp": "Haga clic en la métrica para alternar la altura",
        "secondarymetrichelp2+": "Haga clic en las métricas para alternar la altura",
        "emptyFirstMetric": "La primera métrica no contiene ningún valor. Elija otra métrica.",
        "total": "Total",
        "zoomAction": "Doble clic para aumentar.",
        "moreAction": "Haga clic para ver más opciones.",
        "zoomin": "Acercar",
        "zoomout": "Alejar",
        "hide": "Ocultar",
        "hideall": "Ocultar todo",
        "hideother": "Ocultar otro",
        "hidden": "{value} elemento oculto",
        "hidden2+": "{value} elementos ocultos",
        "topresults": "{value} principales",
        "color": "Color",
        "height": "Altura",
        "both": "Ambos",
        "none": "Ninguno",
        "mapmetric": "Mostrar {metric} como:",
        "percmetric": "{percent} de {metric}",
        "mobilescroll": "&#x25BC desplácese para más detalles"
    },
    "flower": {
        "joy": "Alegría",
        "admiration": "Admiración",
        "fear": "Miedo",
        "surprise": "Sorpresa",
        "sadness": "Tristeza",
        "disgust": "Desagrado",
        "anger": "Enfado",
        "anticipation": "Expectación"
    },
    "venn": {
        "definedAudience": "Audiencia definida"
    },
    "funnel": {
        "step": "Paso",
        "segment": "Segmento",
        "conversion": "Conversión",
        "fallout": "Visita en el orden previsto",
        "average": "Promedio"
    }
}, 'labels');

global.cloudViz.localeDefinition('es-ES', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%a %e",
        "week": "%a %e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%a %e"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%Hh %a %e",
        "day": "%A %e",
        "week": "%A %e",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%Hh %a %e"
    },
    "fullFormat": {
        "second": "%H:%M:%S",
        "minute": "%H:%M %a %e",
        "hour": "%Hh %I %p",
        "day": "%A %e de %B",
        "week": "%A %e de %B",
        "month": "%B %Y",
        "quarter": "%B %Y",
        "year": "%Y",
        "fallback": "%e %b, %Y",
        "condensed": "%d/%m/%Y",
        "timestamp": "%d/%m/%Y %H:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('es-ES', {
    "decimalSeparator": ",",
    "groupSeparator": " ",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    },
    "currency": {
        "symbol": "€",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('es-ES', {
    "singular": {
        "second": "segundo",
        "minute": "minuto",
        "hour": "hora",
        "day": "día",
        "week": "semana",
        "month": "mes",
        "year": "año"
    },
    "plural": {
        "second": "segundos",
        "minute": "minutos",
        "hour": "horas",
        "day": "días",
        "week": "semanas",
        "month": "meses",
        "year": "años"
    },
    "abbreviation": {
        "second": "s",
        "minute": "min",
        "hour": "h",
        "day": "d",
        "week": "w",
        "month": "mon",
        "year": "y"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('fr-FR', {
    "monthAbbreviations": [
        "Janv.",
        "Févr.",
        "Mars",
        "Avr.",
        "Mai",
        "Juin",
        "Juill.",
        "Août",
        "Sept.",
        "Oct.",
        "Nov.",
        "Déc."
    ],
    "months": [
        "janvier",
        "février",
        "mars",
        "avril",
        "mai",
        "juin",
        "juillet",
        "août",
        "septembre",
        "octobre",
        "novembre",
        "décembre"
    ],
    "weekdayAbbreviations": [
        "Dim.",
        "Lun.",
        "Mar.",
        "Mer.",
        "Jeu.",
        "Ven.",
        "Sam."
    ],
    "weekdays": [
        "Dimanche",
        "Lundi",
        "Mardi",
        "Mercredi",
        "Jeudi",
        "Vendredi",
        "Samedi"
    ],
    "ampm": [
        "AM",
        "PM"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('fr-FR', {
    "core": {
        "nodata": "Le graphique ne contient aucune donnée",
        "erroronrender": "Une erreur s’est produite, impossible de restituer le graphique.",
        "other": "Autre",
        "normalized": "Normalisé"
    },
    "dvcore": {
        "target": "Cible",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title} (en {time})",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "Taille"
    },
    "pathing": {
        "entry": "Entrée",
        "exit": "Sortie",
        "entry2+": "Entrées de",
        "exit2+": "Sorties de",
        "path": "Chemin d’accès",
        "path2+": "Chemins d’accès",
        "expand": "Développer",
        "focus": "Mise au point",
        "collapse": "Réduire",
        "title": "Graphique du cheminement",
        "nodeEntries": "Entrées {label}",
        "nodeExits": "Sorties {label}",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{perc} de {label}",
        "pathToNode": "{path} à {label}",
        "pathFromNode": "{path} de {label}",
        "help1": "Ce graphique représente les chemins d’accès récupérés d’un état à un autre.",
        "help2": "Chaque nœud, en forme de cadre, représente un état dans le chemin d’accès.",
        "help3": "Le fait d’appuyer ou de cliquer sur un nœud fournit d’autres options pour modifier le graphique :",
        "focusHelp": "Présente les chemins d’accès issus du nœud ou y parvenant",
        "expandHelp": "Présente des chemins d’accès supplémentaires issus du nœud ou y parvenant.",
        "collapseHelp": "Supprime les chemins d’accès supplémentaires issus du nœud ou y parvenant."
    },
    "sunburst": {
        "audience": "Audience",
        "audience2+": "Audiences",
        "category": "Catégorie",
        "category2+": "Catégories",
        "metric": "Mesure",
        "metric2+": "Mesures",
        "primarymetric": "Mesure principale",
        "secondarymetric": "Mesure secondaire",
        "secondarymetric2+": "Mesures secondaires",
        "secondarymetrichelp": "Cliquer sur une mesure pour activer/désactiver la hauteur",
        "secondarymetrichelp2+": "Cliquer sur des mesures pour activer/désactiver la hauteur",
        "emptyFirstMetric": "La première mesure n’a aucune valeur. Sélectionnez une autre mesure.",
        "total": "Total",
        "zoomAction": "Double-cliquez pour effectuer un zoom avant.",
        "moreAction": "Cliquez pour plus d’options.",
        "zoomin": "Zoom avant",
        "zoomout": "Zoom arrière",
        "hide": "Masquer",
        "hideall": "Tout masquer",
        "hideother": "Masquer autres",
        "hidden": "{value} élément masqué",
        "hidden2+": "{value} éléments masqués",
        "topresults": "{value} premiers",
        "color": "Couleur",
        "height": "Hauteur",
        "both": "Les deux",
        "none": "Néant",
        "mapmetric": "Afficher {metric} comme :",
        "percmetric": "{percent} des {metric}",
        "mobilescroll": "Défilement &#x25BC pour plus de détails"
    },
    "flower": {
        "joy": "Joie",
        "admiration": "Admiration",
        "fear": "Peur",
        "surprise": "Surprise",
        "sadness": "Tristesse",
        "disgust": "Dégoût",
        "anger": "Colère",
        "anticipation": "Anticipation"
    },
    "venn": {
        "definedAudience": "Audience définie"
    },
    "funnel": {
        "step": "Etape",
        "segment": "Segment",
        "conversion": "Conversion",
        "fallout": "Abandons",
        "average": "Moyenne"
    }
}, 'labels');

global.cloudViz.localeDefinition('fr-FR', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%a %e",
        "week": "%a %e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%a %e"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%H h %a %e",
        "day": "%A %e",
        "week": "%A %e",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%H h %a %e"
    },
    "fullFormat": {
        "second": "%H:%M:%S",
        "minute": "%H:%M %a %e",
        "hour": "%H h %a %e",
        "day": "%A %e %B",
        "week": "%A %e %B",
        "month": "%B %Y",
        "quarter": "%B %Y",
        "year": "%Y",
        "fallback": "%e %b %Y",
        "condensed": "%d/%m/%Y",
        "timestamp": "%d/%m/%Y %H:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('fr-FR', {
    "decimalSeparator": ",",
    "groupSeparator": " ",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    },
    "currency": {
        "symbol": "€",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('fr-FR', {
    "singular": {
        "second": "seconde",
        "minute": "minute",
        "hour": "heure",
        "day": "jour",
        "week": "semaine",
        "month": "mois",
        "year": "année"
    },
    "plural": {
        "second": "secondes",
        "minute": "minutes",
        "hour": "heures",
        "day": "jours",
        "week": "semaines",
        "month": "mois",
        "year": "années"
    },
    "abbreviation": {
        "second": "s",
        "minute": "min",
        "hour": "h",
        "day": "d",
        "week": "w",
        "month": "mon",
        "year": "y"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('ja-JP', {
    "monthAbbreviations": [
        "1月",
        "2月",
        "3月",
        "4月",
        "5月",
        "6月",
        "7月",
        "8月",
        "9月",
        "10月",
        "11月",
        "12月"
    ],
    "months": [
        "1月",
        "2月",
        "3月",
        "4月",
        "5月",
        "6月",
        "7月",
        "8月",
        "9月",
        "10月",
        "11月",
        "12月"
    ],
    "weekdayAbbreviations": [
        "日",
        "月",
        "火",
        "水",
        "木",
        "金",
        "土"
    ],
    "weekdays": [
        "日曜日",
        "月曜日",
        "火曜日",
        "水曜日",
        "木曜日",
        "金曜日",
        "土曜日"
    ],
    "ampm": [
        "午前",
        "午後"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('ja-JP', {
    "core": {
        "nodata": "データがありません",
        "erroronrender": "エラーのためチャートを作成できません",
        "other": "その他",
        "normalized": "正規化済み"
    },
    "dvcore": {
        "target": "Target",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title} ({time})",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "Size"
    },
    "pathing": {
        "entry": "入口",
        "exit": "出口",
        "entry2+": "入口",
        "exit2+": "出口",
        "path": "パス内訳",
        "path2+": "パス内訳",
        "expand": "展開する",
        "focus": "再スタート",
        "collapse": "減らす",
        "title": "遷移チャート",
        "nodeEntries": "{label} 入口",
        "nodeExits": "{label} 出口",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{label}の{perc}",
        "pathToNode": "{label}への{path}",
        "pathFromNode": "{label}からの{path}",
        "help1": "流れ（パス）を現すチャートです。",
        "help2": "四角形のノードがデータ項目です。",
        "help3": "ノードをクリック（タップ）すると、以下のようなチャート設定用アイコンが表示されます：",
        "focusHelp": "画面をクリアし、該当ノードの前後のパスのみを表示",
        "expandHelp": "該当ノードの前後のパスをさらに表示",
        "collapseHelp": "展開したパスを元に戻す"
    },
    "sunburst": {
        "audience": "オーディエンス",
        "audience2+": "オーディエンス",
        "category": "カテゴリ",
        "category2+": "カテゴリ",
        "metric": "指標",
        "metric2+": "指標",
        "primarymetric": "一次指標",
        "secondarymetric": "二次指標",
        "secondarymetric2+": "二次指標",
        "secondarymetrichelp": "指標をクリックすると高さが変わる",
        "secondarymetrichelp2+": "指標をクリックすると高さが変わる",
        "emptyFirstMetric": "最も内側の円となる最初の指標のデータが存在しないため、チャートを描画できません。",
        "total": "合計",
        "zoomAction": "ダブルクリックでズームイン",
        "moreAction": "クリックで選択肢を表示",
        "zoomin": "ズームイン",
        "zoomout": "ズームアウト",
        "hide": "選択項目のみ除外",
        "hideall": "全体から同じ項目を除外",
        "hideother": "この項目以外を除外",
        "hidden": "{value} 個の項目を除外中",
        "hidden2+": "{value} 個の項目を除外中",
        "topresults": "上位{value}件",
        "color": "色",
        "height": "高さ",
        "both": "両方",
        "none": "なし",
        "mapmetric": "{metric}の表示方法:",
        "percmetric": "{metric}の{percent}",
        "mobilescroll": "&#x25BC スクロールして詳細を表示"
    },
    "flower": {
        "joy": "喜び",
        "admiration": "賞賛",
        "fear": "恐怖",
        "surprise": "驚き",
        "sadness": "悲しみ",
        "disgust": "不快",
        "anger": "怒り",
        "anticipation": "予測"
    },
    "venn": {
        "definedAudience": "定義されたオーディエンス"
    },
    "funnel": {
        "step": "ステップ",
        "segment": "セグメント",
        "conversion": "コンバージョン",
        "fallout": "フォールアウト",
        "average": "平均"
    }
}, 'labels');

global.cloudViz.localeDefinition('ja-JP', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%I 時 %M 分",
        "hour": "%p %I 時",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%p %I 時 %M 分",
        "hour": "%p %I 時",
        "day": "%e 日 (%a)",
        "week": "%e 日 (%a)",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e 日 (%a)"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%p %I 時 %M 分",
        "hour": "%e 日 (%a) %p %I 時",
        "day": "%e 日 (%a)",
        "week": "%e 日 (%a)",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%e 日 (%a) %p %I 時"
    },
    "fullFormat": {
        "second": "%p %I 時 %M 分 %S 秒",
        "minute": "%e 日 (%a) %p %I 時 %M 分",
        "hour": "%e 日 (%a) %p %I 時",
        "day": "%B %e日%A",
        "week": "%B %e日%A",
        "month": "%Y 年 %B",
        "quarter": "%Y 年 %B",
        "year": "%Y",
        "fallback": "%Y 年 %b %e 日",
        "condensed": "%Y/%m/%d",
        "timestamp": "%Y 年 %m 月 %d 日、%p %I 時 %M 分 %S 秒"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('ja-JP', {
    "decimalSeparator": ".",
    "groupSeparator": ",",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number}{symbol}",
        "negativePattern": "-{number}{symbol}"
    },
    "currency": {
        "symbol": "¥",
        "positivePattern": "{symbol}{number}",
        "negativePattern": "-{symbol}{number}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('ja-JP', {
    "singular": {
        "second": "秒",
        "minute": "分",
        "hour": "時間",
        "day": "日",
        "week": "週間",
        "month": "か月",
        "year": "年"
    },
    "plural": {
        "second": "秒",
        "minute": "分",
        "hour": "時間",
        "day": "日",
        "week": "週間",
        "month": "か月",
        "year": "年"
    },
    "abbreviation": {
        "second": "秒",
        "minute": "分",
        "hour": "時間",
        "day": "日",
        "week": "週間",
        "month": "か月",
        "year": "年"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('ko-KR', {
    "monthAbbreviations": [
        "1월",
        "2월",
        "3월",
        "4월",
        "5월",
        "6월",
        "7월",
        "8월",
        "9월",
        "10월",
        "11월",
        "12월"
    ],
    "months": [
        "1월",
        "2월",
        "3월",
        "4월",
        "5월",
        "6월",
        "7월",
        "8월",
        "9월",
        "10월",
        "11월",
        "12월"
    ],
    "weekdayAbbreviations": [
        "일",
        "월",
        "화",
        "수",
        "목",
        "금",
        "토"
    ],
    "weekdays": [
        "일요일",
        "월요일",
        "화요일",
        "수요일",
        "목요일",
        "금요일",
        "토요일"
    ],
    "ampm": [
        "오전",
        "오후"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('ko-KR', {
    "core": {
        "nodata": "차트에 데이터가 없습니다.",
        "erroronrender": "오류가 발생하여 차트를 렌더링할 수 없습니다.",
        "other": "기타",
        "normalized": "정규화됨"
    },
    "dvcore": {
        "target": "목표",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title}({time})",
        "legendTime": "{value}{time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "크기"
    },
    "pathing": {
        "entry": "시작",
        "exit": "종료",
        "entry2+": "시작",
        "exit2+": "종료",
        "path": "경로",
        "path2+": "경로",
        "expand": "확장",
        "focus": "포커스",
        "collapse": "축소",
        "title": "경로 지정 차트",
        "nodeEntries": "{label} 시작",
        "nodeExits": "{label} 종료",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{label}의 {perc}",
        "pathToNode": "{label} 나가는 {path}",
        "pathFromNode": "{label} 들어오는 {path}",
        "help1": "이 차트는 하나의 주에서 다른 주로 가져온 경로를 나타냅니다.",
        "help2": "상자 모양의 노드는 각각 경로 내의 주를 나타냅니다.",
        "help3": "노드를 누르거나 클릭하면 차트를 수정할 추가 옵션을 설정할 수 있습니다.",
        "focusHelp": "노드에 들어오거나 나가는 경로 표시",
        "expandHelp": "노드에 들어오거나 나가는 추가 경로 표시",
        "collapseHelp": "노드에 들어오거나 나가는 경로 제거"
    },
    "sunburst": {
        "audience": "대상",
        "audience2+": "대상",
        "category": "카테고리",
        "category2+": "카테고리",
        "metric": "지표",
        "metric2+": "지표",
        "primarymetric": "기본 지표",
        "secondarymetric": "보조 지표",
        "secondarymetric2+": "보조 지표",
        "secondarymetrichelp": "지표를 클릭하여 높이 전환",
        "secondarymetrichelp2+": "지표를 클릭하여 높이 전환",
        "emptyFirstMetric": "첫 번째 지표에 값이 없습니다. 다른 지표를 선택하십시오.",
        "total": "합계",
        "zoomAction": "확대하려면 두 번 클릭하십시오.",
        "moreAction": "추가 옵션을 보려면 클릭하십시오.",
        "zoomin": "확대",
        "zoomout": "축소",
        "hide": "숨김",
        "hideall": "모두 숨기기",
        "hideother": "나머지 숨기기",
        "hidden": "{value}개의 숨긴 항목",
        "hidden2+": "{value}개의 숨긴 항목",
        "topresults": "상위 {value}개",
        "color": "색상",
        "height": "높이",
        "both": "둘 다",
        "none": "없음",
        "mapmetric": "{metric} 다음으로 표시:",
        "percmetric": "{metric} 수의 {percent} ",
        "mobilescroll": "&#x25BC 자세한 내용을 보려면 스크롤하십시오."
    },
    "flower": {
        "joy": "기쁨",
        "admiration": "감탄",
        "fear": "두려움",
        "surprise": "놀람",
        "sadness": "슬픔",
        "disgust": "혐오",
        "anger": "분노",
        "anticipation": "기대"
    },
    "venn": {
        "definedAudience": "정의된 대상"
    },
    "funnel": {
        "step": "단계",
        "segment": "세그먼트",
        "conversion": "전환",
        "fallout": "폴아웃",
        "average": "평균"
    }
}, 'labels');

global.cloudViz.localeDefinition('ko-KR', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%I:%M",
        "hour": "%p %I",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%p %I:%M",
        "hour": "%p %I",
        "day": "%e일 %a",
        "week": "%e일 %a",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e일 %a"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%p %I:%M",
        "hour": "%e일 %a %p %I",
        "day": "%e일 %A",
        "week": "%e일 %A",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%e일 %a %p %I"
    },
    "fullFormat": {
        "second": "%p %I:%M:%S",
        "minute": "%e일 %a %p %I:%M",
        "hour": "%e일 %a %p %I",
        "day": "%B %e일, %A",
        "week": "%B %e일, %A",
        "month": "%Y 년 %B",
        "quarter": "%Y %B",
        "year": "%Y",
        "fallback": "%Y %b %e일",
        "condensed": "%Y/%m/%d",
        "timestamp": "%Y/%m/%d %p %I:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('ko-KR', {
    "decimalSeparator": ".",
    "groupSeparator": ",",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number}{symbol}",
        "negativePattern": "-{number}{symbol}"
    },
    "currency": {
        "symbol": "₩",
        "positivePattern": "{symbol}{number}",
        "negativePattern": "-{symbol}{number}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('ko-KR', {
    "singular": {
        "second": "초",
        "minute": "분",
        "hour": "시간",
        "day": "일",
        "week": "주",
        "month": "월",
        "year": "년"
    },
    "plural": {
        "second": "초",
        "minute": "분",
        "hour": "시간",
        "day": "일",
        "week": "주",
        "month": "월",
        "year": "년"
    },
    "abbreviation": {
        "second": "초",
        "minute": "분",
        "hour": "시간",
        "day": "일",
        "week": "주",
        "month": "월",
        "year": "년"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('pt-BR', {
    "monthAbbreviations": [
        "Jan",
        "Fev",
        "Mar",
        "Abr",
        "Mai",
        "Jun",
        "Jul",
        "Ago",
        "Set",
        "Out",
        "Nov",
        "Dez"
    ],
    "months": [
        "janeiro",
        "fevereiro",
        "março",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro"
    ],
    "weekdayAbbreviations": [
        "Dom",
        "Seg",
        "Ter",
        "Qua",
        "Qui",
        "Sex",
        "Sáb"
    ],
    "weekdays": [
        "Domingo",
        "Segunda-feira",
        "Terça-feira",
        "Quarta-feira",
        "Quinta-feira",
        "Sexta-feira",
        "Sábado"
    ],
    "ampm": [
        "AM",
        "PM"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('pt-BR', {
    "core": {
        "nodata": "O gráfico não possui dados",
        "erroronrender": "Ops! Houve um erro e o gráfico não pôde ser processado.",
        "other": "Outro",
        "normalized": "Normalizado"
    },
    "dvcore": {
        "target": "Meta",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title} (em {time})",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "Tamanho"
    },
    "pathing": {
        "entry": "Entrada",
        "exit": "Sair",
        "entry2+": "Entradas",
        "exit2+": "Saídas",
        "path": "Caminho",
        "path2+": "Caminhos",
        "expand": "Expandir",
        "focus": "Foco",
        "collapse": "Recolher",
        "title": "Gráfico de criação de caminho",
        "nodeEntries": "{label} Entradas",
        "nodeExits": "{label} Saídas",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{perc} de {label}",
        "pathToNode": "{path} para {label}",
        "pathFromNode": "{path} de {label}",
        "help1": "Esse gráfico representa os caminhos tomados de um estado para outro.",
        "help2": "Cada nó, formado como uma caixa representa um estado no caminho.",
        "help3": "Tocar ou clicar em um nó fornecerá opções adicionais para modificar o gráfico:",
        "focusHelp": "Mostra os caminhos entrando ou saindo do nó",
        "expandHelp": "Mostra caminhos adicionais entrando ou saindo do nó",
        "collapseHelp": "Remove os caminhos saindo ou entrando no nó"
    },
    "sunburst": {
        "audience": "Público-alvo",
        "audience2+": "Públicos-alvos",
        "category": "Categoria",
        "category2+": "Categorias",
        "metric": "Métrica",
        "metric2+": "Métricas",
        "primarymetric": "Métrica principal",
        "secondarymetric": "Métrica secundária",
        "secondarymetric2+": "Métricas secundárias",
        "secondarymetrichelp": "Clique na métrica para alternar a altura",
        "secondarymetrichelp2+": "Clique nas métricas para alternar a altura",
        "emptyFirstMetric": "A primeira métrica não tem valores. Esolha uma métrica diferente.",
        "total": "Total",
        "zoomAction": "Clique duas vezes para aumentar o zoom.",
        "moreAction": "Clique para ver mais opções.",
        "zoomin": "Ampliar",
        "zoomout": "Reduzir",
        "hide": "Ocultar",
        "hideall": "Ocultar tudo",
        "hideother": "Ocultar outro",
        "hidden": "{value} Item oculto",
        "hidden2+": "{value} itens ocultos",
        "topresults": "principais {value}",
        "color": "Cor",
        "height": "Altura",
        "both": "Ambos",
        "none": "Nenhum",
        "mapmetric": "Mostrar {metric} como:",
        "percmetric": "{percent} de {metric}",
        "mobilescroll": "&#x25BC role para ver os detalhes"
    },
    "flower": {
        "joy": "Alegria",
        "admiration": "Admiração",
        "fear": "Medo",
        "surprise": "Problemas",
        "sadness": "Tristeza",
        "disgust": "Repulsa",
        "anger": "Raiva",
        "anticipation": "Antecipação"
    },
    "venn": {
        "definedAudience": "Público-alvo definido"
    },
    "funnel": {
        "step": "Etapa",
        "segment": "Segmento",
        "conversion": "Conversão",
        "fallout": "Fallout",
        "average": "Média"
    }
}, 'labels');

global.cloudViz.localeDefinition('pt-BR', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%H",
        "day": "%a %e",
        "week": "%a %e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%a %e"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%H:%M",
        "hour": "%Hh %a %e",
        "day": "%A %e",
        "week": "%A %e",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%Hh %a %e"
    },
    "fullFormat": {
        "second": "%H:%M:%S",
        "minute": "%H:%M %a %e",
        "hour": "%Hh %a %e",
        "day": "%A, %e de %B",
        "week": "%A, %e de %B",
        "month": "%B %Y",
        "quarter": "%B %Y",
        "year": "%Y",
        "fallback": "%e %b, %Y",
        "condensed": "%Y/%m/%d",
        "timestamp": "%m/%d/%Y %H:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('pt-BR', {
    "decimalSeparator": ",",
    "groupSeparator": " ",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    },
    "currency": {
        "symbol": "R$",
        "positivePattern": "{number} {symbol}",
        "negativePattern": "-{number} {symbol}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('pt-BR', {
    "singular": {
        "second": "segundo",
        "minute": "minuto",
        "hour": "hora",
        "day": "día",
        "week": "semana",
        "month": "mês",
        "year": "ano"
    },
    "plural": {
        "second": "segundos",
        "minute": "minutos",
        "hour": "horas",
        "day": "dias",
        "week": "semanas",
        "month": "meses",
        "year": "anos"
    },
    "abbreviation": {
        "second": "s",
        "minute": "min",
        "hour": "h",
        "day": "d",
        "week": "w",
        "month": "mon",
        "year": "y"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('zh-CN', {
    "monthAbbreviations": [
        "1 月",
        "2 月",
        "3 月",
        "4 月",
        "5 月",
        "6 月",
        "7 月",
        "8 月",
        "9 月",
        "10 月",
        "11 月",
        "12 月"
    ],
    "months": [
        "1 月",
        "2 月",
        "3 月",
        "4 月",
        "5 月",
        "6 月",
        "7 月",
        "8 月",
        "9 月",
        "10 月",
        "11 月",
        "12 月"
    ],
    "weekdayAbbreviations": [
        "周日",
        "周一",
        "周二",
        "周三",
        "周四",
        "周五",
        "周六"
    ],
    "weekdays": [
        "星期日",
        "星期一",
        "星期二",
        "星期三",
        "星期四",
        "星期五",
        "星期六"
    ],
    "ampm": [
        "上午",
        "下午"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('zh-CN', {
    "core": {
        "nodata": "图表无数据",
        "erroronrender": "抱歉！出现错误，无法呈现图表。",
        "other": "其他",
        "normalized": "已标准化"
    },
    "dvcore": {
        "target": "目标",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title}（{time}）",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "大小"
    },
    "pathing": {
        "entry": "登入",
        "exit": "退出",
        "entry2+": "登入",
        "exit2+": "退出",
        "path": "路径",
        "path2+": "路径",
        "expand": "展开",
        "focus": "聚焦",
        "collapse": "折叠",
        "title": "路径图表",
        "nodeEntries": "{label} 登入",
        "nodeExits": "{label} 退出",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{perc} 的 {label}",
        "pathToNode": "前往 {label} 的 {path}",
        "pathFromNode": "来自 {label} 的 {path}",
        "help1": "此图表代表从一种状态转变为另一种状态的路径。",
        "help2": "每个长方形节点代表路径中的一种状态。",
        "help3": "轻按或单击节点可以提供修改图表的其他选项：",
        "focusHelp": "显示来往于节点的路径",
        "expandHelp": "显示来往于节点的其他路径",
        "collapseHelp": "删除来往于节点的路径"
    },
    "sunburst": {
        "audience": "受众",
        "audience2+": "受众",
        "category": "类别",
        "category2+": "类别",
        "metric": "量度",
        "metric2+": "量度",
        "primarymetric": "主要量度",
        "secondarymetric": "次要量度",
        "secondarymetric2+": "次要量度",
        "secondarymetrichelp": "单击量度可切换高度",
        "secondarymetrichelp2+": "单击量度可切换高度",
        "emptyFirstMetric": "第一个量度没有值。请选择其他量度。",
        "total": "合计",
        "zoomAction": "双击可放大。",
        "moreAction": "单击可获取更多选项。",
        "zoomin": "放大",
        "zoomout": "缩小",
        "hide": "隐藏",
        "hideall": "全部隐藏",
        "hideother": "隐藏其他",
        "hidden": "{value} 个隐藏的条目",
        "hidden2+": "{value} 个隐藏的条目",
        "topresults": "排名前 {value}",
        "color": "彩色",
        "height": "高度",
        "both": "两者",
        "none": "无",
        "mapmetric": "{metric} 显示方式:",
        "percmetric": "{percent} 的 {metric}",
        "mobilescroll": "&#x25BC 展开详细信息"
    },
    "flower": {
        "joy": "欢快",
        "admiration": "羡慕",
        "fear": "害怕",
        "surprise": "惊讶",
        "sadness": "伤心",
        "disgust": "厌恶",
        "anger": "生气",
        "anticipation": "期待"
    },
    "venn": {
        "definedAudience": "定义的受众"
    },
    "funnel": {
        "step": "步骤",
        "segment": "区段",
        "conversion": "转化",
        "fallout": "流失",
        "average": "平均"
    }
}, 'labels');

global.cloudViz.localeDefinition('zh-CN', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%I:%M",
        "hour": "%p %I",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%p %I:%M",
        "hour": "%p %I",
        "day": "%e 日 %a",
        "week": "%e 日 %a",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e 日 %a"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%p %I:%M",
        "hour": "%e 日 %a %p %I",
        "day": "%e 日 %A",
        "week": "%e 日 %A",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%e 日 %a %p %I"
    },
    "fullFormat": {
        "second": "%p %I:%M:%S",
        "minute": "%e 日 (%a) %p %I:%M",
        "hour": "%e 日 %a %p %I",
        "day": "%B %e 日，%A",
        "week": "%B %e 日，%A",
        "month": "%Y 年%B",
        "quarter": "%Y %B",
        "year": "%Y",
        "fallback": "%Y %b %e 日",
        "condensed": "%Y/%m/%d",
        "timestamp": "%Y/%m/%d %p %I:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('zh-CN', {
    "decimalSeparator": ".",
    "groupSeparator": ",",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number}{symbol}",
        "negativePattern": "-{number}{symbol}"
    },
    "currency": {
        "symbol": "¥",
        "positivePattern": "{symbol}{number}",
        "negativePattern": "-{symbol}{number}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('zh-CN', {
    "singular": {
        "second": "秒",
        "minute": "分钟",
        "hour": "小时",
        "day": "天",
        "week": "周",
        "month": "月",
        "year": "年"
    },
    "plural": {
        "second": "秒",
        "minute": "分钟",
        "hour": "小时",
        "day": "天",
        "week": "周",
        "month": "月",
        "year": "年"
    },
    "abbreviation": {
        "second": "秒",
        "minute": "分钟",
        "hour": "小时",
        "day": "天",
        "week": "周",
        "month": "月",
        "year": "年"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('zh-TW', {
    "monthAbbreviations": [
        "1 月",
        "2 月",
        "3 月",
        "4 月",
        "5 月",
        "6 月",
        "7 月",
        "8 月",
        "9 月",
        "10 月",
        "11 月",
        "12 月"
    ],
    "months": [
        "1 月",
        "2 月",
        "3 月",
        "4 月",
        "5 月",
        "6 月",
        "7 月",
        "8 月",
        "9 月",
        "10 月",
        "11 月",
        "12 月"
    ],
    "weekdayAbbreviations": [
        "週日",
        "週一",
        "週二",
        "週三",
        "週四",
        "週五",
        "週六"
    ],
    "weekdays": [
        "星期日",
        "星期一",
        "星期二",
        "星期三",
        "星期四",
        "星期五",
        "星期六"
    ],
    "ampm": [
        "上午",
        "下午"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('zh-TW', {
    "core": {
        "nodata": "此圖表沒有任何資料",
        "erroronrender": "糟糕！發生錯誤，無法產生圖表。",
        "other": "其他",
        "normalized": "已標準化"
    },
    "dvcore": {
        "target": "目標",
        "yAxisTimeNoTitle": "{time}",
        "yAxisTimeWithTitle": "{title} (以{time}數計)",
        "legendTime": "{value} {time}"
    },
    "point": {
        "xScale": "X",
        "yScale": "Y",
        "sizeScale": "大小"
    },
    "pathing": {
        "entry": "登入點",
        "exit": "退出點",
        "entry2+": "登入點",
        "exit2+": "退出點",
        "path": "路徑",
        "path2+": "路徑",
        "expand": "展開",
        "focus": "焦點",
        "collapse": "摺疊",
        "title": "路徑圖表",
        "nodeEntries": "{label} 登入點",
        "nodeExits": "{label} 退出點",
        "nodeToNode": "{source} → {target}",
        "percOfNode": "{perc} 的 {label}",
        "pathToNode": "連至 {label} 的 {path}",
        "pathFromNode": "來自 {label} 的 {path}",
        "help1": "此圖表代表從一狀態變為另一狀態的路徑。",
        "help2": "每個設計成方塊的節點都代表路徑中的一種狀態。",
        "help3": "點選或按一下節點即可取得用於修改圖表的其他選項:",
        "focusHelp": "顯示進出節點的路徑",
        "expandHelp": "顯示前往或遠離節點的其他路徑",
        "collapseHelp": "移除前往或遠離節點的路徑"
    },
    "sunburst": {
        "audience": "讀者",
        "audience2+": "讀者",
        "category": "類別",
        "category2+": "類別",
        "metric": "量度",
        "metric2+": "量度",
        "primarymetric": "主要量度",
        "secondarymetric": "次要量度",
        "secondarymetric2+": "次要量度",
        "secondarymetrichelp": "按一下量度以切換高度",
        "secondarymetrichelp2+": "按一下量度以切換高度",
        "emptyFirstMetric": "第一個量度沒有值。請選擇其他量度。",
        "total": "總計",
        "zoomAction": "連按兩下來放大顯示。",
        "moreAction": "按一下存取更多選項。",
        "zoomin": "放大",
        "zoomout": "縮小",
        "hide": "隱藏",
        "hideall": "全部隱藏",
        "hideother": "隱藏其他",
        "hidden": "{value} 個隱藏項目",
        "hidden2+": "{value} 個隱藏項目",
        "topresults": "前 {value} 個項目",
        "color": "色彩",
        "height": "高度",
        "both": "兩者",
        "none": "無",
        "mapmetric": "將 {metric} 顯示為:",
        "percmetric": "{percent} 的 {metric}",
        "mobilescroll": "&#x25BC 捲動以瞭解詳細資料"
    },
    "flower": {
        "joy": "歡樂",
        "admiration": "欽佩",
        "fear": "恐懼",
        "surprise": "驚喜",
        "sadness": "傷心",
        "disgust": "噁心",
        "anger": "憤怒",
        "anticipation": "期望"
    },
    "venn": {
        "definedAudience": "特定讀者"
    },
    "funnel": {
        "step": "步驟",
        "segment": "區段",
        "conversion": "轉換",
        "fallout": "流失",
        "average": "平均"
    }
}, 'labels');

global.cloudViz.localeDefinition('zh-TW', {
    "shortFormat": {
        "second": ":%S",
        "minute": "%I:%M",
        "hour": "%p %I",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "%M:%S",
        "minute": "%p %I:%M",
        "hour": "%p %I",
        "day": "%e 日 %a",
        "week": "%e 日 %a",
        "month": "%b",
        "quarter": "%b",
        "year": "%Y",
        "fallback": "%e 日 %a"
    },
    "longFormat": {
        "second": "%M:%S",
        "minute": "%p %I:%M",
        "hour": "%e 日 %a %p %I",
        "day": "%e 日 %A",
        "week": "%e 日 %A",
        "month": "%B",
        "quarter": "%B",
        "year": "%Y",
        "fallback": "%e 日 %a %p %I"
    },
    "fullFormat": {
        "second": "%p %I:%M:%S",
        "minute": "%e 日 %a %p %I:%M",
        "hour": "%e 日 %a %p %I",
        "day": "%B %e 日，%A",
        "week": "%B %e 日，%A",
        "month": "%Y 年 %B",
        "quarter": "%Y %B",
        "year": "%Y",
        "fallback": "%Y %b %e 日",
        "condensed": "%Y/%m/%d",
        "timestamp": "%Y/%m/%d %p %I:%M:%S"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('zh-TW', {
    "decimalSeparator": ".",
    "groupSeparator": ",",
    "negativePattern": "-{number}",
    "percent": {
        "symbol": "%",
        "positivePattern": "{number}{symbol}",
        "negativePattern": "-{number}{symbol}"
    },
    "currency": {
        "symbol": "NT$",
        "positivePattern": "{symbol}{number}",
        "negativePattern": "-{symbol}{number}"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('zh-TW', {
    "singular": {
        "second": "秒",
        "minute": "分鐘",
        "hour": "小時",
        "day": "天",
        "week": "週",
        "month": "月",
        "year": "年"
    },
    "plural": {
        "second": "秒",
        "minute": "分鐘",
        "hour": "小時",
        "day": "天",
        "week": "週",
        "month": "月",
        "year": "年"
    },
    "abbreviation": {
        "second": "秒",
        "minute": "分鐘",
        "hour": "小時",
        "day": "天",
        "week": "週",
        "month": "月",
        "year": "年"
    }
}, 'time');

}(this));

(function(global) {
	'use strict';

global.cloudViz.localeDefinition('zz-ZZ', {
    "monthAbbreviations": [
        "[g] 승_Jan_文",
        "[q] 승_Feb_文",
        "[r] 승_Mar_文",
        "[n] 승_Apr_文",
        "[p] 승_May_文",
        "[k] 승_Jun_文",
        "[l] 승_Jul_文",
        "[i] 승_Aug_文",
        "[j] 승_Sep_文",
        "[h] 승_Oct_文",
        "[o] 승_Nov_文",
        "[m] 승_Dec_文"
    ],
    "months": [
        "[1] 승_January_文",
        "[2] 승_February_文",
        "[3] 승_March_文",
        "[x] 승_April_文",
        "[y] 승_May_文",
        "[z] 승_June_文",
        "[0] 승_July_文",
        "[s] 승_August_文",
        "[t] 승_September_文",
        "[u] 승_October_文",
        "[v] 승_November_文",
        "[w] 승_December_文"
    ],
    "weekdayAbbreviations": [
        "[+] 승_Sun_文",
        "[4] 승_Mon_文",
        "[5] 승_Tue_文",
        "[6] 승_Wed_文",
        "[7] 승_Thu_文",
        "[8] 승_Fri_文",
        "[9] 승_Sat_文"
    ],
    "weekdays": [
        "[BB] 승_Sunday_文",
        "[BA] 승_Monday_文",
        "[/] 승_Tuesday_文",
        "[BC] 승_Wednesday_文",
        "[BD] 승_Thursday_文",
        "[BE] 승_Friday_文",
        "[BF] 승_Saturday_文"
    ],
    "ampm": [
        "[e] 승_AM_文",
        "[f] 승_PM_文"
    ]
}, 'calendar');

global.cloudViz.localeDefinition('zz-ZZ', {
    "core": {
        "nodata": "[BH] 승_The chart has no data_文",
        "erroronrender": "[BG] 승_Oops! There was an error and the chart could not be rendered._文",
        "other": "[BJ] 승_Other_文",
        "normalized": "[BI] 승_Normalized_文"
    },
    "dvcore": {
        "target": "[BL] 승_Target_文",
        "yAxisTimeNoTitle": "[BK] 승_{time}_文",
        "yAxisTimeWithTitle": "[BN] 승_{title} (in {time})_文",
        "legendTime": "[BM] 승_{value} {time}_文"
    },
    "point": {
        "xScale": "[Bp] 승_X_文",
        "yScale": "[Br] 승_Y_文",
        "sizeScale": "[Bq] 승_Size_文"
    },
    "pathing": {
        "entry": "[Be] 승_Entry_文",
        "exit": "[Bg] 승_Exit_文",
        "entry2+": "[Bn] 승_Entries_文",
        "exit2+": "[Bb] 승_Exits_文",
        "path": "[BZ] 승_Path_文",
        "path2+": "[Bf] 승_Paths_文",
        "expand": "[BX] 승_Expand_文",
        "focus": "[BW] 승_Focus_文",
        "collapse": "[Bj] 승_Collapse_文",
        "title": "[Bc] 승_Pathing Chart_文",
        "nodeEntries": "[Cz] 승_{label} Entries_文",
        "nodeExits": "[C0] 승_{label} Exits_文",
        "nodeToNode": "[Cy] 승_{source} → {target}_文",
        "percOfNode": "[Ba] 승_{perc} of {label}_文",
        "pathToNode": "[Bo] 승_{path} to {label}_文",
        "pathFromNode": "[Bd] 승_{path} from {label}_文",
        "help1": "[BY] 승_This chart represents paths taken from one state to another._文",
        "help2": "[Bh] 승_Each node, shaped as a box, represents a state in the path._文",
        "help3": "[Bk] 승_Tapping or clicking a node will provide additional options to modify the chart:_文",
        "focusHelp": "[Bm] 승_Shows paths coming into and going out of node_文",
        "expandHelp": "[Bi] 승_Shows additional paths coming or going from the node_文",
        "collapseHelp": "[Bl] 승_Removes paths coming or going from the node_文"
    },
    "sunburst": {
        "audience": "[Ci] 승_Audience_文",
        "audience2+": "[Ce] 승_Audiences_文",
        "category": "[Ch] 승_Category_文",
        "category2+": "[Cf] 승_Categories_文",
        "metric": "[Cd] 승_Metric_文",
        "metric2+": "[Cg] 승_Metrics_文",
        "primarymetric": "[Cj] 승_Primary Metric_文",
        "secondarymetric": "[Cl] 승_Secondary Metric_文",
        "secondarymetric2+": "[Ck] 승_Secondary Metrics_文",
        "secondarymetrichelp": "[Cm] 승_Click metric to toggle height_文",
        "secondarymetrichelp2+": "[Cn] 승_Click metrics to toggle height_文",
        "emptyFirstMetric": "[B2] 승_The first metric has no values. Please pick a different metric._文",
        "total": "[B7] 승_Total_文",
        "zoomAction": "[By] 승_Double-click to Zoom in._文",
        "moreAction": "[B5] 승_Click for more options._文",
        "zoomin": "[Bz] 승_Zoom In_文",
        "zoomout": "[Bs] 승_Zoom Out_文",
        "hide": "[Bt] 승_Hide_文",
        "hideall": "[Bw] 승_Hide All_文",
        "hideother": "[Bu] 승_Hide Other_文",
        "hidden": "[B4] 승_{value} Hidden Item_文",
        "hidden2+": "[B0] 승_{value} Hidden Items_文",
        "topresults": "[B8] 승_top {value}_文",
        "color": "[Bx] 승_Color_文",
        "height": "[Bv] 승_Height_文",
        "both": "[B6] 승_Both_文",
        "none": "[B3] 승_None_文",
        "mapmetric": "[B9] 승_Show {metric} as:_文",
        "percmetric": "[B1] 승_{percent} of {metric}_文",
        "mobilescroll": "[Co] 승_&#x25BC scroll for details_文"
    },
    "flower": {
        "joy": "[BU] 승_Joy_文",
        "admiration": "[BT] 승_Admiration_文",
        "fear": "[BQ] 승_Fear_文",
        "surprise": "[BR] 승_Surprise_文",
        "sadness": "[BO] 승_Sadness_文",
        "disgust": "[BP] 승_Disgust_文",
        "anger": "[BV] 승_Anger_文",
        "anticipation": "[BS] 승_Anticipation_文"
    },
    "venn": {
        "definedAudience": "[B+] 승_Defined Audience_文"
    },
    "funnel": {
        "step": "[C3] 승_Step_文",
        "segment": "[C4] 승_Segment_文",
        "conversion": "[C1] 승_Conversion_文",
        "fallout": "[C5] 승_Fallout_文",
        "average": "[C2] 승_Average_文"
    }
}, 'labels');

global.cloudViz.localeDefinition('zz-ZZ', {
    "shortFormat": {
        "second": "[DB] 승_:%S_文",
        "minute": "[DC] 승_%I:%M_文",
        "hour": "[Z] 승_%I %p_文",
        "day": "%e",
        "week": "%e",
        "month": "%b",
        "quarter": "%b",
        "year": "[d] 승_%Y_文",
        "fallback": "%e"
    },
    "mediumFormat": {
        "second": "[DA] 승_%M:%S_文",
        "minute": "[C/] 승_%I:%M %p_文",
        "hour": "[S] 승_%I %p_文",
        "day": "[Q] 승_%a %e_文",
        "week": "[T] 승_%a %e_文",
        "month": "%b",
        "quarter": "%b",
        "year": "[U] 승_%Y_文",
        "fallback": "[V] 승_%a %e_文"
    },
    "longFormat": {
        "second": "[C+] 승_%M:%S_文",
        "minute": "[C9] 승_%I:%M %p_文",
        "hour": "[P] 승_%I %p %a %e_文",
        "day": "[M] 승_%A %e_文",
        "week": "[O] 승_%A %e_文",
        "month": "[L] 승_%B_文",
        "quarter": "[K] 승_%B_文",
        "year": "[J] 승_%Y_文",
        "fallback": "[N] 승_%I %p %a %e_文"
    },
    "fullFormat": {
        "second": "[C6] 승_%I:%M:%S %p_文",
        "minute": "[C8] 승_%I:%M %p %a %e_文",
        "hour": "[D] 승_%I %p %a %e_文",
        "day": "[C] 승_%A %e %B_文",
        "week": "[B] 승_%A %e %B_文",
        "month": "[G] 승_%B %Y_文",
        "quarter": "[E] 승_%B %Y_文",
        "year": "[I] 승_%Y_文",
        "fallback": "[F] 승_%b %e, %Y_文",
        "condensed": "[H] 승_%m/%d/%Y_文",
        "timestamp": "[C7] 승_%m/%d/%Y %I:%M:%S %p_文"
    }
}, 'dateFormat');

global.cloudViz.localeDefinition('zz-ZZ', {
    "decimalSeparator": "[CC] 승_._文",
    "groupSeparator": "[CD] 승_,_文",
    "negativePattern": "[CE] 승_-{number}_文",
    "percent": {
        "symbol": "[CF] 승_%_文",
        "positivePattern": "[CG] 승_{number}{symbol}_文",
        "negativePattern": "[CH] 승_-{number}{symbol}_文"
    },
    "currency": {
        "symbol": "[B/] 승_$_文",
        "positivePattern": "[CA] 승_{symbol}{number}_文",
        "negativePattern": "[CB] 승_-{symbol}{number}_文"
    }
}, 'numberFormat');

global.cloudViz.localeDefinition('zz-ZZ', {
    "singular": {
        "second": "[CX] 승_second_文",
        "minute": "[CY] 승_minute_文",
        "hour": "[CZ] 승_hour_文",
        "day": "[CV] 승_day_文",
        "week": "[Ca] 승_week_文",
        "month": "[Cb] 승_month_文",
        "year": "[CW] 승_year_文"
    },
    "plural": {
        "second": "[CS] 승_seconds_文",
        "minute": "[CP] 승_minutes_文",
        "hour": "[Cc] 승_hours_文",
        "day": "[CR] 승_days_文",
        "week": "[CQ] 승_weeks_文",
        "month": "[CT] 승_months_文",
        "year": "[CU] 승_years_文"
    },
    "abbreviation": {
        "second": "[CJ] 승_s_文",
        "minute": "[CO] 승_min_文",
        "hour": "[CK] 승_h_文",
        "day": "[CI] 승_d_文",
        "week": "[CL] 승_w_文",
        "month": "[CM] 승_mon_文",
        "year": "[CN] 승_y_文"
    }
}, 'time');

}(this));

